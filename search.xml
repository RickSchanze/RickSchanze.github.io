<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EffectiveC++(1)(1~4)</title>
    <url>/2022/03/04/Effective%20C++/2022-03-04-EffectiveC++(1)(1~4)/</url>
    <content><![CDATA[<h2 id="01-视c-为一个语言联邦"><strong>01:视C++为一个语言联邦</strong></h2>
<p><strong>四个次语言:</strong></p>
<ul>
<li>C</li>
<li>Object-Oriented C++（面向对象C++）</li>
<li>Template C++</li>
<li>STL</li>
</ul>
<h2 id="02-尽量以-const-enum-inline代替-define">02:尽量以 const, enum, inline代替 #define</h2>
<p>使用#define时，编译器看不到你所define的变量，那么当报错时，为了查找理解你所定义的，就需要耗费大量时间</p>
<pre class="line-numbers language-none"><code class="language-none">#define ASPECT_RATIO 1.653　　　　&#x2F;&#x2F;aspect_ratio并未进入符号表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当以常量代替#define时，有两种特殊情况</p>
<ul>
<li><strong>定义常量指针</strong></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">const char* const authoerNameo &#x3D; &quot;ScottMeyers&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><strong><strong>定义class专有常量</strong></strong></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;为了将常量作用域限制于class内，需要static
class GamePlayer&#123;
    static const int NumTurns &#x3D; 5;&#x2F;&#x2F;常量声明式
    int scores[NumTurns];&#x2F;&#x2F;使用常量    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于形似函数的宏(如#definr Test(a,b) f((a)&gt;(b)?(a):(b)))，可以用inline代替</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;
inline void callWithMax(const T&amp; a, const T&amp; b)
&#123;
    f(a &gt; b ? a: b);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="03-尽可能使用const">03:尽可能使用const</h2>
<p>const的几种不同用法</p>
<pre class="line-numbers language-none"><code class="language-none">char greeting[] &#x3D; &quot;hewwl&quot;;
char* p &#x3D; greeting;
const char* p &#x3D;greeting;    &#x2F;&#x2F;non-const pointer, const data
char* const p &#x3D; greeting;   &#x2F;&#x2F;const pointer, non-const data
const char* const p &#x3D; greeting; &#x2F;&#x2F;const pointer, const data
&#x2F;&#x2F;注: const Widget* pw与Widget const* pw等价<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>令函数返回一个常量值，可以降低因错误而造成的意外，如：</p>
<pre class="line-numbers language-none"><code class="language-none">class Rational&#123;&#125;;
const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);
&#x2F;&#x2F;如果没有const可能会造成
Rational a,b,c;
if (a*b &#x3D; c)
&#123;
    &#x2F;* code *&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>另：双目运算符operator*想拥有两个参数，必须在类外定义，因为类内有隐式this指针</strong></p>
<p><strong>当const 和 non-const成员函数有着实质等价的实现时，令non-const版本调用const版本来避免代码重复</strong></p>
<p>class TextBlock { public: const char&amp; operator[](std::size_t position) const{ //过程1 //过程2 //过程3 return text[position]; } char&amp; operator[](std::size_t position){ return const_cast&lt;char&amp;&gt; (static_cast&lt;const TextBlock&amp;&gt; (*this)[position]); } }; //注:不能用const调用non-const,因为non-const可能改变对象</p>
<h2 id="04-确定对象使用前已被初始化">04:确定对象使用前已被初始化</h2>
<li>
<h4>**为内置对象进行手工初始化**</h4>
</li>
<p>内置对象不进行手工初始化的话很可能得到随机值，而浪费性能</p>
<li>
<h4>**构造函数使用成员初始化列表，而不是赋值**</h4>
</li>
<pre class="line-numbers language-none"><code class="language-none">class A
&#123;
private:
    int member1;
    double member2;
    std::string member3;

public:
    &#x2F;&#x2F;使用初始值列表
    A() : member1(0), member2(0), member3(std::string())&#123;&#125;
    &#x2F;&#x2F;赋值初始化
    A()&#123;
        member1 &#x3D; 0;
        member2 &#x3D; 0;
        member3 &#x3D; &quot;&quot;;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用赋值初始化的构造函数在赋值前还会调用default的构造函数，因此会造成性能流失</p>
<li>
<h4>**以本地静态对象代替非本地静态对象**</h4>
</li>
<p>**　　**这是为避免跨编译单元初始化次序问题而提出的解决方案，简单来说就是：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;a.cpp
class hen&#123;
    public:
    std::size_t makeEggs();
&#125;;
hen ji;&#x2F;&#x2F;non-local static

&#x2F;&#x2F;b.cpp
extern hen ji;
class eggs&#123;
    public:
    void eggs()
    &#123;
        ji.makeEggs();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时若调用eggs构造函数，而ji未初始化，则会造成严重问题（多编译文件初始化次序不确定）</p>
<p>而</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;a.cpp
class hen&#123;
    public:
    std::size_t makeEggs();
&#125;;
hen&amp; chicken()
&#123;
    static hen ji
    return ji;
&#125;;

&#x2F;&#x2F;b.cpp
extern hen ji;
class eggs&#123;
    public:
    eggs()
    &#123;
        chicken().makeEggs();
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不存在问题，原因简单分析:</p>
<p>local static 的做法 &gt; 调用 eggs() &gt; 调用 egg 构造函数 &gt; 调用 ji() &gt; 调用 ji 的构造函数 &gt; 成功</p>
<p><a href="https://blog.csdn.net/pursue_my_life/article/details/80950580">参考链接</a></p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveC++(2)(5~12)</title>
    <url>/2022/03/05/Effective%20C++/2022-03-05-EffectiveC++(2)(5~12)/</url>
    <content><![CDATA[<h2 id="05-了解c-默默编写并调用了哪些函数">05:了解C++默默编写并调用了哪些函数</h2>
<p>如果定义一个类</p>
<pre class="line-numbers language-none"><code class="language-none">class Empty&#123;&#125;；
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>相当于定义了</p>
<pre class="line-numbers language-none"><code class="language-none">class Empty&#123;
    public:
    Empty()&#123;&#125;;　　&#x2F;&#x2F;default构造
    Empty(const Empty&amp; rhs)&#123;&#125;;　　&#x2F;&#x2F;拷贝构造
    ~Empty();　　&#x2F;&#x2F;编译器合成的析构函数　　Empty&amp; operator&#x3D;(const Empty&amp; rhs)&#123;&#125;;&#x2F;&#x2F;拷贝赋值运算符
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于这本书标准不是C++11，有关默认移动构造和移动赋值函数等我了解了之后再补充</p>
<p>如果定义了带有参数的构造函数，则不再合成默认构造函数，但可以显式要求编译器合成</p>
<pre class="line-numbers language-none"><code class="language-none">Empty() &#x3D; default;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当类内含有引用成员或cont的成员时，编译器拒绝生成默认拷贝赋值运算符。</p>
<p>如果某个基类的拷贝赋值运算符为private,则编译器拒绝为其子类生成默认拷贝运算符</p>
<p><strong>注意：引用只能定义一次，定义后不能改变它的指向</strong></p>
<h2 id="06：若不想使用编译器自动生成的函数-就该明确拒绝"><strong>06：若不想使用编译器自动生成的函数，就该明确拒绝</strong></h2>
<p>书上给出的方法是定义一个基类，该基类的拷贝构造和拷贝赋值为private，另你的类继承于该基类，则编译器无法合成默认拷贝构造和拷贝赋值函数。</p>
<p>但是在C++11中，<strong>只需要这么在函数后加上delete</strong></p>
<pre class="line-numbers language-none"><code class="language-none">class Empty&#123;
    public:
    Empty()&#123;&#125;;
    Empty(const Empty&amp;) &#x3D; delete;
    Empty&amp; operator&#x3D;(const Empty&amp;) &#x3D; delete;
    ~Empty();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="07-为多态基类声明virtual析构函数">07:为多态基类声明virtual析构函数</h2>
<p>多态基类是为了通过基类指针来控制派生类对象</p>
<ul>
<li><strong>polymorphic(多态)基类应声明一个virtual析构函数， 任何一个类带有任何virtual函数，它就应该用于一个virtual析构函数</strong></li>
</ul>
<p>带有虚构函数的类一般作为基类使用，而如果该类没有虚析构函数，当其派生类对象执行析构时，会导致局部销毁，进而导致内存泄漏</p>
<pre class="line-numbers language-none"><code class="language-none">class Base
&#123;
public:
    Base() &#x3D; default;
    int testBase;
&#125;;

class Derived : public Base
&#123;
public:
    int testDerived;
&#125;;
int main()
&#123;
    Base* A &#x3D; new Base;
    Derived* B &#x3D; new Derived;
    A &#x3D; B;  
    delete A;       &#x2F;&#x2F;执行此语句时只会删掉Base部分的成员，而Derived的部分不会被删除
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意<strong>即使基类指针指向了派生类对象，该指针也只能操作基类成员，因此要定义虚函数来操作派生类对象。</strong></p>
<ul>
<li><strong>类的设计如不不是为了作为基类使用，或不是为了多态性，则不应声明virtual析构函数</strong></li>
</ul>
<p>因为会使对象占用内存增加。同时，为了让你的非基类、非多态用途的类不被继承，可以<strong>使用final关键字</strong>来禁止其派生。</p>
<pre class="line-numbers language-none"><code class="language-none">class NoDerived final
&#123;
     ...  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="08-别让异常逃离虚构函数">08:别让异常逃离虚构函数</h2>
<ul>
<li>
<p><strong>析构函数觉得不能抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或接受程序。</strong></p>
</li>
<li>
<p><strong>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应提供一个普通函数（而非在析构函数中）执行该操作</strong></p>
</li>
</ul>
<p>对于异常处理不熟悉，先记录，以后有机会补充</p>
<h2 id="09-绝不在构造和析构过程中调用virtual函数">09:绝不在构造和析构过程中调用virtual函数</h2>
<p>因为这类调用不会下降至派生类</p>
<p>考虑：</p>
<pre class="line-numbers language-none"><code class="language-none">class Transaction&#123;
public:
    Transaction();
    virtual void logTransaction() const &#x3D; 0;
&#125;;

Transaction::Transaction()
&#123;
    logTransaction();
&#125;

class BuyTransaction : public Transaction&#123;
public:
    virtual void logTransaction() const;
&#125;;

BuyTransaction a;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在定义a时，会先构造基类Transaction，此时调用的将会是基类的logTransaction()，因为在派生类对象的基类构造期间对象类型为基类而非派生类。</p>
<p>因此构造函数和析构函数都不能调用virtual函数</p>
<p>一种解决方案：</p>
<pre class="line-numbers language-none"><code class="language-none">class Transaction
&#123;
public:
    explicit Transaction(const std::string &amp;logInfo);
    void logTransaction(const std::string &amp;logInfo) const; &#x2F;&#x2F;非虚函数
&#125;;

Transaction::Transaction(const std::string &amp;logInfo)
&#123;
    &#x2F;&#x2F;...
    logTransaction(logInfo);
&#125;

class BuyTransaction : public Transaction
&#123;
public:
    BuyTransaction(parameters) : Transaction(createLogString(parameters)) &#123;&#125;

private:
    static std::string createLogString(parameters);
&#125;;
&#x2F;&#x2F;令派生类将必要构造信息向上传给基类狗在函数
&#x2F;&#x2F;从而让构造函数拜托虚函数
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="10-令operator-返回一个reference-to-this">10:令operator=返回一个reference to *this</h2>
<p>为了实现连锁赋值，即<strong>a = b = c = 15</strong>这种赋值，则需要这么做</p>
<pre class="line-numbers language-none"><code class="language-none">class Widget&#123;
public:
    Widget&amp; operator&#x3D;(const Widget&amp; rhs)
    &#123;
         ...
         return *this;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此协议使用于所有赋值运算，+= , -= , …</p>
<h2 id="11-在operator-中处理-自我赋值">11:在operator=中处理&quot;自我赋值&quot;</h2>
<pre class="line-numbers language-none"><code class="language-none">class widget
&#123;
public:
    widget &amp;operator&#x3D;(const widget &amp;rhs);

private:
    widget *wp;
&#125;;

widget &amp;widget::operator&#x3D;(const widget &amp;rhs)
&#123;
    delete wp;
    wp &#x3D; new widget(*rhs.wp);
    return *this;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当自我赋值时，会造成未定义行为，因为rhs在被删掉后还在使用，有三种方法解决</p>
<p><strong>使用证同测试来避免这个问题</strong></p>
<pre class="line-numbers language-none"><code class="language-none">widget &amp;widget::operator&#x3D;(const widget &amp;rhs)
&#123;
    if (this &#x3D;&#x3D; &amp;rhs)
    &#123;
        return *this;
    &#125;
    
    delete wp;
    wp &#x3D; new widget(*rhs.wp);
    return *this;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>精心周到的语句排序</strong></p>
<pre class="line-numbers language-none"><code class="language-none">widget &amp;widget::operator&#x3D;(const widget &amp;rhs)
&#123;
    widget* old &#x3D; wp;
    wp &#x3D; new widget(*rhs.wp);
    delete old;
    return *this;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>copy and swap技术</strong></p>
<pre class="line-numbers language-none"><code class="language-none">class widget
&#123;
public:
    widget &amp;operator&#x3D;(const widget &amp;rhs);
    void swap(widget&amp; rhs); &#x2F;&#x2F;交换*this和rhs的数据

private:
    widget *wp;
&#125;;

widget &amp;widget::operator&#x3D;(const widget &amp;rhs)
&#123;
    widget temp(rhs);
    swap(temp);
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或使用值传递的方式，这里会产生副本，并让*this与副本的数据互换</p>
<pre class="line-numbers language-none"><code class="language-none">widget&amp; operator&#x3D;(widget rhs)
&#123;
    swap(rhs);
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="12-复制对象时勿忘其每一个成分">12:复制对象时勿忘其每一个成分</h2>
<p>考虑如下代码</p>
<pre class="line-numbers language-none"><code class="language-none">class Base
&#123;
private:
    int base;
&#125;;

class Derived : public Base
&#123;
public:
    Derived(const Derived &amp;rhs);
    Derived &amp;operator&#x3D;(const Derived &amp;rhs);

private:
    int derived;
&#125;;

Derived::Derived(const Derived &amp;rhs) : derived(rhs.derived)
&#123;
    &#x2F;&#x2F;do something
&#125;

Derived&amp; Derived::operator&#x3D;(const Derived&amp; rhs)
&#123;
    &#x2F;&#x2F;do something
    derived &#x3D; rhs.derived;
    return *this;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它们并未对Base部分进行初始化，会调用默认构造函数，而这往往造成不想要的结果。</p>
<p>考虑到Base部分往往是private的，可以使用相应base部分的拷贝构造函数</p>
<pre class="line-numbers language-none"><code class="language-none">Derived::Derived(const Derived &amp;rhs) : Base(rhs), derived(rhs.derived)
&#123;
    &#x2F;&#x2F;do something
&#125;

Derived&amp; Derived::operator&#x3D;(const Derived&amp; rhs)
&#123;
    &#x2F;&#x2F;do something
    Base::operator&#x3D;(rhs);
    derived &#x3D; rhs.derived;
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QGuiApplication</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QGuiApplication/</url>
    <content><![CDATA[<h1 id="primaryscreen">primaryScreen()</h1>
<p>获取应用主屏幕</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QScreen</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QScreen/</url>
    <content><![CDATA[<h1 id="availablegeometry">availableGeometry()</h1>
<p>获取应用程序可用区域</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QWebEngineView</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QWebEngineView/</url>
    <content><![CDATA[<h1 id="page">page()</h1>
<p>返回一个指向页面的指针，为QWebEnginePage*</p>
<h1 id="load">load()</h1>
<p>加载特定URL并展示它，不过视图保持不变，直到到达足够的数据以显示新 URL</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QSystemTrayIcon</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QSystemTrayIcon/</url>
    <content><![CDATA[<p>此类用于在系统托盘中添加应用图标</p>
<h1 id="tooltip">toolTip</h1>
<p>托盘工具提示，你把鼠标放在图标上时出现的文字</p>
<p>使用setTooTip()设置</p>
<h1 id="show">show()</h1>
<p>在托盘显示你对象拥有的图标</p>
<h1 id="setcontextmenu-qmenu">setContextMenu(Qmenu*)</h1>
<p>设置用户通过鼠标事件来弹出的菜单（比如右键弹出菜单）</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QWidget</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QWidget/</url>
    <content><![CDATA[<h1 id="qt-wa-translucentbackground">Qt::WA_TranslucentBackground</h1>
<p>为你的控件设置透明背景，因为这个标志会使你的控件拥有一个阿尔法通道。这个属性一旦被设置，<strong>WA_NoSystemBackground</strong>则也被设置。在Windows上你的控件也需要设置窗口标志<strong>Qt::FramelessWindowHint</strong></p>
<h1 id="qt-wa-nosystembackground">Qt::WA_NoSystemBackground</h1>
<p>这个标志被设置意味着你的控件没有背景，即当控件接受绘画事件时，背景不会被自动重绘。</p>
<p>注意：不像<strong>WA_OpaquePaintEvent</strong>, 新曝光区域的背景永远不会被填充</p>
<h1 id="qt-wa-opaquepaintevent">Qt::WA_OpaquePaintEvent</h1>
<p>收到绘制事件时，绘制控件拥有的所有像素。但是不会重绘之前绘制的东西</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QPainter</title>
    <url>/2022/03/02/QtAPI/2022-03-02-QPainter/</url>
    <content><![CDATA[<h2 id="void-translate-const-qpointf-offset">void translate(const QPointF &amp;offset)</h2>
<p>按照给定偏移量平移坐标系(重设坐标原点)</p>
<h2 id="void-scale-qreal-sx-qreal-sy">void scale(qreal sx, qreal sy)</h2>
<p>按 （sx， sy） 缩放坐标系。</p>
<h2 id="void-qpainter-rotate-qreal-angle">void QPainter::rotate(qreal angle)</h2>
<p>顺时针旋转坐标系。给定的角度参数以度为单位。</p>
<h2 id="void-qpainter-drawpixmap-const-qrectf-target-const-qpixmap-pixmap-const-qrectf-source">void QPainter::drawPixmap(const QRectF &amp;target, const QPixmap &amp;pixmap, const QRectF &amp;source)</h2>
<p>将给定位图的矩形部分源绘制到绘制设备中的给定目标中</p>
<p>此函数有重载，详请查看帮助文档</p>
<p>此函数主要用于绘制图片</p>
<h2 id="void-qpainter-drawpolygon-const-qpointf-points-int-pointcount-qt-fillrule-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const QPointF *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill)</h2>
<p>使用points里的前pointCount个点进行多边形绘图</p>
<p>第一个点隐式连接到最后一个点，并且多边形用当前画笔填充。<strong>Qt::FillRule</strong></p>
<table>
<thead>
<tr>
<th>Qt::OddEvenFill</th>
<th>0</th>
<th>指定该区域使用奇偶填充规则填充。有了这条规则，我们可以用下面的方法来确定一个点是否在形状内部。从这一点画一条水平线到形状外面的一个位置，并计算交点的数量。如果交点个数是奇数，则该点在形状内。此模式为默认模式。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::WindingFill</td>
<td>1</td>
<td>Specifies that the region is filled using the non zero winding rule. With this rule, we determine whether a point is inside the shape by using the following method. Draw a horizontal line from the point to a location outside the shape. Determine whether the direction of the line at each intersection point is up or down. The winding number is determined by summing the direction of each intersection. If the number is non zero, the point is inside the shape. This fill mode can also in most cases be considered as the intersection of closed shapes.</td>
</tr>
</tbody>
</table>
<h2 id="bool-qpainter-begin-qpaintdevice-device">bool QPainter::begin(QPaintDevice *device)</h2>
<p>开始在绘图设备上绘图，如果成功返回true;否则返回false。</p>
<p>请注意，当调用begin()时，所有的painter的设置(setPen()， setBrush()等)都被重置为默认值。</p>
<p>请注意，大多数情况下，您可以使用其中一个构造函数来代替begin()，end()函数会在painter销毁时自动进行</p>
<p><strong>警告:一个绘画装置一次只能由一个画家进行绘画。</strong></p>
<p><strong>警告:不支持在QImage::Format_Indexed8格式的QImage上绘画。</strong></p>
<h2 id="bool-qpainter-end">bool QPainter::end()</h2>
<p>绘制结束。绘制时使用的任何资源将被释放。通常不需要调用它，因为它是由析构函数调用的。</p>
<p>如果绘制器不再活动，则返回true;否则返回false。</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QList</title>
    <url>/2022/03/04/QtAPI/2022-03-04-QList/</url>
    <content><![CDATA[<h2 id="removelast"><strong><strong>removeLast()</strong></strong></h2>
<p>从一个QList中拿走最后一个，自动调整大小，但是，<strong>如果存储的是指针，则不会不delete它</strong></p>
<h2 id="int-qlist-indexof-const-t-value-int-from-const"><strong><strong>int QList::indexOf(const T &amp;value, int from = …) const</strong></strong></h2>
<p>返回列表中第一个值出现的索引位置，从索引位置from向后搜索。如果没有匹配项，则返回-1。</p>
<p>此函数要求值类型具有operator==()的实现。</p>
<p><strong>请注意，QList使用基于0的索引，就像c++数组一样。除上面提到的值外，不支持负索引</strong></p>
<h2 id="const-t-qlist-at-int-i-const"><strong><strong>const T &amp;QList::at(int i) const</strong></strong></h2>
<p>返回列表中索引位置i处的项。我必须是一个有效的索引位置在列表(即，0 &lt;= i &lt; size())。</p>
<p>这个函数非常快(常数时间)。</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QAbstractButton</title>
    <url>/2022/03/05/QtAPI/2022-03-05-QAbstractButton/</url>
    <content><![CDATA[<h1 id="此章用于所有与button有关的控件"><strong>此章用于所有与button有关的控件</strong></h1>
<h2 id="ischeck">isCheck()</h2>
<p>如果这个按钮被选中，则返回true。只有checkable的button才有这个，默认为false</p>
<h2 id="text"><strong>text()</strong></h2>
<p>获取这个按钮的文字</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QPixmap</title>
    <url>/2022/03/05/QtAPI/2022-03-05-QPixmap/</url>
    <content><![CDATA[<h2 id="bool-qpixmap-load-const-qstring-filename-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor">*<em>bool QPixmap::load(const QString &amp;fileName, const char <em>format = nullptr, Qt::ImageConversionFlags flags = Qt::AutoColor)</em></em></h2>
<p>从指定文件名的文件中加载位图。如果位图成功加载，返回true;否则位图无效并返回false。</p>
<h2 id="qpixmap-qpixmap-scaled-const-qsize-size-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const"><strong>QPixmap QPixmap::scaled(const QSize &amp;size, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</strong></h2>
<p>使用由aspectRatioMode和transformMode指定的宽高比和转换模式，将位图缩放到给定的大小</p>
<p><strong>注意：此函数是使用值传递，因此不会改变传进去的pixmap,要想真正对pixmap改变，还请另赋值</strong></p>
<h3 id="qt-aspectratiomode">Qt::AspectRatioMode</h3>
<table>
<thead>
<tr>
<th><strong>Qt::IgnoreAspectRatio</strong></th>
<th><strong>0</strong></th>
<th><strong>大小可以自由缩放。长宽比没有限制。</strong></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Qt::KeepAspectRatio</strong></td>
<td><strong>1</strong></td>
<td><strong>在给定的矩形内，将尺寸缩放为尽可能大的矩形，并保留长宽比。</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Qt::KeepAspectRatioByExpanding</strong></td>
<td><strong>2</strong></td>
<td><strong>尺寸被缩放到一个矩形，在给定的矩形之外尽可能小，并保持长宽比。</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="transformmode">transformMode</h3>
<table>
<thead>
<tr>
<th><strong>Qt::FastTransformation</strong></th>
<th><strong>0</strong></th>
<th><strong>转换是快速执行的，没有平滑处理。</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Qt::SmoothTransformation</strong></td>
<td><strong>1</strong></td>
<td><strong>得到的图像使用双线性滤波进行变换。(平滑处理了)</strong></td>
</tr>
</tbody>
</table>
<h2 id="void-qpixmap-fill-const-qcolor-color-qt-white">void QPixmap::fill(const QColor &amp;color = Qt::white)</h2>
<p>用给定的颜色填充像素图。</p>
<p>当pixmap已经被绘制在设备上时，此函数的行为是未定义的</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QFontDatabase</title>
    <url>/2022/03/06/QtAPI/2022-03-06-QFontDatabase/</url>
    <content><![CDATA[<h2 id="qstringlist-qfontdatabase-families-qfontdatabase-writingsystem-writingsystem-any-const"><strong>QStringList QFontDatabase::families(QFontDatabase::WritingSystem writingSystem = Any) const</strong></h2>
<p>返回支持writingSystem的可用字体族的排序列表。</p>
<p>如果一个字体族的名字对应着不同公司出的字体，则该字体返回的名称为family [foundry]。例如:Times [Adobe]，Times [Cronyx]，Palatino。</p>
<h2 id="int-qfontdatabase-addapplicationfont-const-qstring-filename"><strong>int QFontDatabase::addApplicationFont(const QString &amp;fileName)</strong></h2>
<p>从fileName指定的文件加载字体，并使其可用于应用程序。返回一个ID，可以使用removeApplicationFont()再次删除字体，或者检索字体中包含的家族名称列表。</p>
<p>如果字体无法加载，函数返回-1。</p>
<p>目前只支持TrueType字体、TrueType字体集合和OpenType字体。</p>
<h2 id="qstringlist-qfontdatabase-applicationfontfamilies-int-id"><strong>QStringList QFontDatabase::applicationFontFamilies(int id)</strong></h2>
<p>返回由id标识的给定应用程序字体的字体族列表。</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QFont</title>
    <url>/2022/03/06/QtAPI/2022-03-06-QFont/</url>
    <content><![CDATA[<h2 id="void-qfont-sethintingpreference-qfont-hintingpreference-hintingpreference"><strong>void QFont::setHintingPreference(QFont::HintingPreference hintingPreference)</strong></h2>
<p><strong>将符号的提示级别的首选项设置为hintingPreference。这是对底层字体渲染系统使用某种程度的提示的提示，并且跨平台有不同的支持。</strong></p>
<p><strong>QFont::HintingPreference</strong></p>
<table>
<thead>
<tr>
<th>QFont::PreferDefaultHinting</th>
<th>0</th>
<th>使用目标平台的默认提示级别。</th>
</tr>
</thead>
<tbody>
<tr>
<td>QFont::PreferNoHinting</td>
<td>1</td>
<td>如果可能的话,在渲染文本时不要提示字形的轮廓。文本布局将是排版准确和可扩展的,使用与打印时相同的指标。</td>
</tr>
<tr>
<td>QFont::PreferVerticalHinting</td>
<td>2</td>
<td>如果可能的话,渲染文本时不要有水平提示,但在垂直方向上将字形与像素网格对齐。在密度过低而无法准确渲染字形的显示器上,文字会显得更清晰。但由于字形的水平度量是没有提示的,所以文本的布局将可以扩展到更高密度的设备上(如打印机),而不会影响换行符等细节。</td>
</tr>
<tr>
<td>QFont::PreferFullHinting</td>
<td>3</td>
<td>如果可能的话,在水平和垂直方向上渲染带有提示的文本。文本将被改变,以优化目标设备上的可读性,但由于指标将取决于文本的目标尺寸,字形、换行符和其他排版细节的位置将不按比例排列,这意味着文本布局在不同像素密度的设备上可能会有不同的外观。</td>
</tr>
</tbody>
</table>
<p><strong>翻译不够精准还请看官方文档</strong></p>
<h2 id="void-qfont-setpixelsize-int-pixelsize">void QFont::setPixelSize(int pixelSize)</h2>
<p>将字体大小设置为pixelSize像素。</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QPolygon</title>
    <url>/2022/03/06/QtAPI/2022-03-06-QPolygon/</url>
    <content><![CDATA[<h2 id="void-qpolygon-setpoints-int-npoints-const-int-points">void QPolygon::setPoints(int nPoints, const int *points)</h2>
<p>根据数组设置多边形的点。参数1是设置点的个数。有函数重载</p>
<h2 id="void-putpoints-int-index-int-npoints-int-firstx-int-firsty"><strong>void putPoints(int index, int nPoints, int firstx, int firsty, …)</strong></h2>
<p>将变量参数列表中的点从给定索引添加到当前多边形中。参数1是添加起始的索引，参数2是添加的点的个数，参数3、4是添加的第1个点的x、y…</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt动画框架使用</title>
    <url>/2022/05/26/Qt%E4%BD%BF%E7%94%A8/2022-05-26-Qt%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>最近在考虑上位机的问题，在使用纯Qt + C++ + OpenCV和使用OpenCV + C# 中徘徊，但最后考虑到我不太会C#，就选择了Qt,因此怎么也该来学习学习了。<br>
　　本文算是一篇转载文章。<br>
　　原文<a href="https://blog.csdn.net/qinhoupingss/article/details/47961507">点这里</a>。<br>
<img src="https://s2.loli.net/2022/05/28/g5xc4f3GWOvohUD.gif" alt="1.gif"></p>
<h2 id="qt-animation-framework继承体系">Qt Animation Framework继承体系</h2>
<p>Qt有一套专门的动画框架，其继承体系如下图。<br>
<img src="https://s2.loli.net/2022/05/28/FXdBOjHKyvqEMC8.jpg" alt="2.jpg"><br>
　　Qt动画框架基石由<strong>QAbstractAnimation</strong>以及它的两个子类<strong>QVariantAnimation</strong>和<strong>QAnimationGroup</strong>组成。<strong>QAbstractAnimation</strong>类是所有动画类的祖先。它包含了一些在框架中被普遍使用的基本功能；尤其是启动、停止和暂停动画功能。它也接收定时触发通知。</p>
<p>Qt动画框架更是提供了<strong>QPropertyAnimation</strong>类，该类继承于<strong>QVariantAnimation</strong>类，用于对Qt属性的动画操作(Qt属性系统是Qt元对象系统的一部分)。<strong>QPropertyAnimation</strong>类使用缓和曲线算法对属性进行插值演化操作。因此当你想动画改变一个值时，你就声明该值为一个属性值并且使该类为成为一个<strong>QObject</strong>对象。这给我们提供了很大的方便性去动画操作现有的部件和其他的<strong>QObject</strong>对象。</p>
<p>复杂动画可以通过构建Q<strong>AbstractAnimation</strong>树形结构来构造。该树主要使用<strong>QAnimationGroup</strong>，<strong>QAnimationGroup</strong>类是一个包含其他动画类的容器类；同时<strong>QAnimationGroup</strong>类也是<strong>QAbstractAnimation</strong>类的子类，因此一个容器可以包含其他容器。</p>
<p>Qt动画框架既是独立的一部分，也是Qt状态机框架的一部分。Qt状态机框架提供一个状态用来行使动画。当<strong>QState</strong>进入或者退出时可以改变属性，当这个动画状态提供了一个<strong>QPropertyAnimatio</strong>时，则动画状态即在这些值之间进行插值衍化操作。</p>
<table>
<thead>
<tr>
<th>QAbstractAnimation</th>
<th>所有动画类的基类</th>
</tr>
</thead>
<tbody>
<tr>
<td>QAnimationGroup</td>
<td>动画容器类的抽象基类</td>
</tr>
<tr>
<td>QEasingCurve</td>
<td>动画控制的缓和曲线类</td>
</tr>
<tr>
<td>QParallelAnimationGroup</td>
<td>并行动画容器</td>
</tr>
<tr>
<td>QPauseAnimation</td>
<td>QSequentialAnimationGroup对象暂停延迟</td>
</tr>
<tr>
<td>QPropertyAnimation</td>
<td>Qt动画属性操作</td>
</tr>
<tr>
<td>QSequentialAnimationGroup</td>
<td>串行动画容器</td>
</tr>
<tr>
<td>QTimeLine</td>
<td>动画控制的时间片类</td>
</tr>
<tr>
<td>QVariantAnimation</td>
<td>动画类的抽象基类</td>
</tr>
</tbody>
</table>
<h2 id="qt动画属性">Qt动画属性</h2>
<p>正如上述所提到的，QPropertyAnimation类能够修改Qt属性值。正是该类用于改变动画属性值；事实上，它的基类QVariantAnimation是一个抽象类，所以QVariantAnimation不能被直接使用。<br>
　　我们选用Qt动画属性的一个主要原因是由于它给了我们很大的自由性去动画操作已经存在的类，尤其是拥有bounds、colors等属性的QWidget类(QWidget能被嵌入到QGraphicsView类)。我们看看一个小例子：</p>
<pre class="line-numbers language-none"><code class="language-none">void QtWidgetsApplication1::on_btn_clicked()
&#123;
　　QPropertyAnimation* animation &#x3D; new 　　QPropertyAnimation(ui.label, &quot;geometry&quot;);
　　animation-&gt;setDuration(10000);
　　animation-&gt;setStartValue(QRect(0, 0, 200, 200));
　　animation-&gt;setEndValue(QRect(500, 500, 　　this-&gt;width(), this-&gt;height()));
　　animation-&gt;start();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码使按钮被按下后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">label</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>在10秒内移动到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>500</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(500,500)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span><br>
<strong>注意：在我测试的过程中，发现只有指针形式的调用才能实现次效果</strong><br>
　　也可以做到类似CSS中的@keyframe效果，例如：</p>
<pre class="line-numbers language-none"><code class="language-none">void QtWidgetsApplication1::on_btn_clicked()
&#123;
　　QPropertyAnimation* animation &#x3D; new QPropertyAnimation(ui.label, &quot;geometry&quot;);
　　animation-&gt;setDuration(10000);
　　animation-&gt;setKeyValueAt(0, QRect(0, 0, 500, 500));
　　animation-&gt;setKeyValueAt(0.5, QRect(250, 250, 500, 500));
　　animation-&gt;setKeyValueAt(1.0, QRect(0, 0, 500, 500));
　　animation-&gt;start();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而在自定义动画属性时，<strong>必须使用宏Q_PROPERTY设置访问与设置的函数</strong>，这样才能正确使用。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">class MyGraphicsRectItem : public QObject, public QGraphicsRectItem
&#123;
    Q_OBJECT
    Q_PROPERTY(QRectF geometry READ geometry WRITE setGeometry)
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="动画和图形视图框架">动画和图形视图框架</h2>
]]></content>
      <categories>
        <category>Qt具体使用</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt图形视图框架</title>
    <url>/2022/05/28/Qt%E4%BD%BF%E7%94%A8/2022-05-28-Qt%E5%9B%BE%E5%BD%A2%E8%A7%86%E5%9B%BE%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>为了应付大作业<s>更好的整活</s>，我需要学习以下Qt的图形视图框架。<br>
　　本文内容主要来自<a href="https://blog.csdn.net/qq_25800311/article/details/81002822">这里</a></p>
<h2 id="图形视图框架概述">图形视图框架概述</h2>
<p>如果要绘制成千上万的图形，并且对它们进行控制，比如拖动这些图形、检测它们的位置以及判断它们是否碰撞等，可以使用Qt提供的图形视图框架来进行设计。</p>
<p>图形视图框架提供了一个基于图形项的模型视图编程方法，主要由场景、视图和图形项三部分组成，这三部分分别由<strong>QGraphicsScene</strong>、<strong>QGraphicsView</strong>和<strong>QGraphicsItem</strong>这三个类来表示。多个视图可以查看一个场景，场景中包含各种各样几何形状的图形项。</p>
<p>图形视图框架可以管理数量庞大的自定义2D图形项，并且可以与它们进行交互。使用视图部件可以使这些图形项可视化，视图还支持缩放与旋转。框架中包含了一个事件传播架构，提供了和场景中的图形项进行精确的双精度交互的能力。图形视图框架使用一个<strong>BSP(Binary Space Partitioning)树</strong>来快速发现图形项。可通过<strong>Graphics View Framework</strong>关键字查看相关帮助。</p>
<h2 id="场景">场景</h2>
<p><strong>QGraphicsItem</strong>是场景中图形项的基类。典型的形状的标准图形项有矩形(<strong>QGraphicsRectItem</strong>)、椭圆(<strong>QGraphicsEllipseItem</strong>)和文本项(<strong>QGraphicsTextItem</strong>)等。但只有编写自定义的图形项才能发挥<strong>QGraphicsItem</strong>的强大功能。</p>
<p><strong>QGraphicsItem</strong>主要支持如下功能：</p>
<ul>
<li>
<p>鼠标按下、移动、释放、双击、悬停、滚轮和右键菜单事件</p>
</li>
<li>
<p>键盘输入焦点和键盘事件</p>
</li>
<li>
<p>拖放事件</p>
</li>
<li>
<p>碰撞检测</p>
</li>
</ul>
<p>除此之外，图形项还可以存储自定义的数据，可以使用<strong>setData</strong>()进行数据存储，然后使用<strong>data</strong>()获取其中的数据。</p>
<p>要实现自定义的图形项，那么首先要创建一个<strong>QGraphicsItem</strong>的子类，然后重新实现它的两个纯虚公共函数:<strong>boundingRect</strong>()和<strong>paint</strong>()，前者用来返回要绘制图形项的矩形区域，后者用来执行实际的绘图操作。其中<strong>boundingRect</strong>()函数将图形项的外部边界定义为一个矩形，所有的绘图操作都必须限制在图形项的边界矩形中。这个矩形对于剔除不可见图形项、确定绘制交叉项目时哪些区域需要重新构建、碰撞检测机制都很重要。一定要保证所有绘图都在<strong>boundingRect</strong>()的边界之中，特别是当<strong>QPainter</strong>使用了指定的QPen来渲染图形的边界轮廓时，绘制的图形的边界线的一般会在外面，一半会在里面（例如使用了宽度为两个单位的画笔，就必须在<strong>boundingRect</strong>()里绘制一个单位的边界线），这也是在<strong>boundingRect</strong>()中要包含半个画笔宽度的原因。<br>
　　纯虚函数实现示例：</p>
<pre class="line-numbers language-none"><code class="language-none">QRectF MyItem::boundingRect() const
&#123;
    qreal penWidth &#x3D; 1; &#x2F;&#x2F;画笔宽度
    return QRectF(0 - penWidth &#x2F; 2, 0 - penWidth &#x2F; 2,
                  20 + penWidth, 20 + penWidth);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">void MyItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *, QWidget *)
&#123;
    painter-&gt;setBrush(Qt::red);
    painter-&gt;drawRect(0, 0, 20, 20);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>##图形视图框架的坐标系统<br>
　　图形视图框架基于笛卡尔坐标系统。图形视图框架中有3个有效的坐标系统：<strong>图形项坐标</strong>、<strong>场景坐标</strong>和<strong>视图坐标</strong>。进行绘图时，场景坐标对应QPainter的逻辑坐标，视图坐标对应设备坐标。</p>
<h3 id="图形项坐标">图形项坐标</h3>
<p>图形项使用自己的本地坐标系统，<strong>坐标通常是以（0,0）为原点</strong>，而这也是所有变换的中心。当要创建一个自定义图形项时，只需要考虑图形项的坐标系统，而且一个图形项的边界矩形和图形形状都是在图形项坐标系统中的。</p>
<p>图形项的位置是指<strong>图形项的原点在其父图形项或者场景中的位置</strong>。可以使用<strong>setPos</strong>（）函数来指定图形项的位置，如果没有指定，默认出现在父图形项或者场景的原点处。</p>
<p>子图形项的位置和坐标是相对于父图形项的，虽然父图形项的坐标变换会隐含地变换子图形项，但<strong>子图形项的坐标不会受到父图形项的变换的影响</strong>。例如，在没有坐标变换时，子图形项就在父图形项的（10,0）点，那么子图形项中的（0,10）点就对应了父图形项的（10,10）点。现在即使父图形项进行了旋转或者缩放，子图形项的（0,10）点仍对应着父图形项的（10,10）点。但是相对于场景，子图形项就会跟随父图形项的变换，例如，父图形项放大为（2x，2x），那么子图形项在场景中的位置就会变成（20,0），它的（10,0）点就会对应着场景中的（40,0）点。</p>
<p>所有的图形项都会使用确定的顺序来进行绘制，这个顺序也决定了单击场景时哪个图形项会先获得鼠标输入。一个子图形项会堆叠在父图形项的上面，而兄弟图形项会以插入顺序进行堆叠。<strong>所有图形项都包含一个Z值来设置它们的层叠顺序</strong>，一个图形项的Z值默认为0，可以使用<strong>QGraphicsItem::setZValue</strong>()来改变一个图形项的Z值，从而使它堆叠到其兄弟图形项的上面（使用较大的Z值）或者下面（使用较小的Z值）。</p>
<h3 id="场景坐标">场景坐标</h3>
<p>场景坐标是所有图形项的基础坐标系统。场景坐标的原点在场景的中心，x和y坐标分别向右和向下增大。</p>
<h3 id="视图坐标">视图坐标</h3>
<p>视图坐标的每一个单位对应一个像素，原点（0,0）总在<strong>QGraphicsView</strong>视口的左上角，而右下角是（宽，高）。所有的鼠标事件和拖放事件最初都是使用视图坐标接收的。</p>
<h3 id="坐标映射">坐标映射</h3>
<p>不仅可以在视图、场景和图形项之间使用坐标映射，还可以在子图形项、父图形项或者图形项、图形项之间进行坐标映射。所有的映射函数都可以映射点、矩形、多边形和路径。例如要获取在视图中的一个椭圆形中包含的图形项，则可以先传递一个<strong>QPainterPath</strong>对象作为参数给<strong>mapToScene</strong>（）函数，然后传递映射后的路径给<strong>QGraphicsScene::items</strong>（）函数。</p>
<p>####图形视图框架的映射函数</p>
<table>
<thead>
<tr>
<th>映射函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>QGraphicsView::mapToScene( )</td>
<td>从视图坐标系统映射到场景坐标系统</td>
</tr>
<tr>
<td>QGraphicsView::mapFromScene( )</td>
<td>从场景坐标系统映射到视图坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapToScene( )</td>
<td>从图形项的坐标系统映射到场景的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapFromScene( )</td>
<td>从场景的坐标系统映射到图形项的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapToParent( )</td>
<td>从本图形项的坐标系统映射到其父图形项的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapFromParent( )</td>
<td>从父图形项的坐标系统映射到本图形项的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapToItem( )</td>
<td>从本图形项的坐标系统映射到另一个图形项的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapFromItem( )</td>
<td>从另一个图形项的坐标系统映射到本图形项的坐标系统</td>
</tr>
</tbody>
</table>
<h2 id="事件处理与传播">事件处理与传播</h2>
<p>图形视图框架中的事件都是<strong>先由视图进行接收，然后传递给场景，再由场景传递给相应的图形项</strong>。而对于键盘事件，它会传递给获得焦点的图形项，可以使用<strong>QGraphicsScene</strong>类的<strong>setFocusItem</strong>（）函数或者图形项自身调用<strong>setFocus</strong>（）函数来设置焦点图形项。默认的，如果场景没有获得焦点，那么所有的键盘事件都会被丢弃。场景中的图形项获得了焦点，场景也会自动获得焦点。</p>
<h2 id="示例">示例</h2>
<h3 id="myitem">MyItem</h3>
<ul>
<li>MyItem.h</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#pragma once

#include &lt;QGraphicsItem&gt;

class MyTime : public QGraphicsItem
&#123;

public:
	MyTime();
	~MyTime();
	QRectF boundingRect() const override;
	void paint(QPainter* painter,
		const QStyleOptionGraphicsItem* option,
		QWidget* widget) override;
	void setColor(const QColor&amp; color);

private:
	QColor brushColor;

protected:
	void KeyPressEvent(QKeyEvent* event);
	void mousePressEvent(QGraphicsSceneMouseEvent* event);
	void hoverEnterEvent(QGraphicsSceneHoverEvent* event);
	void contextMenuEvent(QGraphicsSceneContextMenuEvent* event);
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>MyItem.cpp</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;MyTime.h&quot;

#include &lt;QPainter&gt;
#include &lt;QCursor&gt;
#include &lt;QKeyEvent&gt;
#include &lt;QGraphicsSceneHoverEvent&gt;
#include &lt;QGraphicsSceneContextMenuEvent&gt;
#include &lt;QMenu&gt;

MyTime::MyTime()
&#123;
	brushColor &#x3D; Qt::red;

	setFlag(QGraphicsItem::ItemIsFocusable);
	setFlag(QGraphicsItem::ItemIsMovable);

	setAcceptHoverEvents(true);
&#125;

MyTime::~MyTime()
&#123;
&#125;

QRectF MyTime::boundingRect() const
&#123;
	qreal adjust &#x3D; 0.5;
	return QRectF(
		-10 - adjust,
		-10 - adjust,
		20 + adjust,
		20 + adjust
	);
&#125;

void MyTime::paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget)
&#123;
	if (hasFocus())
	&#123;
		painter-&gt;setPen(QPen(QColor(255, 255, 255, 200)));
	&#125;
	else
	&#123;
		painter-&gt;setPen(QPen(QColor(100, 100, 100, 100)));
	&#125;
	painter-&gt;setBrush(brushColor);
	painter-&gt;drawRect(-10, -10, 20, 20);
&#125;

void MyTime::setColor(const QColor&amp; color)
&#123;
	brushColor &#x3D; color;
&#125;

void MyTime::KeyPressEvent(QKeyEvent* event)
&#123;
	if (event-&gt;key() &#x3D;&#x3D; Qt::Key_Down)
	&#123;
		moveBy(0, 10);
	&#125;
&#125;

void MyTime::mousePressEvent(QGraphicsSceneMouseEvent* event)
&#123;
	setFocus();
	setCursor(Qt::ClosedHandCursor);
&#125;

void MyTime::hoverEnterEvent(QGraphicsSceneHoverEvent* event)
&#123;
	setCursor(Qt::OpenHandCursor);
	setToolTip(&quot;I am a item&quot;);
&#125;

void MyTime::contextMenuEvent(QGraphicsSceneContextMenuEvent* event)
&#123;
	QMenu menu;
	QAction* moveAction &#x3D; menu.addAction(&quot;move back&quot;);
	QAction* selectedAction &#x3D; menu.exec(event-&gt;screenPos());
	if (selectedAction &#x3D;&#x3D; moveAction)
	&#123;
		setPos(0, 0);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="myview">MyView</h3>
<ul>
<li>MyView.h</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#pragma once

#include &lt;QGraphicsView&gt;

class MyView : public QGraphicsView
&#123;

public:
	MyView();
	~MyView();
protected:
	void keyPressEvent(QKeyEvent* event);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>MyView.cpp</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;MyView.h&quot;
#include &lt;QKeyEvent&gt;

MyView::MyView()
	
&#123;
&#125;

MyView::~MyView()
&#123;
&#125;

void MyView::keyPressEvent(QKeyEvent* event)
&#123;
	switch (event-&gt;key())
	&#123;
	case Qt::Key_Plus:
		scale(1.2, 1.2);
		break;
	case Qt::Key_Minus:
		scale(1 &#x2F; 1.2, 1 &#x2F; 1.2);
		break;
	case Qt::Key_Right:
		rotate(30);
	default:
		break;
	&#125;
	QGraphicsView::keyPressEvent(event);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="main">main</h3>
<ul>
<li>main.cpp</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;QtWidgets&#x2F;QApplication&gt;
#include &lt;QTime&gt;
#include &quot;MyTime.h&quot;
#include &quot;MyView.h&quot;

int main(int argc, char *argv[])
&#123;
    QApplication app(argc, argv);
    qsrand(QTime(0, 0, 0).secsTo(QTime::currentTime()));
    QGraphicsScene scene;
    scene.setSceneRect(-200, -150, 400, 300);

    for (int i &#x3D; 0; i &lt; 5; i++)
    &#123;
        MyTime* item &#x3D; new MyTime();
        item-&gt;setColor(QColor(qrand() % 256, qrand() % 256, qrand() % 256));
        item-&gt;setPos(i * 50 - 90, -50);
        scene.addItem(item);
    &#125;

    MyView view;
    view.setScene(&amp;scene);
    view.setBackgroundBrush(QBrush(Qt::red));
    view.show();
    return app.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Qt具体使用</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt使用</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链表</title>
    <url>/2022/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-02-11-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>虽然我不知道静态链表什么时候用，但学了总有好处</p>
<h3 id="前言：">前言：</h3>
<p>1.老师仅仅布置了静态链表的初始化、插入和删除操作，因此我只做这几个。</p>
<p>2.本文使用cpp完成。</p>
<h3 id="思路：">思路：</h3>
<p>Component中有两个元素，一个是DataType,这里我使用了string,用来表示存储的元素，另一个是cursor，它的作用与链表节点中的指针一样，用来指出下一个元素的位置</p>
<p>不同的是，cursor指出的不再是地址，而是下一个元素在数组中的下标。</p>
<p>由此可以看出，<strong>静态链表本质还是链表，我们仍需用出来链表的方式处理静态链表，不能被数组所迷惑。</strong></p>
<p>下面开始实现。</p>
<h3 id="实现：">实现：</h3>
<p>静态链表，归根结底还是链表，因此首先我们要定义节点。</p>
<pre class="line-numbers language-none"><code class="language-none">#define MAXSIZE 1000     &#x2F;&#x2F;数组最大长度

struct Component
&#123;
    string data &#x3D;  &quot;&quot; ;         &#x2F;&#x2F;数据
    int cursor &#x3D; 0;            &#x2F;&#x2F;游标
&#125;;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在main函数中，我们定义静态链表</p>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    Component StaticLinkedList[MAXSIZE];      &#x2F;&#x2F;静态链表
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们需要进行初始化</p>
<pre class="line-numbers language-none"><code class="language-none">void initLinkedList(Component* list)
&#123;
    int cnt &#x3D; 1;
    for ( int i &#x3D; 0; i &lt; MAXSIZE - 1; i++)
    &#123;
        list[i].cursor &#x3D; i++;                  &#x2F;&#x2F;初始化时每个节点的cursor指出
    &#125;                                                     &#x2F;&#x2F;下一个节点的位置，而最后一个
    list[MAXSIZE - 1].cursor &#x3D; 0;            &#x2F;&#x2F;节点的cursor为0，指向头节点
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论插入还是删除，我们都需要找到元素。</p>
<pre class="line-numbers language-none"><code class="language-none">Component&amp; find(string input, Component* list)
&#123; &#x2F;&#x2F;返回component的引用，这样可以修改数组中的元素，而无需使用指针
    int curEle &#x3D; list[0].cursor;
    while (list[curEle].cursor !&#x3D; 0 &amp;&amp; list[curEle].data !&#x3D;  &quot;&quot; )　　　　 &#x2F;&#x2F;初始化时每个元素都为空，因此以此为条件
    &#123;
        if (list[curEle].data &#x3D;&#x3D; input)
        &#123;
            return list[curEle];
        &#125;
        else
        &#123;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
    return list[curEle];　　 &#x2F;&#x2F;当找不到时返回的元素
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
<p>当我们插入元素时，我们需要将最后一个非空元素后面的那一个元素使用，将数据保存在那个元素里。</p>
<p><img src="https://s2.loli.net/2022/05/25/DzMxsWebVGNQjS2.png" alt="当前长度" title="当前长度"></p>
<p>这里是将元素出入指定元素之后</p>
<pre class="line-numbers language-none"><code class="language-none">void insertAfter(string input, string query, Component* list)
&#123; &#x2F;&#x2F;与链表插入几乎一样的手法，无需多言
    currenLength++;
    Component&amp; target &#x3D; find(query, list);
    list[currenLength].data &#x3D; input;
    list[currenLength].cursor &#x3D; target.cursor;
    target.cursor &#x3D; currenLength;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>删除元素</p>
<pre class="line-numbers language-none"><code class="language-none">void deleteElement(string query, Component* list)
&#123;
    if (query &#x3D;&#x3D;  &quot;&quot; )
    &#123;
        cout &lt;&lt;  &quot;you didn&#39;t input anything.&quot; ;
        return ;
    &#125;
    Component&amp; target &#x3D; find(query, list);
    if (target.data !&#x3D; query)
    &#123;
        cout &lt;&lt;  &quot;the element you input does not exist in the list.&quot; ;
        return ;
    &#125;
    int curEle &#x3D; 0;
    int pre;
    while (1)　　 &#x2F;&#x2F;需要寻找指定元素之前的元素
    &#123;
        if (list[curEle].data &#x3D;&#x3D; query)
        &#123;
            list[pre].cursor &#x3D; list[curEle].cursor;
            list[curEle].cursor &#x3D; -1;
            list[curEle].data &#x3D;  &quot;&quot; ;
            break ;
        &#125;
        else
        &#123;
            pre &#x3D; curEle;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>完整代码：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include 
#include 
using namespace std;
#define MAXSIZE 1000
struct Component
&#123;
    string data &#x3D;  &quot;&quot; ;
    int cursor &#x3D; 0;
&#125;;

static int currenLength &#x3D; 0;

Component&amp; find(string input, Component* list)
&#123;
    int curEle &#x3D; list[0].cursor;
    while (list[curEle].cursor !&#x3D; 0 &amp;&amp; list[curEle].data !&#x3D;  &quot;&quot; )
    &#123;
        if (list[curEle].data &#x3D;&#x3D; input)
        &#123;
            return list[curEle];
        &#125;
        else
        &#123;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
    return list[curEle];
&#125;

void insertAfter(string input, string query, Component* list)
&#123;
    currenLength++;
    Component&amp; target &#x3D; find(query, list);
    list[currenLength].data &#x3D; input;
    list[currenLength].cursor &#x3D; target.cursor;
    target.cursor &#x3D; currenLength;
&#125;

void deleteElement(string query, Component* list)
&#123;
    if (query &#x3D;&#x3D;  &quot;&quot; )
    &#123;
        cout &lt;&lt;  &quot;you didn&#39;t input anything.&quot; ;
        return ;
    &#125;
    Component&amp; target &#x3D; find(query, list);
    if (target.data !&#x3D; query)
    &#123;
        cout &lt;&lt;  &quot;the element you input does not exist in the list.&quot; ;
        return ;
    &#125;
    int curEle &#x3D; 0;
    int pre;
    while (1)
    &#123;
        if (list[curEle].data &#x3D;&#x3D; query)
        &#123;
            list[pre].cursor &#x3D; list[curEle].cursor;
            list[curEle].cursor &#x3D; -1;
            list[curEle].data &#x3D;  &quot;&quot; ;
            break ;
        &#125;
        else
        &#123;
            pre &#x3D; curEle;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
&#125;

void initLinkedList(Component* list)
&#123;
    int cnt &#x3D; 1;
    for ( int i &#x3D; 0; i &lt; MAXSIZE - 1; i++)
    &#123;
        list[i].cursor &#x3D; i++;
    &#125;
    list[MAXSIZE - 1].cursor &#x3D; 0;
&#125;
int main()
&#123;
   
    Component StaticLinkedList[MAXSIZE];
    initLinkedList(StaticLinkedList);
    string input, query, deleteMent;
    while (1) &#123;
        cin &gt;&gt; input &gt;&gt; query &gt;&gt; deleteMent;
        insertAfter(input, query, StaticLinkedList);
        deleteElement(deleteMent, StaticLinkedList);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
<h3 id="结语：">结语：</h3>
<p>这就是静态链表这几个操作了，我经过VS调试后并未出现异常</p>
<p>如有看不懂，或错误的地方，欢迎讨论。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>双链表</title>
    <url>/2022/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-02-14-%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>相比单链表，双链表提供了prev指针，使得其在处理一些操作时更为简单。</p>
<h2 id="前言：">前言：</h2>
<p>1.这里的双链表使用C++实现</p>
<p>2.只完成了插入删除操作</p>
<h2 id="思路：">思路：</h2>
<p><img src="https://s2.loli.net/2022/05/25/3LFDGZJONKn98y4.png" alt=""></p>
<p>如上图所示，next指向下一个，而prev指向前一个，只要适当调整指针指向，即可完成双链表</p>
<h2 id="实现：">实现：</h2>
<p>首先，需要定义表示节点的结构体:</p>
<pre class="line-numbers language-none"><code class="language-none">struct node
&#123;
	string data;
	node* next;		&#x2F;&#x2F;指向下一个元素
	node* prev;		&#x2F;&#x2F;指向前一个元素
	node()                　&#x2F;&#x2F;构造函数，用于在创建新节点时自动初始化    
	&#123;
		data &#x3D; &quot;&quot;;
		prev &#x3D; NULL;
		next &#x3D; NULL;
	&#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我为了在字面上区分节点和链表的区别，使用了</p>
<p><img src="https://s2.loli.net/2022/05/25/5OE78YwUT1kyhrp.png" alt=""></p>
<p>接下来创建链表，实际上是创造了一个节点，将其作为头结点。</p>
<pre class="line-numbers language-none"><code class="language-none">doubleLinkedList* createList()
&#123;
	node* list &#x3D; new node();　　&#x2F;&#x2F;这种方式返回不会存在局部变量内存销毁的问题，因为它是new出来的
	return list;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>插入操作</p>
<pre class="line-numbers language-none"><code class="language-none">void insert(node* position, string input)
&#123;&#x2F;&#x2F;position是插入的位置，input是插入数据的data
	node* newNode &#x3D; new node();
	&lt;strong&gt;newNode-&gt;data &#x3D; input;				&#x2F;&#x2F;先处理新创造的节点
	newNode-&gt;next &#x3D; position-&gt;next;		　　　　 &#x2F;&#x2F;如果不对新节点优先处理，会造成找不到节点的清空，造成野指针
	newNode-&gt;prev &#x3D; position;
	if (position-&gt;next !&#x3D; NULL) &#123;　　　　　　　　　　　　&#x2F;&#x2F;如果不进行判断，可能会对NULL操作而错误
		position-&gt;next-&gt;prev &#x3D; newNode;
		position-&gt;next &#x3D; newNode;
	&#125;
	else &#123;
		position-&gt;next &#x3D; newNode;
	&#125;&lt;&#x2F;strong&gt;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
<pre class="line-numbers language-none"><code class="language-none">void deleteElement(node* ele)
&#123;
	ele-&gt;prev-&gt;next &#x3D; ele-&gt;next;
	if (ele-&gt;next !&#x3D; NULL)
	&#123;
		ele-&gt;next-&gt;prev &#x3D; ele-&gt;prev;
	&#125;
	else
	&#123;&#x2F;&#x2F;ele-&gt;next为空时不需要做什么了
	&#125;
	delete ele;　　　　&#x2F;&#x2F;必须删除，否则长时间可能造成内存泄漏
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
<p>查找操作</p>
<pre class="line-numbers language-none"><code class="language-none">node* find(string input, doubleLinkedList* list)
&#123;&#x2F;&#x2F;与单链表差不多
	doubleLinkedList* L &#x3D; list;
	while (L !&#x3D; NULL)
	&#123;
		if (L-&gt;data &#x3D;&#x3D; input)
		&#123;
			return L;
		&#125;
		else
		&#123;
			L &#x3D; L-&gt;next;
		&#125;
	&#125;
	return NULL;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>完整代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
struct node
&#123;
	string data;
	node* next;		&#x2F;&#x2F;指向下一个元素
	node* prev;		&#x2F;&#x2F;指向前一个元素
	node()
	&#123;
		data &#x3D; &quot;&quot;;
		prev &#x3D; NULL;
		next &#x3D; NULL;
	&#125;
&#125;;

using doubleLinkedList &#x3D; node;

void insert(node* position, string input)
&#123;&#x2F;&#x2F;position是插入的位置，input是插入数据的data
	node* newNode &#x3D; new node();
	newNode-&gt;data &#x3D; input;				&#x2F;&#x2F;先处理新创造的节点
	newNode-&gt;next &#x3D; position-&gt;next;		
	newNode-&gt;prev &#x3D; position;
	if (position-&gt;next !&#x3D; NULL) &#123;
		position-&gt;next-&gt;prev &#x3D; newNode;
		position-&gt;next &#x3D; newNode;
	&#125;
	else &#123;
		position-&gt;next &#x3D; newNode;
	&#125;
&#125;

void deleteElement(node* ele)
&#123;
	ele-&gt;prev-&gt;next &#x3D; ele-&gt;next;
	if (ele-&gt;next !&#x3D; NULL)
	&#123;
		ele-&gt;next-&gt;prev &#x3D; ele-&gt;prev;
	&#125;
	else
	&#123;
	&#125;
	delete ele;
&#125;

node* find(string input, doubleLinkedList* list)
&#123;
	doubleLinkedList* L &#x3D; list;
	while (L !&#x3D; NULL)
	&#123;
		if (L-&gt;data &#x3D;&#x3D; input)
		&#123;
			return L;
		&#125;
		else
		&#123;
			L &#x3D; L-&gt;next;
		&#125;
	&#125;
	return NULL;
&#125;

doubleLinkedList* createList()
&#123;
	node* list &#x3D; new node();
	return list;
&#125;

int main()
&#123;
	doubleLinkedList* list &#x3D; createList();
	while (true)
	&#123;
		int j;
		cin &gt;&gt; j;
		if (j &#x3D;&#x3D; 1)
		&#123;
			string query, input;
			cin &gt;&gt; input;
			insert(list, input);
		&#125;
		else
		&#123;
			string query;
			cin &gt;&gt; query;
			deleteElement(find(query, list));
		&#125;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此代码已经本人VS调试测试，暂时没有发现什么问题</p>
<p>如果由不懂的或错误的，欢迎评论或加QQ私聊！</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于函数体内指针指向问题</title>
    <url>/2022/02/16/%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/2022-02-16-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在做一道题的时候，发现了一个问题，那就是函数的执行会不会改变指针指向的问题。</p>
<p>下面来诠释此问题。</p>
<p></p>
<p>首先，我们用一段代码创建了一个具有10个节点的链表（不算头结点）：</p>
<pre class="line-numbers language-none"><code class="language-none">struct test &#123;
	int data;
	test* next &#x3D; NULL;
&#125;;

test* createList()
&#123;
	test* list &#x3D; new test;
	test* ret &#x3D; list;
	for (int i &#x3D; 0; i &lt; 10; i++)
	&#123;
		test* newNode &#x3D; new test;
		newNode-&gt;data &#x3D; i;
		list-&gt;next &#x3D; newNode;
		list &#x3D; list-&gt;next;
	&#125;
	return ret;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们有一个测试函数来改变指针：</p>
<pre class="line-numbers language-none"><code class="language-none">void changePoint(test* list)
&#123;
	list &#x3D; list-&gt;next;
&#125;

int main()
&#123;
	test* testlist &#x3D; createList();
	changePoint(testlist);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面开始调试，将断点设置在函数changePoint中，得到如下结果：</p>
<p><img src="https://s2.loli.net/2022/05/26/YQ4jAtaXq9swDVN.png" alt="1.png"></p>
<p><img src="https://s2.loli.net/2022/05/26/xCjGmJqbHD4QSVA.png" alt="2.png"></p>
<p>可见在函数体内部，指针是被改变了的。</p>
<p>但在函数执行完毕后，指针又变成了原来未被改变的：</p>
<p><img src="https://s2.loli.net/2022/05/26/PvFCebwK7R2ziWI.png" alt="3.png"></p>
<p>如果想要同时更改函数体内和函数体外的指针的值，可以使用<strong>指针的引用.</strong></p>
<pre class="line-numbers language-none"><code class="language-none">void changePoint(test* &amp;list)
&#123;
	list &#x3D; list-&gt;next;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现，指针被顺利改写。</p>
<p><strong><img src="https://s2.loli.net/2022/05/26/YsUfb5eViRh8P3u.png" alt="4.png"></strong></p>
<p><img src="https://s2.loli.net/2022/05/26/irTmSIPNge8VUM6.png" alt="5.png"></p>
<p></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>细节问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】Prim算法</title>
    <url>/2022/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-05-29-Prim%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>最近数据结构已经结课了，但是我差的太多啦！！！这篇文章就来补最小生成树的Prim算法。</p>
<h2 id="简介">简介</h2>
<p>Prim是一种生成最小生成树的算法。<s>雀氏简啊</s></p>
<h2 id="算法步骤描述">算法步骤描述</h2>
<p>假设$$ N=(V, {E}) $$ 是一连通图, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">TE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>为最小生成树种边的集合。</p>
<ol>
<li>初始时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><msub><mi>u</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>u</mi><mn>0</mn></msub><mo>∈</mo><mi>V</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>T</mi><mi>E</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">U={u_0}(u_0\in V), TE=\empty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span> 。</li>
<li>在所有的$u\in U,v\in V-U <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>的边中，选一条代价最小的边</mtext></mrow><annotation encoding="application/x-tex">的边中，选一条代价最小的边</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">选</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">价</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">边</span></span></span></span>(u,v)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>并入集合</mtext></mrow><annotation encoding="application/x-tex">并入集合</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span></span></span></span>TE<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo separator="true">,</mo><mtext>同时</mtext></mrow><annotation encoding="application/x-tex">,同时</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">时</span></span></span></span>v<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>并入</mtext></mrow><annotation encoding="application/x-tex">并入</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">入</span></span></span></span>U$.</li>
<li>重复第二个步骤，直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U=V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>为止。</li>
</ol>
<p>此时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">TE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>种必含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>条边，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mrow><mi>T</mi><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=(V,{TE})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span><span class="mclose">)</span></span></span></span>为N的最小生成树。</p>
<h2 id="算法图解">算法图解</h2>
<p><img src="https://s2.loli.net/2022/05/30/KTOcxhZpN2qWdgj.jpg" alt="1.jpg"></p>
<center>此图来源于课本</center>
<h2 id="算法实现">算法实现</h2>
<p>为了记录已在生成树的顶点集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>，我们使用一个结构来记录，如下</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct Assist
&#123;
    int tail;			&#x2F;&#x2F; 表示从结点tail引出
    int lowcost;		&#x2F;&#x2F; 表示到当前结点的最短距离
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在进行操作时，我们(closedge为Assist数组)</p>
<ol>
<li>将初始顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>加入到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>中，对其余每一顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">closedge[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>均初始化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>的边信息。</li>
<li>循环<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次，进行如下操作：
<ul>
<li>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">closedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span></span></span></span>中选出最小边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext>这里</mtext><mi>v</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">closedge[v],这里v \in V-U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>。</li>
<li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>加入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span></li>
<li>更新剩余每组的最小边信息<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>i</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">closedge[i](i \in V-U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> 。</li>
</ul>
</li>
</ol>
<p>关键部分如下:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * @description: Prim算法
 * @param begin 最小生成树的开始结点
 * @return void
 *&#x2F;
void Graph::prim(int begin)
&#123;
    &#x2F;*用于求最小生成树的辅助结构*&#x2F;
    Assist closedge[20];
    auto start &#x3D; begin - 1;
    closedge[start].lowcost &#x3D; 0; &#x2F;&#x2F; 初始化, U &#x3D; &#123;u&#125;
    for (int i &#x3D; 0; i &lt; vexnum; i++)
    &#123;
        if (i !&#x3D; start)			&#x2F;&#x2F; 初始化closedge[i]
        &#123;
            closedge[i].tail &#x3D; start;
            auto weig &#x3D; findArc(start, i + 1);
            if (!weig)
            &#123;
                closedge[i].lowcost &#x3D; 10000;
            &#125;
            else
            &#123;
                closedge[i].lowcost &#x3D; weig-&gt;weight;
            &#125;
        &#125;
    &#125;
    for (int i &#x3D; 0; i &lt; vexnum - 1; i++)		&#x2F;&#x2F; 循环n-1次
    &#123;
        auto minNode &#x3D; minimum(closedge);		&#x2F;&#x2F; 找出最小边
        start &#x3D; closedge[minNode].tail;
        &#x2F;*输出最小生成树信息*&#x2F;
        std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; start + 1 &lt;&lt; &quot;,&quot; &lt;&lt; minNode + 1 &lt;&lt; &quot;&gt;&quot; &lt;&lt; std::endl;
        closedge[minNode].lowcost &#x3D; 0;			&#x2F;&#x2F; 将minNode并入U中
        &#x2F;*更新closedge信息*&#x2F;
        for (int j &#x3D; 0; j &lt; vexnum; j++)
        &#123;
            auto now &#x3D; findArc(minNode, j + 1);
            if (!now)
            &#123;
                continue;
            &#125;
            if (now-&gt;weight &lt; closedge[j].lowcost)
            &#123;
                closedge[j].lowcost &#x3D; now-&gt;weight;
                closedge[j].tail &#x3D; minNode;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="完整代码实现">完整代码实现</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
 * @Author: zh(RickSchanze)(帝皇の惊)
 * @Description: 最小生成树的Prim算法
 * @Date: 2022-05-29 22:48:52
 * @LastEditTime: 2022-05-31 21:34:56
 *&#x2F;
#include &lt;iostream&gt;

struct ArcNode
&#123;
    int arc;
    int weight;
    ArcNode *next;

    ArcNode(int arc, int weight) : arc(arc), weight(weight), next(nullptr) &#123;&#125;
&#125;;

struct VexNode
&#123;
    int vex;
    ArcNode *first;

    VexNode(int vex) : vex(vex), first(nullptr) &#123;&#125;
    VexNode() : vex(-1), first(nullptr) &#123;&#125;
&#125;;

struct Assist
&#123;
    int tail;
    int lowcost;
&#125;;

struct Graph
&#123;
    VexNode vexMat[20];
    int arcnum;
    int vexnum;

    &#x2F;&#x2F; void createDirectedGraph();  有向图暂时先不写了
    void createGraph();
    void prim(int begin);
    ArcNode *findArc(int begin, int end) const;
    int minimum(Assist *) const;
&#125;;

int Graph::minimum(Assist dist[]) const
&#123;
    int min &#x3D; 10000, rtn &#x3D; 10000;
    for (int i &#x3D; 0; i &lt; vexnum; i++)
    &#123;
        if (dist[i].lowcost &#x3D;&#x3D; 0)
        &#123;
            continue;
        &#125;
        if (dist[i].lowcost &lt; min)
        &#123;
            min &#x3D; dist[i].lowcost;
            rtn &#x3D; i;
        &#125;
    &#125;
    return rtn;
&#125;

ArcNode *Graph::findArc(int begin, int end) const
&#123;
    auto beginPtr &#x3D; vexMat[begin].first;
    if (beginPtr)
    &#123;
        while (beginPtr !&#x3D; nullptr)
        &#123;
            if (beginPtr-&gt;arc &#x3D;&#x3D; end)
            &#123;
                return beginPtr;
            &#125;
            beginPtr &#x3D; beginPtr-&gt;next;
        &#125;
    &#125;
    return beginPtr;
&#125;

void Graph::createGraph()
&#123;
    std::cout &lt;&lt; &quot;请输入顶点个数:&quot;;
    std::cin &gt;&gt; vexnum;
    &#x2F;&#x2F; vexMat &#x3D; new VexNode[vexnum];
    for (size_t i &#x3D; 0; i &lt; vexnum; i++)
    &#123;
        std::cin &gt;&gt; vexMat[i].vex;
    &#125;
    std::cout &lt;&lt; &quot;请输入边个数:&quot;;
    std::cin &gt;&gt; arcnum;
    for (size_t i &#x3D; 0; i &lt; arcnum; i++)
    &#123;
        int begin, end, weight;
        std::cout &lt;&lt; &quot;输入弧尾弧头权重:&quot;;
        std::cin &gt;&gt; begin &gt;&gt; end &gt;&gt; weight;
        auto first &#x3D; vexMat[begin - 1].first;
        for (; first !&#x3D; nullptr &amp;&amp; first-&gt;next !&#x3D; nullptr; first &#x3D; first-&gt;next)
            ;
        if (first &#x3D;&#x3D; nullptr)
        &#123;
            vexMat[begin - 1].first &#x3D; new ArcNode(end, weight);
        &#125;
        else
        &#123;
            first-&gt;next &#x3D; new ArcNode(end, weight);
        &#125;
    &#125;
&#125;

&#x2F;**
 * @description: Prim算法
 * @param begin 最小生成树的开始结点
 * @return void
 *&#x2F;
void Graph::prim(int begin)
&#123;
    &#x2F;*用于求最小生成树的辅助结构*&#x2F;
    Assist closedge[20];
    auto start &#x3D; begin - 1;
    closedge[start].lowcost &#x3D; 0; &#x2F;&#x2F; 初始化, U &#x3D; &#123;u&#125;
    for (int i &#x3D; 0; i &lt; vexnum; i++)
    &#123;
        if (i !&#x3D; start)
        &#123;
            closedge[i].tail &#x3D; start;
            auto weig &#x3D; findArc(start, i + 1);
            if (!weig)
            &#123;
                closedge[i].lowcost &#x3D; 10000;
            &#125;
            else
            &#123;
                closedge[i].lowcost &#x3D; weig-&gt;weight;
            &#125;
        &#125;
    &#125;
    for (int i &#x3D; 0; i &lt; vexnum - 1; i++)
    &#123;
        auto minNode &#x3D; minimum(closedge);
        start &#x3D; closedge[minNode].tail;
        std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; start + 1 &lt;&lt; &quot;,&quot; &lt;&lt; minNode + 1 &lt;&lt; &quot;&gt;&quot; &lt;&lt; std::endl;
        closedge[minNode].lowcost &#x3D; 0;
        for (int j &#x3D; 0; j &lt; vexnum; j++)
        &#123;
            auto now &#x3D; findArc(minNode, j + 1);
            if (!now)
            &#123;
                continue;
            &#125;
            if (now-&gt;weight &lt; closedge[j].lowcost)
            &#123;
                closedge[j].lowcost &#x3D; now-&gt;weight;
                closedge[j].tail &#x3D; minNode;
            &#125;
        &#125;
    &#125;
&#125;

int main()
&#123;
    Graph *graph &#x3D; new Graph();
    graph-&gt;createGraph();
    graph-&gt;prim(2);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注：这里的图用邻接表存储</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类里静态成员链接错误</title>
    <url>/2022/03/03/%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/2022-03-03-C++%E7%B1%BB%E9%87%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>我现声明一个类内静态变量:</p>
<pre class="line-numbers language-none"><code class="language-none">class test&#123;
public:
    static int a;
    int get();
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在test.cpp中对a进行使用</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;test.h&gt;
int test::get()
&#123;
    return a;                    
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>会产生链接错误</p>
<p><img src="https://s2.loli.net/2022/05/29/MPGYQKLqogBn7uE.png" alt="1.png"><br>
　　解决方案：</p>
<p><strong>①在头文件中定义函数</strong></p>
<p>**　　　　**</p>
<pre class="line-numbers language-none"><code class="language-none">#pragma once
class test
&#123;
public:
	static int a;
	int get()
	&#123;
		return a;
	&#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>②在源文件加上静态变量的声明</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;test.h&quot;

int test::a;

int test::get()
&#123;
	return a;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
]]></content>
      <categories>
        <category>细节问题</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>细节问题</tag>
      </tags>
  </entry>
</search>
