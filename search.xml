<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EffectiveC++(1)(1~4)</title>
    <url>/2022/03/04/Effective%20C++/2022-03-04-EffectiveC++(1)(1~4)/</url>
    <content><![CDATA[<h2 id="01-视c-为一个语言联邦"><strong>01:视C++为一个语言联邦</strong></h2>
<p><strong>四个次语言:</strong></p>
<ul>
<li>C</li>
<li>Object-Oriented C++（面向对象C++）</li>
<li>Template C++</li>
<li>STL</li>
</ul>
<h2 id="02-尽量以-const-enum-inline代替-define">02:尽量以 const, enum, inline代替 #define</h2>
<p>使用#define时，编译器看不到你所define的变量，那么当报错时，为了查找理解你所定义的，就需要耗费大量时间</p>
<pre class="line-numbers language-none"><code class="language-none">#define ASPECT_RATIO 1.653　　　　&#x2F;&#x2F;aspect_ratio并未进入符号表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当以常量代替#define时，有两种特殊情况</p>
<ul>
<li><strong>定义常量指针</strong></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">const char* const authoerNameo &#x3D; &quot;ScottMeyers&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><strong><strong>定义class专有常量</strong></strong></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;为了将常量作用域限制于class内，需要static
class GamePlayer&#123;
    static const int NumTurns &#x3D; 5;&#x2F;&#x2F;常量声明式
    int scores[NumTurns];&#x2F;&#x2F;使用常量    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于形似函数的宏(如#definr Test(a,b) f((a)&gt;(b)?(a):(b)))，可以用inline代替</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;
inline void callWithMax(const T&amp; a, const T&amp; b)
&#123;
    f(a &gt; b ? a: b);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="03-尽可能使用const">03:尽可能使用const</h2>
<p>const的几种不同用法</p>
<pre class="line-numbers language-none"><code class="language-none">char greeting[] &#x3D; &quot;hewwl&quot;;
char* p &#x3D; greeting;
const char* p &#x3D;greeting;    &#x2F;&#x2F;non-const pointer, const data
char* const p &#x3D; greeting;   &#x2F;&#x2F;const pointer, non-const data
const char* const p &#x3D; greeting; &#x2F;&#x2F;const pointer, const data
&#x2F;&#x2F;注: const Widget* pw与Widget const* pw等价<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>令函数返回一个常量值，可以降低因错误而造成的意外，如：</p>
<pre class="line-numbers language-none"><code class="language-none">class Rational&#123;&#125;;
const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);
&#x2F;&#x2F;如果没有const可能会造成
Rational a,b,c;
if (a*b &#x3D; c)
&#123;
    &#x2F;* code *&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>另：双目运算符operator*想拥有两个参数，必须在类外定义，因为类内有隐式this指针</strong></p>
<p><strong>当const 和 non-const成员函数有着实质等价的实现时，令non-const版本调用const版本来避免代码重复</strong></p>
<pre class="line-numbers language-none"><code class="language-none">class TextBlock &#123; public: const char&amp; operator[](std::size_t position) const&#123; &#x2F;&#x2F;过程1 &#x2F;&#x2F;过程2 &#x2F;&#x2F;过程3 return text[position]; &#125; char&amp; operator[](std::size_t position)&#123; return const_cast&lt;char&amp;&gt; (static_cast&lt;const TextBlock&amp;&gt; (*this)[position]); &#125; &#125;; &#x2F;&#x2F;注:不能用const调用non-const,因为non-const可能改变对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="04-确定对象使用前已被初始化">04:确定对象使用前已被初始化</h2>
<li>
<p><strong>为内置对象进行手工初始化</strong></p>
</li>
<p>内置对象不进行手工初始化的话很可能得到随机值，而浪费性能</p>
<li>
<p><strong>构造函数使用成员初始化列表，而不是赋值</strong></p>
</li>
<pre class="line-numbers language-none"><code class="language-none">class A
&#123;
private:
    int member1;
    double member2;
    std::string member3;

public:
    &#x2F;&#x2F;使用初始值列表
    A() : member1(0), member2(0), member3(std::string())&#123;&#125;
    &#x2F;&#x2F;赋值初始化
    A()&#123;
        member1 &#x3D; 0;
        member2 &#x3D; 0;
        member3 &#x3D; &quot;&quot;;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用赋值初始化的构造函数在赋值前还会调用default的构造函数，因此会造成性能流失</p>
<li>
<p><strong>以本地静态对象代替非本地静态对象</strong></p>
</li>
<p>这是为避免跨编译单元初始化次序问题而提出的解决方案，简单来说就是：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;a.cpp
class hen&#123;
    public:
    std::size_t makeEggs();
&#125;;
hen ji;&#x2F;&#x2F;non-local static

&#x2F;&#x2F;b.cpp
extern hen ji;
class eggs&#123;
    public:
    void eggs()
    &#123;
        ji.makeEggs();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时若调用eggs构造函数，而ji未初始化，则会造成严重问题（多编译文件初始化次序不确定）</p>
<p>而</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;a.cpp
class hen&#123;
    public:
    std::size_t makeEggs();
&#125;;
hen&amp; chicken()
&#123;
    static hen ji
    return ji;
&#125;;

&#x2F;&#x2F;b.cpp
extern hen ji;
class eggs&#123;
    public:
    eggs()
    &#123;
        chicken().makeEggs();
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不存在问题，原因简单分析:</p>
<p>local static 的做法 &gt; 调用 eggs() &gt; 调用 egg 构造函数 &gt; 调用 ji() &gt; 调用 ji 的构造函数 &gt; 成功</p>
<p><a href="https://blog.csdn.net/pursue_my_life/article/details/80950580">参考链接</a></p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveC++(2)(5~12)</title>
    <url>/2022/03/05/Effective%20C++/2022-03-05-EffectiveC++(2)(5~12)/</url>
    <content><![CDATA[<h2 id="05-了解c-默默编写并调用了哪些函数">05:了解C++默默编写并调用了哪些函数</h2>
<p>如果定义一个类</p>
<pre class="line-numbers language-none"><code class="language-none">class Empty&#123;&#125;；
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>相当于定义了</p>
<pre class="line-numbers language-none"><code class="language-none">class Empty&#123;
    public:
    Empty()&#123;&#125;;　　&#x2F;&#x2F;default构造
    Empty(const Empty&amp; rhs)&#123;&#125;;　　&#x2F;&#x2F;拷贝构造
    ~Empty();　　&#x2F;&#x2F;编译器合成的析构函数　　Empty&amp; operator&#x3D;(const Empty&amp; rhs)&#123;&#125;;&#x2F;&#x2F;拷贝赋值运算符
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于这本书标准不是C++11，有关默认移动构造和移动赋值函数等我了解了之后再补充</p>
<p>如果定义了带有参数的构造函数，则不再合成默认构造函数，但可以显式要求编译器合成</p>
<pre class="line-numbers language-none"><code class="language-none">Empty() &#x3D; default;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当类内含有引用成员或cont的成员时，编译器拒绝生成默认拷贝赋值运算符。</p>
<p>如果某个基类的拷贝赋值运算符为private,则编译器拒绝为其子类生成默认拷贝运算符</p>
<p><strong>注意：引用只能定义一次，定义后不能改变它的指向</strong></p>
<h2 id="06：若不想使用编译器自动生成的函数-就该明确拒绝"><strong>06：若不想使用编译器自动生成的函数，就该明确拒绝</strong></h2>
<p>书上给出的方法是定义一个基类，该基类的拷贝构造和拷贝赋值为private，另你的类继承于该基类，则编译器无法合成默认拷贝构造和拷贝赋值函数。</p>
<p>但是在C++11中，<strong>只需要这么在函数后加上delete</strong></p>
<pre class="line-numbers language-none"><code class="language-none">class Empty&#123;
    public:
    Empty()&#123;&#125;;
    Empty(const Empty&amp;) &#x3D; delete;
    Empty&amp; operator&#x3D;(const Empty&amp;) &#x3D; delete;
    ~Empty();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="07-为多态基类声明virtual析构函数">07:为多态基类声明virtual析构函数</h2>
<p>多态基类是为了通过基类指针来控制派生类对象</p>
<ul>
<li><strong>polymorphic(多态)基类应声明一个virtual析构函数， 任何一个类带有任何virtual函数，它就应该用于一个virtual析构函数</strong></li>
</ul>
<p>带有虚构函数的类一般作为基类使用，而如果该类没有虚析构函数，当其派生类对象执行析构时，会导致局部销毁，进而导致内存泄漏</p>
<pre class="line-numbers language-none"><code class="language-none">class Base
&#123;
public:
    Base() &#x3D; default;
    int testBase;
&#125;;

class Derived : public Base
&#123;
public:
    int testDerived;
&#125;;
int main()
&#123;
    Base* A &#x3D; new Base;
    Derived* B &#x3D; new Derived;
    A &#x3D; B;  
    delete A;       &#x2F;&#x2F;执行此语句时只会删掉Base部分的成员，而Derived的部分不会被删除
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意<strong>即使基类指针指向了派生类对象，该指针也只能操作基类成员，因此要定义虚函数来操作派生类对象。</strong></p>
<ul>
<li><strong>类的设计如不不是为了作为基类使用，或不是为了多态性，则不应声明virtual析构函数</strong></li>
</ul>
<p>因为会使对象占用内存增加。同时，为了让你的非基类、非多态用途的类不被继承，可以<strong>使用final关键字</strong>来禁止其派生。</p>
<pre class="line-numbers language-none"><code class="language-none">class NoDerived final
&#123;
     ...  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="08-别让异常逃离虚构函数">08:别让异常逃离虚构函数</h2>
<ul>
<li>
<p><strong>析构函数觉得不能抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或接受程序。</strong></p>
</li>
<li>
<p><strong>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应提供一个普通函数（而非在析构函数中）执行该操作</strong></p>
</li>
</ul>
<p>对于异常处理不熟悉，先记录，以后有机会补充</p>
<h2 id="09-绝不在构造和析构过程中调用virtual函数">09:绝不在构造和析构过程中调用virtual函数</h2>
<p>因为这类调用不会下降至派生类</p>
<p>考虑：</p>
<pre class="line-numbers language-none"><code class="language-none">class Transaction&#123;
public:
    Transaction();
    virtual void logTransaction() const &#x3D; 0;
&#125;;

Transaction::Transaction()
&#123;
    logTransaction();
&#125;

class BuyTransaction : public Transaction&#123;
public:
    virtual void logTransaction() const;
&#125;;

BuyTransaction a;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在定义a时，会先构造基类Transaction，此时调用的将会是基类的logTransaction()，因为在派生类对象的基类构造期间对象类型为基类而非派生类。</p>
<p>因此构造函数和析构函数都不能调用virtual函数</p>
<p>一种解决方案：</p>
<pre class="line-numbers language-none"><code class="language-none">class Transaction
&#123;
public:
    explicit Transaction(const std::string &amp;logInfo);
    void logTransaction(const std::string &amp;logInfo) const; &#x2F;&#x2F;非虚函数
&#125;;

Transaction::Transaction(const std::string &amp;logInfo)
&#123;
    &#x2F;&#x2F;...
    logTransaction(logInfo);
&#125;

class BuyTransaction : public Transaction
&#123;
public:
    BuyTransaction(parameters) : Transaction(createLogString(parameters)) &#123;&#125;

private:
    static std::string createLogString(parameters);
&#125;;
&#x2F;&#x2F;令派生类将必要构造信息向上传给基类狗在函数
&#x2F;&#x2F;从而让构造函数拜托虚函数
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="10-令operator-返回一个reference-to-this">10:令operator=返回一个reference to *this</h2>
<p>为了实现连锁赋值，即<strong>a = b = c = 15</strong>这种赋值，则需要这么做</p>
<pre class="line-numbers language-none"><code class="language-none">class Widget&#123;
public:
    Widget&amp; operator&#x3D;(const Widget&amp; rhs)
    &#123;
         ...
         return *this;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此协议使用于所有赋值运算，+= , -= , …</p>
<h2 id="11-在operator-中处理-自我赋值">11:在operator=中处理&quot;自我赋值&quot;</h2>
<pre class="line-numbers language-none"><code class="language-none">class widget
&#123;
public:
    widget &amp;operator&#x3D;(const widget &amp;rhs);

private:
    widget *wp;
&#125;;

widget &amp;widget::operator&#x3D;(const widget &amp;rhs)
&#123;
    delete wp;
    wp &#x3D; new widget(*rhs.wp);
    return *this;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当自我赋值时，会造成未定义行为，因为rhs在被删掉后还在使用，有三种方法解决</p>
<p><strong>使用证同测试来避免这个问题</strong></p>
<pre class="line-numbers language-none"><code class="language-none">widget &amp;widget::operator&#x3D;(const widget &amp;rhs)
&#123;
    if (this &#x3D;&#x3D; &amp;rhs)
    &#123;
        return *this;
    &#125;
    
    delete wp;
    wp &#x3D; new widget(*rhs.wp);
    return *this;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>精心周到的语句排序</strong></p>
<pre class="line-numbers language-none"><code class="language-none">widget &amp;widget::operator&#x3D;(const widget &amp;rhs)
&#123;
    widget* old &#x3D; wp;
    wp &#x3D; new widget(*rhs.wp);
    delete old;
    return *this;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>copy and swap技术</strong></p>
<pre class="line-numbers language-none"><code class="language-none">class widget
&#123;
public:
    widget &amp;operator&#x3D;(const widget &amp;rhs);
    void swap(widget&amp; rhs); &#x2F;&#x2F;交换*this和rhs的数据

private:
    widget *wp;
&#125;;

widget &amp;widget::operator&#x3D;(const widget &amp;rhs)
&#123;
    widget temp(rhs);
    swap(temp);
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或使用值传递的方式，这里会产生副本，并让*this与副本的数据互换</p>
<pre class="line-numbers language-none"><code class="language-none">widget&amp; operator&#x3D;(widget rhs)
&#123;
    swap(rhs);
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="12-复制对象时勿忘其每一个成分">12:复制对象时勿忘其每一个成分</h2>
<p>考虑如下代码</p>
<pre class="line-numbers language-none"><code class="language-none">class Base
&#123;
private:
    int base;
&#125;;

class Derived : public Base
&#123;
public:
    Derived(const Derived &amp;rhs);
    Derived &amp;operator&#x3D;(const Derived &amp;rhs);

private:
    int derived;
&#125;;

Derived::Derived(const Derived &amp;rhs) : derived(rhs.derived)
&#123;
    &#x2F;&#x2F;do something
&#125;

Derived&amp; Derived::operator&#x3D;(const Derived&amp; rhs)
&#123;
    &#x2F;&#x2F;do something
    derived &#x3D; rhs.derived;
    return *this;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它们并未对Base部分进行初始化，会调用默认构造函数，而这往往造成不想要的结果。</p>
<p>考虑到Base部分往往是private的，可以使用相应base部分的拷贝构造函数</p>
<pre class="line-numbers language-none"><code class="language-none">Derived::Derived(const Derived &amp;rhs) : Base(rhs), derived(rhs.derived)
&#123;
    &#x2F;&#x2F;do something
&#125;

Derived&amp; Derived::operator&#x3D;(const Derived&amp; rhs)
&#123;
    &#x2F;&#x2F;do something
    Base::operator&#x3D;(rhs);
    derived &#x3D; rhs.derived;
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveC++(3)(13~17)</title>
    <url>/2022/06/02/Effective%20C++/2022-03-07-EffectiveC++(3)(13~17)/</url>
    <content><![CDATA[<h2 id="13-以对象管理资源">13:以对象管理资源</h2>
<p>以对象管理资源的两个关键想法:</p>
<ol>
<li><strong>获得资源后立刻放进资源管理对象内</strong></li>
<li><strong>管理对象应用析构函数确保资源被释放</strong></li>
</ol>
<p>考虑：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class test&#123;
    public:
    test* createTets();     &#x2F;&#x2F;创建一个指向对象的指针
    void f();   &#x2F;&#x2F;用于删除使用完毕之后的对象
&#125;;

void test::f()
&#123;
    test* newTett &#x3D; createTets();
    &#x2F;&#x2F;...
    delete newTett;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的做法看似稳妥，但是假如在…部分有return语句使函数提前结束，则资源无法释放，久而久之造成内存泄漏。</p>
<p>有时候也会有无我们个人的原因，忘记析构某个对象之类的，为此我们的解决方案是<strong>利用对象管理资源</strong></p>
<p>如使用 <strong>shared_ptr</strong> 或 <strong>unique_ptr.</strong></p>
<p>但仍要注意，在使用shared_ptr时可能会造成的错误。</p>
<p>如：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;memory&gt;
#include &lt;iostream&gt;
int main()
&#123;
    int a &#x3D; 52;
    &#123;
        std::shared_ptr&lt;int&gt; test(&amp;a);
    &#125;
    std::cout &lt;&lt; a;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在test退出程序块时会释放掉内存，因此之前定义的变量a就不能使用了，需时刻注意。</p>
<p><strong>注意：shared_ptr在析构时调用的是delete而不是delete[ ],若想改变这一状况可自行传入删除器</strong></p>
<p><font size=5>请记住:</font></p>
<ol>
<li>为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源</li>
<li>两个常用的RAII类为shared_ptr与unique_ptr,前者通常为较佳选择，因为其复制行为比较直观，若选择unique_ptr,复制动作会报错，但是可以通过右值来转移所有权（即std::move)</li>
</ol>
<h2 id="14：在资源管理类中小心copying行为">14：在资源管理类中小心copying行为</h2>
<p>当一个RAII对象被复制，可以的选择是:</p>
<ul>
<li>
<p><strong>禁止复制</strong></p>
<p>有些RAII对象的复制并不合理，可以使用=delete来禁止这类对象的辅助。</p>
</li>
<li>
<p><strong>对底层资源使用&quot;引用计数&quot;</strong></p>
<p>在希望保有资源，知道其最后一个使用者被销毁。这种情况下使该资源的&quot;引用计数&quot;递增。</p>
<p>使用shared_ptr可以为一个资源管理类方便地添加一个引用计数功能，当shared_ptr析构时所做的操作不是你所想要的时候，可以为其提供一个删除其来提供合理的删除操作。</p>
</li>
<li>
<p><strong>复制底部资源</strong></p>
<p>使用&quot;资源管理类&quot;的唯一理由时确保在不再需要时被释放，此时复制资源管理对象，也应复制其所包覆的资源，即&quot;深拷贝&quot;。</p>
</li>
<li>
<p><strong>转移底部资源的拥有权</strong></p>
<p>自己编写拷贝函数，以免编译器合成的默认函数造成不符合预期的效果。</p>
</li>
</ul>
<h2 id="15：在资源管理类中提供对原始资源的访问">15：在资源管理类中提供对原始资源的访问</h2>
<p>在一些API中直接指涉资源，除非永远不会使用这样的API，否则只得绕过资源管理对象而直接访问原始资源。</p>
<p>类shared_ptr与unique_ptr都提供给了一个函数get(),用于返回智能指针的原始指针。</p>
<p>而shared_ptr与unique_ptr都重载了&quot;-&gt;“与”.&quot;，它们允许隐式转换至底部原始指针。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Investment
&#123;
    public:
    bool isTaxFree() const;
&#125;;

Investment* createInvestment();     &#x2F;&#x2F; factory函数
std::shared_ptr&lt;Investment&gt; pi1(createInvestment());
bool taxablel1 &#x3D; pi1-&gt;isTaxFree();       &#x2F;&#x2F; operator -&gt;
std::unique_ptr&lt;Investment&gt; pi2(createInvestment());
bool taxablel2 &#x3D; (*pi2).isTaxFree();    &#x2F;&#x2F; 右operator*访问资源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于有时候还是需要取得RAII对象内部的原始资源，为此可以设置一个显示get,例如：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class ResourceManage
&#123;
public:
    int *get()
    &#123;
        return a;
    &#125;

private:
    int *a;
&#125;;
&#x2F;&#x2F; 调用
ResourceManage a;
invoke(a.get());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这可能会造成大量的get调用。</p>
<p>或为类提供隐式转换函数</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class NeedType
&#123;&#125;;

class ResourceManage
&#123;
public:
    operator NeedType() const
    &#123;
        return a;
    &#125;
private:
    NeedType a;
&#125;;
&#x2F;&#x2F; 调用
ResourceManage a;
invoke(a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但这可能增加出错几率，可能会造成在赋值时调用隐式转换而造成预期之外的结果。</p>
<p><strong>请记住</strong></p>
<ol>
<li>API往往要求访问原始资源，所以每一个RAII类都有提供一个获取其所管理资源的方法。</li>
<li>对原始资源的访问可能经由显示转换和隐式转换，一般而言显示转换比较安全，而隐式转换比较方便。</li>
</ol>
<h2 id="16：成对使用new和delete时要采用相同的形式">16：成对使用new和delete时要采用相同的形式</h2>
<p>当使用new生成对象时，会:</p>
<ol>
<li>分配内存</li>
<li>在此内存上调用构造函数</li>
</ol>
<p>而当使用delete删除对象时，会：</p>
<ol>
<li>在此内存上调用析构函数</li>
<li>释放此内存</li>
</ol>
<p>然而如果对数组使用delete而非delete [ ]，则会造成未定义行为。</p>
<p>这常常意味着只删除了单一对象，数组内的其余对象未被删除。</p>
<p>同样的，对单一对象调用delete [ ]，也会造成未定义行为。</p>
<p>因此<strong>如调用new时使用了[ ]，则调用delete时也需要使用[ ],如果调用new时未使用[ ]，则调用delete时也不该使用[ ]</strong></p>
<p>此外，考虑</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef std::string AddressLines[4];
std::string* pal &#x3D; new AddressLines;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>则删除pal时必须使用[ ]:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">delete pal;	&#x2F;&#x2F;未定义
delete [] pal; &#x2F;&#x2F; 好<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>因此，最好不要对数组形式使用typedef。</p>
<h2 id="17：以独立语句将newed对象置入智能指针">17：以独立语句将newed对象置入智能指针</h2>
<p>考虑:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int priority();
void a(sharded_ptr&lt;Obj&gt; pw, int p);
a(new Obj, priority());		&#x2F;&#x2F; 无法通过编译，因为shared_ptr需要指针的构造函数是一个explicit函数
a(shared_ptr&lt;obj&gt;(new obj), priority());	&#x2F;&#x2F; 虽然通过编译，但是可能造成资源泄漏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么第二种方式可能会资源泄漏呢？</p>
<p>在以第二种形式调用时，需要做以下三件事：</p>
<ul>
<li>调用priority</li>
<li>执行&quot;new obj&quot;</li>
<li>调用shared_ptr构造函数</li>
</ul>
<p>但是由于C++编译器的自由性，编译器优化后可能会产生这样的顺序：</p>
<ul>
<li>执行&quot;new obj&quot;</li>
<li>调用priority</li>
<li>调用shared_ptr构造函数</li>
</ul>
<p>假如在调用priority时抛出异常，则new obj返回的指针不会被置入shared_ptr中，从而造成资源泄漏。</p>
<p>解决该问题的办法就是将new语句分开来写。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">shared_ptr&lt;obj&gt; pw(new obj);
a(pw, priority());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>请记住</strong></p>
<ul>
<li>以独立语句将newed对象存储入智能指针内，如果不这样做，一旦一场被抛出，则有可能产生难以察觉的资源泄漏。</li>
</ul>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveC++(4)</title>
    <url>/2022/06/03/Effective%20C++/2022-06-03-EffectiveC++(4)/</url>
    <content><![CDATA[<h2 id="18：让接口容易被正确使用-不易被误用">18：让接口容易被正确使用，不易被误用</h2>
<p>假如为一个表现日期的类设计构造函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Date
&#123;
    public:
    Date(int month, int day, int year);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在调用时可能会调用</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto date &#x3D; Date(2, 30, 2022);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>为防止这样的错误，可以导入新类型（利用类型系统）。</p>
<p>现在为上述例子导入简单的外覆类型来区别天数，月份与年数。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct Day
&#123;
    explicit Day(int d): val(d) &#123;&#125;
    int val;
&#125;;

struct Month
&#123;
    explicit Month(int month): val(month) &#123;&#125;
    int val;
&#125;;

struct Year
&#123;
    explicit Year(int year): val(year) &#123;&#125;
    int val;
&#125;;

class Date
&#123;
    public:
    Date(const Month&amp; month, const Day&amp; day, const Year&amp; year);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时再进行调用时，可以保证错误的传入不过编译。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto d1 &#x3D; Date(2, 30, 1998);                        &#x2F;&#x2F; wrong
auto d2 &#x3D; Date(Day(30), Month(2), Year(2022));      &#x2F;&#x2F; wrong
auto d2 &#x3D; Date(Month(3), Day(2), Year(2022));       &#x2F;&#x2F; right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可见，明智而审慎地导入新类型对预防“接口被误用”有奇效。</p>
<p>当一个类型地值有所限制时，我们可以预先定义其值，例如：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Month
&#123;
private:
    int val;

public:
    explicit Month(int month) : val(month) &#123;&#125;
    static Month Jan() &#123; return Month(1);&#125;
    static Month Fed() &#123; return Month(2);&#125;
    &#x2F;&#x2F;...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>预防错误地另一个方法是<strong>限制类型内什么事可以做，什么事不可以做</strong>，常见地限制为加上<strong>const</strong>，可回忆条款三。</p>
<p>另一个一般性准则为&quot;除非有好理由，否则应让自定义类型行为与内置类型行为一致&quot;。</p>
<p>例如对于<em>int</em>类型的<em>a</em>与<em>b</em>，对<em>a*b</em>赋值并不合法，那么自定义类型的&quot;*&quot;操作也不应能赋值。</p>
<p>避免无端与内置内省不兼容，其真正的理由是为了提供行为一致的接口。</p>
<p><strong>任何接口如果要求客户必须记得做某些事情，则存在着”不正确使用“的倾向</strong>，以为客户有可能忘记。</p>
<p>例如一个条款13的工厂函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Investment* create();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此函数返回的指针应被包覆于智能指针中，但考虑到客户有可能忘记，将其改为这样的形式往往是更好的选择：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">shared_ptr&lt;Investment&gt; create();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样几乎不存在忘记的可能。</p>
<p>假如类设计者希望可以从<strong>create</strong>返回的指针需要由函数<strong>getRidOfInvestment</strong>来销毁，而不是直接delete，那么可以为其提供一个删除器：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">shared_ptr&lt;Investment&gt; create()
&#123;
    shared_ptr&lt;Investment&gt; retVal(nullptr, getRidOfInvestment);
    retVal &#x3D; ...&#x2F;&#x2F;正确的指向
    return retVal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>shared_ptr另一个特别好的性质是：<strong>它会自动使用它的“每个指针专属的删除器”</strong>，这样可以避免另一个错误：“跨DLL内存分配”。</p>
<p>但是shared_ptr<strong>比原始指针大且慢，且使用辅助动态内存</strong>，但它“降低客户错误”的成效却是有目共睹的。</p>
<p><font size=8>请记住：</font></p>
<ul>
<li><strong>好的接口很容易被正确使用，不容易被误用，应在自定义接口中努力达成这一性质</strong></li>
<li><strong>“促进正确使用”的办法包括接口的一致性，以及于内置类型行为兼容</strong></li>
<li><strong>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值以及消除客户的资源管理责任</strong></li>
<li><strong>shared_ptr支持自定义删除器，这可以防范DLL问题，可悲用来自动解除互斥锁等等</strong></li>
</ul>
<hr>
<h2 id="19：设计class犹如type">19：设计class犹如type</h2>
<p><strong>好的type拥有自然的语法，直观的语义以及一个或多个高效实现品</strong>，因此再设计class时，应该确认：</p>
<ul>
<li>新type的对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？</li>
<li>新type的对象如果以值传递，意味着什么？</li>
<li>什么是新type的“合法值”？</li>
<li>你的新type需要配合某个继承体系吗（主要考虑虚函数的问题）？</li>
<li>你的新type需要什么样的转换？</li>
<li>什么样的操作符和函数对此新type而言是合理的？</li>
<li>什么样的标准函数应该被驳回？</li>
<li>谁该群用新type的成员？</li>
<li>什么是新type的“未声明接口”？</li>
<li>你的新type有多么一般化？</li>
<li>你真的需要一个新type吗？</li>
</ul>
<hr>
<h2 id="20：宁以传常量引用代替传值">20：宁以传常量引用代替传值</h2>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QScreen</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QScreen/</url>
    <content><![CDATA[<h1 id="availablegeometry">availableGeometry()</h1>
<p>获取应用程序可用区域</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QGuiApplication</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QGuiApplication/</url>
    <content><![CDATA[<h1 id="primaryscreen">primaryScreen()</h1>
<p>获取应用主屏幕</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QSystemTrayIcon</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QSystemTrayIcon/</url>
    <content><![CDATA[<p>此类用于在系统托盘中添加应用图标</p>
<h1 id="tooltip">toolTip</h1>
<p>托盘工具提示，你把鼠标放在图标上时出现的文字</p>
<p>使用setTooTip()设置</p>
<h1 id="show">show()</h1>
<p>在托盘显示你对象拥有的图标</p>
<h1 id="setcontextmenu-qmenu">setContextMenu(Qmenu*)</h1>
<p>设置用户通过鼠标事件来弹出的菜单（比如右键弹出菜单）</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QWebEngineView</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QWebEngineView/</url>
    <content><![CDATA[<h1 id="page">page()</h1>
<p>返回一个指向页面的指针，为QWebEnginePage*</p>
<h1 id="load">load()</h1>
<p>加载特定URL并展示它，不过视图保持不变，直到到达足够的数据以显示新 URL</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QWidget</title>
    <url>/2022/03/01/QtAPI/2022-03-01-QWidget/</url>
    <content><![CDATA[<h1 id="qt-wa-translucentbackground">Qt::WA_TranslucentBackground</h1>
<p>为你的控件设置透明背景，因为这个标志会使你的控件拥有一个阿尔法通道。这个属性一旦被设置，<strong>WA_NoSystemBackground</strong>则也被设置。在Windows上你的控件也需要设置窗口标志<strong>Qt::FramelessWindowHint</strong></p>
<h1 id="qt-wa-nosystembackground">Qt::WA_NoSystemBackground</h1>
<p>这个标志被设置意味着你的控件没有背景，即当控件接受绘画事件时，背景不会被自动重绘。</p>
<p>注意：不像<strong>WA_OpaquePaintEvent</strong>, 新曝光区域的背景永远不会被填充</p>
<h1 id="qt-wa-opaquepaintevent">Qt::WA_OpaquePaintEvent</h1>
<p>收到绘制事件时，绘制控件拥有的所有像素。但是不会重绘之前绘制的东西</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QPainter</title>
    <url>/2022/03/02/QtAPI/2022-03-02-QPainter/</url>
    <content><![CDATA[<h2 id="void-translate-const-qpointf-offset">void translate(const QPointF &amp;offset)</h2>
<p>按照给定偏移量平移坐标系(重设坐标原点)</p>
<h2 id="void-scale-qreal-sx-qreal-sy">void scale(qreal sx, qreal sy)</h2>
<p>按 （sx， sy） 缩放坐标系。</p>
<h2 id="void-qpainter-rotate-qreal-angle">void QPainter::rotate(qreal angle)</h2>
<p>顺时针旋转坐标系。给定的角度参数以度为单位。</p>
<h2 id="void-qpainter-drawpixmap-const-qrectf-target-const-qpixmap-pixmap-const-qrectf-source">void QPainter::drawPixmap(const QRectF &amp;target, const QPixmap &amp;pixmap, const QRectF &amp;source)</h2>
<p>将给定位图的矩形部分源绘制到绘制设备中的给定目标中</p>
<p>此函数有重载，详请查看帮助文档</p>
<p>此函数主要用于绘制图片</p>
<h2 id="void-qpainter-drawpolygon-const-qpointf-points-int-pointcount-qt-fillrule-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const QPointF *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill)</h2>
<p>使用points里的前pointCount个点进行多边形绘图</p>
<p>第一个点隐式连接到最后一个点，并且多边形用当前画笔填充。<strong>Qt::FillRule</strong></p>
<table>
<thead>
<tr>
<th>Qt::OddEvenFill</th>
<th>0</th>
<th>指定该区域使用奇偶填充规则填充。有了这条规则，我们可以用下面的方法来确定一个点是否在形状内部。从这一点画一条水平线到形状外面的一个位置，并计算交点的数量。如果交点个数是奇数，则该点在形状内。此模式为默认模式。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::WindingFill</td>
<td>1</td>
<td>Specifies that the region is filled using the non zero winding rule. With this rule, we determine whether a point is inside the shape by using the following method. Draw a horizontal line from the point to a location outside the shape. Determine whether the direction of the line at each intersection point is up or down. The winding number is determined by summing the direction of each intersection. If the number is non zero, the point is inside the shape. This fill mode can also in most cases be considered as the intersection of closed shapes.</td>
</tr>
</tbody>
</table>
<h2 id="bool-qpainter-begin-qpaintdevice-device">bool QPainter::begin(QPaintDevice *device)</h2>
<p>开始在绘图设备上绘图，如果成功返回true;否则返回false。</p>
<p>请注意，当调用begin()时，所有的painter的设置(setPen()， setBrush()等)都被重置为默认值。</p>
<p>请注意，大多数情况下，您可以使用其中一个构造函数来代替begin()，end()函数会在painter销毁时自动进行</p>
<p><strong>警告:一个绘画装置一次只能由一个画家进行绘画。</strong></p>
<p><strong>警告:不支持在QImage::Format_Indexed8格式的QImage上绘画。</strong></p>
<h2 id="bool-qpainter-end">bool QPainter::end()</h2>
<p>绘制结束。绘制时使用的任何资源将被释放。通常不需要调用它，因为它是由析构函数调用的。</p>
<p>如果绘制器不再活动，则返回true;否则返回false。</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QList</title>
    <url>/2022/03/04/QtAPI/2022-03-04-QList/</url>
    <content><![CDATA[<h2 id="removelast"><strong><strong>removeLast()</strong></strong></h2>
<p>从一个QList中拿走最后一个，自动调整大小，但是，<strong>如果存储的是指针，则不会不delete它</strong></p>
<h2 id="int-qlist-indexof-const-t-value-int-from-const"><strong><strong>int QList::indexOf(const T &amp;value, int from = …) const</strong></strong></h2>
<p>返回列表中第一个值出现的索引位置，从索引位置from向后搜索。如果没有匹配项，则返回-1。</p>
<p>此函数要求值类型具有operator==()的实现。</p>
<p><strong>请注意，QList使用基于0的索引，就像c++数组一样。除上面提到的值外，不支持负索引</strong></p>
<h2 id="const-t-qlist-at-int-i-const"><strong><strong>const T &amp;QList::at(int i) const</strong></strong></h2>
<p>返回列表中索引位置i处的项。我必须是一个有效的索引位置在列表(即，0 &lt;= i &lt; size())。</p>
<p>这个函数非常快(常数时间)。</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QAbstractButton</title>
    <url>/2022/03/05/QtAPI/2022-03-05-QAbstractButton/</url>
    <content><![CDATA[<h1 id="此章用于所有与button有关的控件"><strong>此章用于所有与button有关的控件</strong></h1>
<h2 id="ischeck">isCheck()</h2>
<p>如果这个按钮被选中，则返回true。只有checkable的button才有这个，默认为false</p>
<h2 id="text"><strong>text()</strong></h2>
<p>获取这个按钮的文字</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QPixmap</title>
    <url>/2022/03/05/QtAPI/2022-03-05-QPixmap/</url>
    <content><![CDATA[<h2 id="bool-qpixmap-load-const-qstring-filename-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor">*<em>bool QPixmap::load(const QString &amp;fileName, const char <em>format = nullptr, Qt::ImageConversionFlags flags = Qt::AutoColor)</em></em></h2>
<p>从指定文件名的文件中加载位图。如果位图成功加载，返回true;否则位图无效并返回false。</p>
<h2 id="qpixmap-qpixmap-scaled-const-qsize-size-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const"><strong>QPixmap QPixmap::scaled(const QSize &amp;size, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</strong></h2>
<p>使用由aspectRatioMode和transformMode指定的宽高比和转换模式，将位图缩放到给定的大小</p>
<p><strong>注意：此函数是使用值传递，因此不会改变传进去的pixmap,要想真正对pixmap改变，还请另赋值</strong></p>
<h3 id="qt-aspectratiomode">Qt::AspectRatioMode</h3>
<table>
<thead>
<tr>
<th><strong>Qt::IgnoreAspectRatio</strong></th>
<th><strong>0</strong></th>
<th><strong>大小可以自由缩放。长宽比没有限制。</strong></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Qt::KeepAspectRatio</strong></td>
<td><strong>1</strong></td>
<td><strong>在给定的矩形内，将尺寸缩放为尽可能大的矩形，并保留长宽比。</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Qt::KeepAspectRatioByExpanding</strong></td>
<td><strong>2</strong></td>
<td><strong>尺寸被缩放到一个矩形，在给定的矩形之外尽可能小，并保持长宽比。</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="transformmode">transformMode</h3>
<table>
<thead>
<tr>
<th><strong>Qt::FastTransformation</strong></th>
<th><strong>0</strong></th>
<th><strong>转换是快速执行的，没有平滑处理。</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Qt::SmoothTransformation</strong></td>
<td><strong>1</strong></td>
<td><strong>得到的图像使用双线性滤波进行变换。(平滑处理了)</strong></td>
</tr>
</tbody>
</table>
<h2 id="void-qpixmap-fill-const-qcolor-color-qt-white">void QPixmap::fill(const QColor &amp;color = Qt::white)</h2>
<p>用给定的颜色填充像素图。</p>
<p>当pixmap已经被绘制在设备上时，此函数的行为是未定义的</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QFont</title>
    <url>/2022/03/06/QtAPI/2022-03-06-QFont/</url>
    <content><![CDATA[<h2 id="void-qfont-sethintingpreference-qfont-hintingpreference-hintingpreference"><strong>void QFont::setHintingPreference(QFont::HintingPreference hintingPreference)</strong></h2>
<p><strong>将符号的提示级别的首选项设置为hintingPreference。这是对底层字体渲染系统使用某种程度的提示的提示，并且跨平台有不同的支持。</strong></p>
<p><strong>QFont::HintingPreference</strong></p>
<table>
<thead>
<tr>
<th>QFont::PreferDefaultHinting</th>
<th>0</th>
<th>使用目标平台的默认提示级别。</th>
</tr>
</thead>
<tbody>
<tr>
<td>QFont::PreferNoHinting</td>
<td>1</td>
<td>如果可能的话,在渲染文本时不要提示字形的轮廓。文本布局将是排版准确和可扩展的,使用与打印时相同的指标。</td>
</tr>
<tr>
<td>QFont::PreferVerticalHinting</td>
<td>2</td>
<td>如果可能的话,渲染文本时不要有水平提示,但在垂直方向上将字形与像素网格对齐。在密度过低而无法准确渲染字形的显示器上,文字会显得更清晰。但由于字形的水平度量是没有提示的,所以文本的布局将可以扩展到更高密度的设备上(如打印机),而不会影响换行符等细节。</td>
</tr>
<tr>
<td>QFont::PreferFullHinting</td>
<td>3</td>
<td>如果可能的话,在水平和垂直方向上渲染带有提示的文本。文本将被改变,以优化目标设备上的可读性,但由于指标将取决于文本的目标尺寸,字形、换行符和其他排版细节的位置将不按比例排列,这意味着文本布局在不同像素密度的设备上可能会有不同的外观。</td>
</tr>
</tbody>
</table>
<p><strong>翻译不够精准还请看官方文档</strong></p>
<h2 id="void-qfont-setpixelsize-int-pixelsize">void QFont::setPixelSize(int pixelSize)</h2>
<p>将字体大小设置为pixelSize像素。</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QFontDatabase</title>
    <url>/2022/03/06/QtAPI/2022-03-06-QFontDatabase/</url>
    <content><![CDATA[<h2 id="qstringlist-qfontdatabase-families-qfontdatabase-writingsystem-writingsystem-any-const"><strong>QStringList QFontDatabase::families(QFontDatabase::WritingSystem writingSystem = Any) const</strong></h2>
<p>返回支持writingSystem的可用字体族的排序列表。</p>
<p>如果一个字体族的名字对应着不同公司出的字体，则该字体返回的名称为family [foundry]。例如:Times [Adobe]，Times [Cronyx]，Palatino。</p>
<h2 id="int-qfontdatabase-addapplicationfont-const-qstring-filename"><strong>int QFontDatabase::addApplicationFont(const QString &amp;fileName)</strong></h2>
<p>从fileName指定的文件加载字体，并使其可用于应用程序。返回一个ID，可以使用removeApplicationFont()再次删除字体，或者检索字体中包含的家族名称列表。</p>
<p>如果字体无法加载，函数返回-1。</p>
<p>目前只支持TrueType字体、TrueType字体集合和OpenType字体。</p>
<h2 id="qstringlist-qfontdatabase-applicationfontfamilies-int-id"><strong>QStringList QFontDatabase::applicationFontFamilies(int id)</strong></h2>
<p>返回由id标识的给定应用程序字体的字体族列表。</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QPolygon</title>
    <url>/2022/03/06/QtAPI/2022-03-06-QPolygon/</url>
    <content><![CDATA[<h2 id="void-qpolygon-setpoints-int-npoints-const-int-points">void QPolygon::setPoints(int nPoints, const int *points)</h2>
<p>根据数组设置多边形的点。参数1是设置点的个数。有函数重载</p>
<h2 id="void-putpoints-int-index-int-npoints-int-firstx-int-firsty"><strong>void putPoints(int index, int nPoints, int firstx, int firsty, …)</strong></h2>
<p>将变量参数列表中的点从给定索引添加到当前多边形中。参数1是添加起始的索引，参数2是添加的点的个数，参数3、4是添加的第1个点的x、y…</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QHostInfo</title>
    <url>/2022/03/09/QtAPI/2022-03-09-QHostInfo/</url>
    <content><![CDATA[<h1 id="qlist-qhostaddress-addresses"><strong>QList<QHostAddress>  addresses()</strong></h1>
<p>返回与hostName()主机关联的IP地址列表</p>
<h1 id="hostinfoerror-error"><strong>HostInfoError  error()</strong></h1>
<p>如果主机查找失败，返回失败类型</p>
<h1 id="qstring-errorstring"><strong>QString  errorString(）</strong></h1>
<p>如果主机查找失败，返回错误描述字符串</p>
<h1 id="qstring-hostname"><strong>QString  hostName()</strong></h1>
<p>返回通过IP查找的主机名称</p>
<h1 id="int-lookupid"><strong>int  lookupId()</strong></h1>
<p>返回本次查找的ID</p>
<h1 id="void-aborthostlookup-int-id"><strong>void abortHostLookup(int id)</strong></h1>
<p>中断主机查找</p>
<h1 id="qhostinfo-fromname-qstring-name"><strong>QHostInfo  fromName(QString&amp; name)</strong></h1>
<p>返回指定主机名的IP地址</p>
<h1 id="qstring-localdomainname"><strong>QString  localDomainName()</strong></h1>
<p>返回本机DNS域名</p>
<h1 id="qstring-localhostname"><strong>QString  localHostName()</strong></h1>
<p>返回本机主机名</p>
<h1 id="int-lookuphost-qstring-name-qobject-receiver-char-member"><em><em>int  lookupHost(QString&amp; name, QObject</em> receiver, char</em> member)**</h1>
<p>以异步方式根据主机名查找主机的IP地址，并返回一个表示本次查找的ID,可用于abortHostLookup()</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QNetworkInterface</title>
    <url>/2022/03/10/QtAPI/2022-03-10-QNetworkInterface/</url>
    <content><![CDATA[<h1 id="qlist-qnetworkaddressentry-addressentries">QList<QNetworkAddressEntry> addressEntries()</h1>
<p>返回该网络接口（包括子网掩码和广播地址）的IP地址列表</p>
<h1 id="qstring-hardwareaddress">QString hardwareAddress()</h1>
<p>返回该接口的低级硬件地址，以太网里就是MAC地址</p>
<h1 id="qstring-humanreadablename">QString humanReadableName()</h1>
<p>返回可以读懂的接口名称，若名称不确定，则会得到name()返回值</p>
<h1 id="bool-isvalid">bool isValid()</h1>
<p>如果接口信息有效返回true</p>
<h1 id="qstring-name">QString name()</h1>
<p>返回网络接口名称</p>
<h1 id="qlist-qhostaddress-alladdresses">QList<QHostAddress> allAddresses()</h1>
<p>返回主机上所有IP地址的列表</p>
<h1 id="qlist-qnetworkinterface-allinterface">QList<QNetworkInterface> allInterface()</h1>
<p><strong><strong>返回主机上所有接口的列表</strong></strong></p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QNetworkAddressEntry</title>
    <url>/2022/03/13/QtAPI/2022-03-13-QNetworkAddressEntry/</url>
    <content><![CDATA[<h1 id="qhostaddress-qnetworkaddressentry-ip-const"><strong>QHostAddress QNetworkAddressEntry::ip() const</strong></h1>
<p><strong>这个函数返回一个在网络接口中找到的IPv4或IPv6地址。</strong></p>
<h1 id="qhostaddress-qnetworkaddressentry-netmask-const"><strong>QHostAddress QNetworkAddressEntry::netmask() const</strong></h1>
<p>**返回与IP地址关联的子网掩码。子网掩码采用IP地址形式，**如255.255.0.0。</p>
<p>对于IPv6地址，前缀长度转换为地址中位数为1的地址与前缀长度相等。如果前缀长度为64位(最常用的值)，netmask将被表示为QHostAddress，其中包含地址FFFF:FFFF:FFFF:FFFF::</p>
<h1 id="qhostaddress-qnetworkaddressentry-broadcast-const"><strong>QHostAddress QNetworkAddressEntry::broadcast() const</strong></h1>
<p>**返回与IPv4地址和子网掩码相关联的广播地址。**它通常可以通过将子网掩码包含0的IP地址位设置为1来派生。(换句话说，通过按位或者用网络掩码的逆来计算IP地址)</p>
<p>这个成员对于IPv6地址来说总是空的，因为广播的概念在这个系统中已经被放弃了，取而代之的是组播。特别是，全节点专用组播组(地址FF02::1)可以到达本地网络中所有节点对应的主机组。</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QAbstractSocket</title>
    <url>/2022/03/14/QtAPI/2022-03-14-QAbstractSocket/</url>
    <content><![CDATA[<p><strong>QTcpSocket除构造与析构外均从此类继承</strong></p>
<h1 id="virtual-void-qabstractsocket-connecttohost-const-qhostaddress-address-quint16-port-qiodevice-openmode-openmode-readwrite">[virtual] void QAbstractSocket::connectToHost(const QHostAddress &amp;address, quint16 port, QIODevice::OpenMode openMode = ReadWrite)</h1>
<p>以异步方式连接到指定IP地址和端口的TCP服务器，连接成功则发送connected()信号</p>
<h1 id="virtual-void-qabstractsocket-disconnectfromhost">[virtual] void QAbstractSocket::disconnectFromHost()</h1>
<p>断开socket,关闭成功后发射disconnected()信号</p>
<h1 id="virtual-bool-qabstractsocket-waitforconnected-int-msecs-30000">[virtual] bool QAbstractSocket::waitForConnected(int msecs = 30000)</h1>
<p>等待知道建立socked连接，做多等msecs秒</p>
<h1 id="virtual-bool-qabstractsocket-waitfordisconnected-int-msecs-30000">[virtual] bool QAbstractSocket::waitForDisconnected(int msecs = 30000)</h1>
<p>等待直到socket断开连接</p>
<h1 id="qhostaddress-qabstractsocket-localaddress-const">QHostAddress QAbstractSocket::localAddress() const</h1>
<p>返回本socket的地址</p>
<h1 id="quint16-qabstractsocket-localport-const">quint16 QAbstractSocket::localPort() const</h1>
<p>返回本socket的端口</p>
<h1 id="qhostaddress-qabstractsocket-peeraddress-const">QHostAddress QAbstractSocket::peerAddress() const</h1>
<p>在已连接状态下，返回对方socket的地址</p>
<h1 id="quint16-qabstractsocket-peerport-const">quint16 QAbstractSocket::peerPort() const</h1>
<p>在已连接状态下，返回对方socket的端口</p>
<h1 id="qint64-qabstractsocket-readbuffersize-const">qint64 QAbstractSocket::readBufferSize() const</h1>
<p>返回内部读取缓冲区的大小，该大小决定了read()和readAll()函数能读出的数据大小</p>
<h1 id="virtual-void-qabstractsocket-setreadbuffersize-qint64-size">[virtual] void QAbstractSocket::setReadBufferSize(qint64 size)</h1>
<p>设置内部读取缓冲区大小</p>
<h1 id="override-virtual-qint64-qabstractsocket-bytesavailable-const">[override virtual] qint64 QAbstractSocket::bytesAvailable() const</h1>
<p>返回需要读取的缓冲区数据的字节数</p>
<h1 id="override-virtual-bool-qabstractsocket-canreadline-const">[override virtual] bool QAbstractSocket::canReadLine() const</h1>
<p>如果有行数据要从socket缓冲区读取，返回true</p>
<h1 id="qabstractsocket-socketstate-qabstractsocket-state-const">QAbstractSocket::SocketState QAbstractSocket::state() const</h1>
<p>返回socket当前状态</p>
<p>signals:</p>
<h1 id="void-connected">void connected()</h1>
<p>connectToHost()成功连接到服务器后发射</p>
<h1 id="void-disconnected">void disconnected()**</h1>
<p>socket断开后发射</p>
<h1 id="void-error-qabstractsocket-socketerror-socketerror">void error(QAbstractSocket::SocketError socketError)</h1>
<p>socket错误后发射</p>
<h1 id="void-hostfound">void hostFound()</h1>
<p>调用connectToHost()找到主机后发射</p>
<h1 id="void-proxyauthenticationrequired-const-qnetworkproxy-proxy-qauthenticator-authenticator">** void proxyAuthenticationRequired(const QNetworkProxy &amp;proxy, QAuthenticator <em>authenticator)</em>*</h1>
<p><strong>当使用需要身份验证的代理时，可以发出此信号。然后，可以在验证器对象中填充所需的详细信息，以允许验证并继续连接。</strong></p>
<p><strong>注意:不可能使用QueuedConnection连接到这个信号，因为当信号返回时，如果未将新信息填充到验证器，则连接将失败。</strong></p>
<h1 id="void-statechanged-qabstractsocket-socketstate-socketstate">** void stateChanged(QAbstractSocket::SocketState socketState)**</h1>
<p><strong><strong>当socket状态变化是发射，socketState表示了socket当前状态</strong></strong></p>
<h1 id="void-readyread"><strong>void readyRead()</strong></h1>
<p><strong><strong>当缓冲区有新数据需要读取时发射,在此信号的槽函数里读取缓冲区数据</strong></strong></p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QHostAddress</title>
    <url>/2022/03/14/QtAPI/2022-03-14-QHostAddress/</url>
    <content><![CDATA[<p>QHostAddress类提供一个IP地址。</p>
<p>这个类提供一种独立于平台和协议的方式来保存IPv4和IPv6地址。</p>
<h1 id="bool-isloopback-const">bool isLoopback() const</h1>
<p>如果地址是IPv6的环回地址，或任何IPv4的环回地址，则返回true。</p>
<h1 id="bool-isnull-const">bool isNull() const</h1>
<p>如果主机地址为空（INADDR_ANY 或 in6addr_any），返回true。默认的构造函数创建一个空的地址，这个地址对于任何主机或接口是无效的。</p>
<h1 id="qabstractsocket-networklayerprotocol-protocol-const">QAbstractSocket::NetworkLayerProtocol protocol() const</h1>
<p>返回主机地址的网络层协议。</p>
<h1 id="qstring-scopeid-const">QString scopeId() const</h1>
<p>返回IPv6地址的范围ID。对于IPv4地址，如果该地址不包含范围ID，则返回一个空字符串。</p>
<p>IPv6的范围ID指定非全球IPv6地址范围的可达性，限制地址可以被使用的区域。所有IPv6地址与这种可达范围相关联。范围ID用于消除那些不能保证是全局唯一性的地址。</p>
<h1 id="枚举-qhostaddress-specialaddress"><strong>枚举 QHostAddress::SpecialAddress</strong></h1>
<table>
<thead>
<tr>
<th>QHostAddress::Null</th>
<th>0</th>
<th>空地址对象，相当于QHostAddress()。</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>QHostAddress::LocalHost</strong></td>
<td><strong>2</strong></td>
<td><strong>IPv4本地主机地址，相当于QHostAddress(127.0.0.1)。</strong></td>
</tr>
<tr>
<td><strong>QHostAddress::LocalHostIPv6</strong></td>
<td><strong>3</strong></td>
<td><strong>Pv6本地主机地址，相当于 QHostAddress(::1)。</strong></td>
</tr>
<tr>
<td><strong>QHostAddress::Broadcast</strong></td>
<td><strong>1</strong></td>
<td><strong>IPv4广播地址，相当于QHostAddress(255.255.255.255)。</strong></td>
</tr>
<tr>
<td><strong>QHostAddress::AnyIPv4</strong></td>
<td><strong>6</strong></td>
<td><strong>IPv4 any-address，相当于QHostAddress(0.0.0.0)。与该地址绑定的socket将只监听IPv4接口。</strong></td>
</tr>
<tr>
<td><strong>QHostAddress::AnyIPv6</strong></td>
<td><strong>5</strong></td>
<td><strong>IPv6 any-address，相当于QHostAddress(::)。与该地址绑定的socket将只监听IPv4接口。</strong></td>
</tr>
<tr>
<td><strong>QHostAddress::Any</strong></td>
<td><strong>4</strong></td>
<td><strong>双any-address栈，与该地址绑定的socket将侦听IPv4和IPv6接口。</strong></td>
</tr>
</tbody>
</table>
<p><a href="https://blog.csdn.net/iamplane/article/details/70738406">参考地址</a></p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>QTcpServer</title>
    <url>/2022/03/14/QtAPI/2022-03-14-QTcpServer/</url>
    <content><![CDATA[<p><strong>该类用于服务器端建立网络监听，创建网络Socket连接</strong></p>
<h1 id="public"><strong>public:</strong></h1>
<h1 id="void-qtcpserver-close">void QTcpServer::close()</h1>
<p>关闭服务器，停止网络监听</p>
<h1 id="bool-qtcpserver-listen-const-qhostaddress-address-qhostaddress-any-quint16-port-0">bool QTcpServer::listen(const QHostAddress &amp;address = QHostAddress::Any, quint16 port = 0)</h1>
<p>在给定IP地址和端口上开始监听，若成功就返回true</p>
<h1 id="bool-qtcpserver-islistening-const">bool QTcpServer::isListening() const</h1>
<p>返回true表示服务器处于监听状态</p>
<h1 id="virtual-qtcpsocket-qtcpserver-nextpendingconnection">[virtual] QTcpSocket *QTcpServer::nextPendingConnection()</h1>
<p>返回下一个等待接入的连接</p>
<h1 id="qhostaddress-qtcpserver-serveraddress-const">QHostAddress QTcpServer::serverAddress() const</h1>
<p>如果服务器处于监听状态，返回服务器地址</p>
<h1 id="quint16-qtcpserver-serverport-const">quint16 QTcpServer::serverPort() const</h1>
<p>如果服务器处于监听状态，返回监听端口</p>
<h1 id="bool-qtcpserver-waitfornewconnection-int-msec-0-bool-timedout-nullptr">bool QTcpServer::waitForNewConnection(int msec = 0, bool *timedOut = nullptr)</h1>
<p>以阻塞方式等待新的连接</p>
<h1 id="signals"><strong>signals:</strong></h1>
<h1 id="signal-void-qtcpserver-accepterror-qabstractsocket-socketerror-socketerror"><strong>[signal] void QTcpServer::acceptError(QAbstractSocket::SocketError socketError)</strong></h1>
<p>当接受一个新的连接发生错误时发射此信号，参数socketError描述了错误信息</p>
<h1 id="signal-void-qtcpserver-newconnection">[signal] void QTcpServer::newConnection()</h1>
<p><strong>当有新的连接时发射此信号</strong></p>
<h1 id="protected"><strong>protected:</strong></h1>
<h1 id="virtual-protected-void-qtcpserver-incomingconnection-qintptr-socketdescriptor"><strong>[virtual protected] void QTcpServer::incomingConnection(qintptr socketDescriptor)</strong></h1>
<p><strong>当有一个新的连接可用时，QTcpServer内部调用此函数，创建一个QTcpSocket对象，添加到内部可用新连接列表，然后发送newConnection()信号。用户若从QTcpServer继承定义类，可以重定义此函数，但必须调用</strong></p>
<p><strong>addPendingConnection()</strong></p>
<h1 id="protected-void-qtcpserver-addpendingconnection-qtcpsocket-socket">*<em>[protected] void QTcpServer::addPendingConnection(QTcpSocket <em>socket)</em></em></h1>
<p><strong>由incomingConnection()调用，将创建的QTcpServer添加到内部新可用连接列表</strong></p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt API</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt动画框架使用</title>
    <url>/2022/05/26/Qt%E4%BD%BF%E7%94%A8/2022-05-26-Qt%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>最近在考虑上位机的问题，在使用纯Qt + C++ + OpenCV和使用OpenCV + C# 中徘徊，但最后考虑到我不太会C#，就选择了Qt,因此怎么也该来学习学习了。<br>
　　本文算是一篇转载文章。<br>
　　原文<a href="https://blog.csdn.net/qinhoupingss/article/details/47961507">点这里</a>。<br>
<img src="https://s2.loli.net/2022/05/28/g5xc4f3GWOvohUD.gif" alt="1.gif"></p>
<h2 id="qt-animation-framework继承体系">Qt Animation Framework继承体系</h2>
<p>Qt有一套专门的动画框架，其继承体系如下图。<br>
<img src="https://s2.loli.net/2022/05/28/FXdBOjHKyvqEMC8.jpg" alt="2.jpg"><br>
　　Qt动画框架基石由<strong>QAbstractAnimation</strong>以及它的两个子类<strong>QVariantAnimation</strong>和<strong>QAnimationGroup</strong>组成。<strong>QAbstractAnimation</strong>类是所有动画类的祖先。它包含了一些在框架中被普遍使用的基本功能；尤其是启动、停止和暂停动画功能。它也接收定时触发通知。</p>
<p>Qt动画框架更是提供了<strong>QPropertyAnimation</strong>类，该类继承于<strong>QVariantAnimation</strong>类，用于对Qt属性的动画操作(Qt属性系统是Qt元对象系统的一部分)。<strong>QPropertyAnimation</strong>类使用缓和曲线算法对属性进行插值演化操作。因此当你想动画改变一个值时，你就声明该值为一个属性值并且使该类为成为一个<strong>QObject</strong>对象。这给我们提供了很大的方便性去动画操作现有的部件和其他的<strong>QObject</strong>对象。</p>
<p>复杂动画可以通过构建Q<strong>AbstractAnimation</strong>树形结构来构造。该树主要使用<strong>QAnimationGroup</strong>，<strong>QAnimationGroup</strong>类是一个包含其他动画类的容器类；同时<strong>QAnimationGroup</strong>类也是<strong>QAbstractAnimation</strong>类的子类，因此一个容器可以包含其他容器。</p>
<p>Qt动画框架既是独立的一部分，也是Qt状态机框架的一部分。Qt状态机框架提供一个状态用来行使动画。当<strong>QState</strong>进入或者退出时可以改变属性，当这个动画状态提供了一个<strong>QPropertyAnimatio</strong>时，则动画状态即在这些值之间进行插值衍化操作。</p>
<table>
<thead>
<tr>
<th>QAbstractAnimation</th>
<th>所有动画类的基类</th>
</tr>
</thead>
<tbody>
<tr>
<td>QAnimationGroup</td>
<td>动画容器类的抽象基类</td>
</tr>
<tr>
<td>QEasingCurve</td>
<td>动画控制的缓和曲线类</td>
</tr>
<tr>
<td>QParallelAnimationGroup</td>
<td>并行动画容器</td>
</tr>
<tr>
<td>QPauseAnimation</td>
<td>QSequentialAnimationGroup对象暂停延迟</td>
</tr>
<tr>
<td>QPropertyAnimation</td>
<td>Qt动画属性操作</td>
</tr>
<tr>
<td>QSequentialAnimationGroup</td>
<td>串行动画容器</td>
</tr>
<tr>
<td>QTimeLine</td>
<td>动画控制的时间片类</td>
</tr>
<tr>
<td>QVariantAnimation</td>
<td>动画类的抽象基类</td>
</tr>
</tbody>
</table>
<h2 id="qt动画属性">Qt动画属性</h2>
<p>正如上述所提到的，QPropertyAnimation类能够修改Qt属性值。正是该类用于改变动画属性值；事实上，它的基类QVariantAnimation是一个抽象类，所以QVariantAnimation不能被直接使用。<br>
　　我们选用Qt动画属性的一个主要原因是由于它给了我们很大的自由性去动画操作已经存在的类，尤其是拥有bounds、colors等属性的QWidget类(QWidget能被嵌入到QGraphicsView类)。我们看看一个小例子：</p>
<pre class="line-numbers language-none"><code class="language-none">void QtWidgetsApplication1::on_btn_clicked()
&#123;
　　QPropertyAnimation* animation &#x3D; new 　　QPropertyAnimation(ui.label, &quot;geometry&quot;);
　　animation-&gt;setDuration(10000);
　　animation-&gt;setStartValue(QRect(0, 0, 200, 200));
　　animation-&gt;setEndValue(QRect(500, 500, 　　this-&gt;width(), this-&gt;height()));
　　animation-&gt;start();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码使按钮被按下后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">label</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>在10秒内移动到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>500</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(500,500)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span><br>
<strong>注意：在我测试的过程中，发现只有指针形式的调用才能实现次效果</strong><br>
　　也可以做到类似CSS中的@keyframe效果，例如：</p>
<pre class="line-numbers language-none"><code class="language-none">void QtWidgetsApplication1::on_btn_clicked()
&#123;
　　QPropertyAnimation* animation &#x3D; new QPropertyAnimation(ui.label, &quot;geometry&quot;);
　　animation-&gt;setDuration(10000);
　　animation-&gt;setKeyValueAt(0, QRect(0, 0, 500, 500));
　　animation-&gt;setKeyValueAt(0.5, QRect(250, 250, 500, 500));
　　animation-&gt;setKeyValueAt(1.0, QRect(0, 0, 500, 500));
　　animation-&gt;start();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而在自定义动画属性时，<strong>必须使用宏Q_PROPERTY设置访问与设置的函数</strong>，这样才能正确使用。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">class MyGraphicsRectItem : public QObject, public QGraphicsRectItem
&#123;
    Q_OBJECT
    Q_PROPERTY(QRectF geometry READ geometry WRITE setGeometry)
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="动画和图形视图框架">动画和图形视图框架</h2>
]]></content>
      <categories>
        <category>Qt具体使用</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt使用</tag>
      </tags>
  </entry>
  <entry>
    <title>基本命令与热键</title>
    <url>/2022/03/06/linux/2022-03-06-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%83%AD%E9%94%AE/</url>
    <content><![CDATA[<h1 id="命令">命令</h1>
<h1 id="cal-month-year">cal [month] [year]</h1>
<p>显示某年某月的日历</p>
<h1 id="date">**date **</h1>
<p>显示时间日期</p>
<h1 id="bc"><strong>bc</strong></h1>
<p>命令行下的计算器，默认仅输出整数，如果要输出小数点下位数可以使用</p>
<p><strong>scale=number</strong></p>
<p>使用<strong>quit</strong>退出</p>
<h1 id="可选参数-help"><strong>可选参数–help</strong></h1>
<p>大多数命令都有这个参数，用于查询命令所具有的选项和参数</p>
<h1 id="man-命令"><strong>man 命令</strong></h1>
<p>用于查看命令的详细说明，按下【空格键】翻页，按下【q】离开</p>
<p>命令后可能有数字，如date(1)，最重要的三个为</p>
<ul>
<li>1：用户在shell环境中可以操作的命令和可执行文件</li>
<li>5：配置文件或是某些文件的格式</li>
<li>8：系统管理员可用的管理命令</li>
</ul>
<p>其余自行查阅</p>
<p>在man页面，使用 **/word **来向下查找所有word所在地，用？word来向上查找</p>
<p><strong>热键</strong></p>
<h1 id="tab">[tab]</h1>
<p>如果跟在一串命令的第一个字段后，则会显示所有以输入数据开头的命令</p>
<p>如果跟在一串命令的第二个字段后，则为【文件补齐】</p>
<h1 id="ctrl-c"><strong>[ctrl]+c</strong></h1>
<p>中断目前程序</p>
<h1 id="ctrl-d"><strong>[ctrl]+d</strong></h1>
<p>键盘输入结束，可以离开命令行模式</p>
<h1 id="shift-page-up-page-down"><strong>[shift]+{[Page Up]|[Page Down]}</strong></h1>
<p>前后翻页</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt图形视图框架</title>
    <url>/2022/05/28/Qt%E4%BD%BF%E7%94%A8/2022-05-28-Qt%E5%9B%BE%E5%BD%A2%E8%A7%86%E5%9B%BE%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>为了应付大作业<s>更好的整活</s>，我需要学习以下Qt的图形视图框架。<br>
　　本文内容主要来自<a href="https://blog.csdn.net/qq_25800311/article/details/81002822">这里</a></p>
<h2 id="图形视图框架概述">图形视图框架概述</h2>
<p>如果要绘制成千上万的图形，并且对它们进行控制，比如拖动这些图形、检测它们的位置以及判断它们是否碰撞等，可以使用Qt提供的图形视图框架来进行设计。</p>
<p>图形视图框架提供了一个基于图形项的模型视图编程方法，主要由场景、视图和图形项三部分组成，这三部分分别由<strong>QGraphicsScene</strong>、<strong>QGraphicsView</strong>和<strong>QGraphicsItem</strong>这三个类来表示。多个视图可以查看一个场景，场景中包含各种各样几何形状的图形项。</p>
<p>图形视图框架可以管理数量庞大的自定义2D图形项，并且可以与它们进行交互。使用视图部件可以使这些图形项可视化，视图还支持缩放与旋转。框架中包含了一个事件传播架构，提供了和场景中的图形项进行精确的双精度交互的能力。图形视图框架使用一个<strong>BSP(Binary Space Partitioning)树</strong>来快速发现图形项。可通过<strong>Graphics View Framework</strong>关键字查看相关帮助。</p>
<h2 id="场景">场景</h2>
<p><strong>QGraphicsItem</strong>是场景中图形项的基类。典型的形状的标准图形项有矩形(<strong>QGraphicsRectItem</strong>)、椭圆(<strong>QGraphicsEllipseItem</strong>)和文本项(<strong>QGraphicsTextItem</strong>)等。但只有编写自定义的图形项才能发挥<strong>QGraphicsItem</strong>的强大功能。</p>
<p><strong>QGraphicsItem</strong>主要支持如下功能：</p>
<ul>
<li>
<p>鼠标按下、移动、释放、双击、悬停、滚轮和右键菜单事件</p>
</li>
<li>
<p>键盘输入焦点和键盘事件</p>
</li>
<li>
<p>拖放事件</p>
</li>
<li>
<p>碰撞检测</p>
</li>
</ul>
<p>除此之外，图形项还可以存储自定义的数据，可以使用<strong>setData</strong>()进行数据存储，然后使用<strong>data</strong>()获取其中的数据。</p>
<p>要实现自定义的图形项，那么首先要创建一个<strong>QGraphicsItem</strong>的子类，然后重新实现它的两个纯虚公共函数:<strong>boundingRect</strong>()和<strong>paint</strong>()，前者用来返回要绘制图形项的矩形区域，后者用来执行实际的绘图操作。其中<strong>boundingRect</strong>()函数将图形项的外部边界定义为一个矩形，所有的绘图操作都必须限制在图形项的边界矩形中。这个矩形对于剔除不可见图形项、确定绘制交叉项目时哪些区域需要重新构建、碰撞检测机制都很重要。一定要保证所有绘图都在<strong>boundingRect</strong>()的边界之中，特别是当<strong>QPainter</strong>使用了指定的QPen来渲染图形的边界轮廓时，绘制的图形的边界线的一般会在外面，一半会在里面（例如使用了宽度为两个单位的画笔，就必须在<strong>boundingRect</strong>()里绘制一个单位的边界线），这也是在<strong>boundingRect</strong>()中要包含半个画笔宽度的原因。<br>
　　纯虚函数实现示例：</p>
<pre class="line-numbers language-none"><code class="language-none">QRectF MyItem::boundingRect() const
&#123;
    qreal penWidth &#x3D; 1; &#x2F;&#x2F;画笔宽度
    return QRectF(0 - penWidth &#x2F; 2, 0 - penWidth &#x2F; 2,
                  20 + penWidth, 20 + penWidth);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">void MyItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *, QWidget *)
&#123;
    painter-&gt;setBrush(Qt::red);
    painter-&gt;drawRect(0, 0, 20, 20);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>##图形视图框架的坐标系统<br>
　　图形视图框架基于笛卡尔坐标系统。图形视图框架中有3个有效的坐标系统：<strong>图形项坐标</strong>、<strong>场景坐标</strong>和<strong>视图坐标</strong>。进行绘图时，场景坐标对应QPainter的逻辑坐标，视图坐标对应设备坐标。</p>
<h3 id="图形项坐标">图形项坐标</h3>
<p>图形项使用自己的本地坐标系统，<strong>坐标通常是以（0,0）为原点</strong>，而这也是所有变换的中心。当要创建一个自定义图形项时，只需要考虑图形项的坐标系统，而且一个图形项的边界矩形和图形形状都是在图形项坐标系统中的。</p>
<p>图形项的位置是指<strong>图形项的原点在其父图形项或者场景中的位置</strong>。可以使用<strong>setPos</strong>（）函数来指定图形项的位置，如果没有指定，默认出现在父图形项或者场景的原点处。</p>
<p>子图形项的位置和坐标是相对于父图形项的，虽然父图形项的坐标变换会隐含地变换子图形项，但<strong>子图形项的坐标不会受到父图形项的变换的影响</strong>。例如，在没有坐标变换时，子图形项就在父图形项的（10,0）点，那么子图形项中的（0,10）点就对应了父图形项的（10,10）点。现在即使父图形项进行了旋转或者缩放，子图形项的（0,10）点仍对应着父图形项的（10,10）点。但是相对于场景，子图形项就会跟随父图形项的变换，例如，父图形项放大为（2x，2x），那么子图形项在场景中的位置就会变成（20,0），它的（10,0）点就会对应着场景中的（40,0）点。</p>
<p>所有的图形项都会使用确定的顺序来进行绘制，这个顺序也决定了单击场景时哪个图形项会先获得鼠标输入。一个子图形项会堆叠在父图形项的上面，而兄弟图形项会以插入顺序进行堆叠。<strong>所有图形项都包含一个Z值来设置它们的层叠顺序</strong>，一个图形项的Z值默认为0，可以使用<strong>QGraphicsItem::setZValue</strong>()来改变一个图形项的Z值，从而使它堆叠到其兄弟图形项的上面（使用较大的Z值）或者下面（使用较小的Z值）。</p>
<h3 id="场景坐标">场景坐标</h3>
<p>场景坐标是所有图形项的基础坐标系统。场景坐标的原点在场景的中心，x和y坐标分别向右和向下增大。</p>
<h3 id="视图坐标">视图坐标</h3>
<p>视图坐标的每一个单位对应一个像素，原点（0,0）总在<strong>QGraphicsView</strong>视口的左上角，而右下角是（宽，高）。所有的鼠标事件和拖放事件最初都是使用视图坐标接收的。</p>
<h3 id="坐标映射">坐标映射</h3>
<p>不仅可以在视图、场景和图形项之间使用坐标映射，还可以在子图形项、父图形项或者图形项、图形项之间进行坐标映射。所有的映射函数都可以映射点、矩形、多边形和路径。例如要获取在视图中的一个椭圆形中包含的图形项，则可以先传递一个<strong>QPainterPath</strong>对象作为参数给<strong>mapToScene</strong>（）函数，然后传递映射后的路径给<strong>QGraphicsScene::items</strong>（）函数。</p>
<p>####图形视图框架的映射函数</p>
<table>
<thead>
<tr>
<th>映射函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>QGraphicsView::mapToScene( )</td>
<td>从视图坐标系统映射到场景坐标系统</td>
</tr>
<tr>
<td>QGraphicsView::mapFromScene( )</td>
<td>从场景坐标系统映射到视图坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapToScene( )</td>
<td>从图形项的坐标系统映射到场景的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapFromScene( )</td>
<td>从场景的坐标系统映射到图形项的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapToParent( )</td>
<td>从本图形项的坐标系统映射到其父图形项的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapFromParent( )</td>
<td>从父图形项的坐标系统映射到本图形项的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapToItem( )</td>
<td>从本图形项的坐标系统映射到另一个图形项的坐标系统</td>
</tr>
<tr>
<td>QGraphicsItem::mapFromItem( )</td>
<td>从另一个图形项的坐标系统映射到本图形项的坐标系统</td>
</tr>
</tbody>
</table>
<h2 id="事件处理与传播">事件处理与传播</h2>
<p>图形视图框架中的事件都是<strong>先由视图进行接收，然后传递给场景，再由场景传递给相应的图形项</strong>。而对于键盘事件，它会传递给获得焦点的图形项，可以使用<strong>QGraphicsScene</strong>类的<strong>setFocusItem</strong>（）函数或者图形项自身调用<strong>setFocus</strong>（）函数来设置焦点图形项。默认的，如果场景没有获得焦点，那么所有的键盘事件都会被丢弃。场景中的图形项获得了焦点，场景也会自动获得焦点。</p>
<h2 id="示例">示例</h2>
<h3 id="myitem">MyItem</h3>
<ul>
<li>MyItem.h</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#pragma once

#include &lt;QGraphicsItem&gt;

class MyTime : public QGraphicsItem
&#123;

public:
	MyTime();
	~MyTime();
	QRectF boundingRect() const override;
	void paint(QPainter* painter,
		const QStyleOptionGraphicsItem* option,
		QWidget* widget) override;
	void setColor(const QColor&amp; color);

private:
	QColor brushColor;

protected:
	void KeyPressEvent(QKeyEvent* event);
	void mousePressEvent(QGraphicsSceneMouseEvent* event);
	void hoverEnterEvent(QGraphicsSceneHoverEvent* event);
	void contextMenuEvent(QGraphicsSceneContextMenuEvent* event);
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>MyItem.cpp</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;MyTime.h&quot;

#include &lt;QPainter&gt;
#include &lt;QCursor&gt;
#include &lt;QKeyEvent&gt;
#include &lt;QGraphicsSceneHoverEvent&gt;
#include &lt;QGraphicsSceneContextMenuEvent&gt;
#include &lt;QMenu&gt;

MyTime::MyTime()
&#123;
	brushColor &#x3D; Qt::red;

	setFlag(QGraphicsItem::ItemIsFocusable);
	setFlag(QGraphicsItem::ItemIsMovable);

	setAcceptHoverEvents(true);
&#125;

MyTime::~MyTime()
&#123;
&#125;

QRectF MyTime::boundingRect() const
&#123;
	qreal adjust &#x3D; 0.5;
	return QRectF(
		-10 - adjust,
		-10 - adjust,
		20 + adjust,
		20 + adjust
	);
&#125;

void MyTime::paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget)
&#123;
	if (hasFocus())
	&#123;
		painter-&gt;setPen(QPen(QColor(255, 255, 255, 200)));
	&#125;
	else
	&#123;
		painter-&gt;setPen(QPen(QColor(100, 100, 100, 100)));
	&#125;
	painter-&gt;setBrush(brushColor);
	painter-&gt;drawRect(-10, -10, 20, 20);
&#125;

void MyTime::setColor(const QColor&amp; color)
&#123;
	brushColor &#x3D; color;
&#125;

void MyTime::KeyPressEvent(QKeyEvent* event)
&#123;
	if (event-&gt;key() &#x3D;&#x3D; Qt::Key_Down)
	&#123;
		moveBy(0, 10);
	&#125;
&#125;

void MyTime::mousePressEvent(QGraphicsSceneMouseEvent* event)
&#123;
	setFocus();
	setCursor(Qt::ClosedHandCursor);
&#125;

void MyTime::hoverEnterEvent(QGraphicsSceneHoverEvent* event)
&#123;
	setCursor(Qt::OpenHandCursor);
	setToolTip(&quot;I am a item&quot;);
&#125;

void MyTime::contextMenuEvent(QGraphicsSceneContextMenuEvent* event)
&#123;
	QMenu menu;
	QAction* moveAction &#x3D; menu.addAction(&quot;move back&quot;);
	QAction* selectedAction &#x3D; menu.exec(event-&gt;screenPos());
	if (selectedAction &#x3D;&#x3D; moveAction)
	&#123;
		setPos(0, 0);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="myview">MyView</h3>
<ul>
<li>MyView.h</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#pragma once

#include &lt;QGraphicsView&gt;

class MyView : public QGraphicsView
&#123;

public:
	MyView();
	~MyView();
protected:
	void keyPressEvent(QKeyEvent* event);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>MyView.cpp</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;MyView.h&quot;
#include &lt;QKeyEvent&gt;

MyView::MyView()
	
&#123;
&#125;

MyView::~MyView()
&#123;
&#125;

void MyView::keyPressEvent(QKeyEvent* event)
&#123;
	switch (event-&gt;key())
	&#123;
	case Qt::Key_Plus:
		scale(1.2, 1.2);
		break;
	case Qt::Key_Minus:
		scale(1 &#x2F; 1.2, 1 &#x2F; 1.2);
		break;
	case Qt::Key_Right:
		rotate(30);
	default:
		break;
	&#125;
	QGraphicsView::keyPressEvent(event);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="main">main</h3>
<ul>
<li>main.cpp</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;QtWidgets&#x2F;QApplication&gt;
#include &lt;QTime&gt;
#include &quot;MyTime.h&quot;
#include &quot;MyView.h&quot;

int main(int argc, char *argv[])
&#123;
    QApplication app(argc, argv);
    qsrand(QTime(0, 0, 0).secsTo(QTime::currentTime()));
    QGraphicsScene scene;
    scene.setSceneRect(-200, -150, 400, 300);

    for (int i &#x3D; 0; i &lt; 5; i++)
    &#123;
        MyTime* item &#x3D; new MyTime();
        item-&gt;setColor(QColor(qrand() % 256, qrand() % 256, qrand() % 256));
        item-&gt;setPos(i * 50 - 90, -50);
        scene.addItem(item);
    &#125;

    MyView view;
    view.setScene(&amp;scene);
    view.setBackgroundBrush(QBrush(Qt::red));
    view.show();
    return app.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Qt具体使用</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>Qt使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim的使用</title>
    <url>/2022/06/25/linux/2022-06-22-Vim%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​	Vim是linux环境下常用的编辑器,这篇文章目的在于帮助我自己记忆Vim的相关语法命令.</p>
<hr>
<p><code>i</code>或<code>Insert</code>进入编辑模式</p>
<p><code>:</code>或<code>/</code>进入命令模式</p>
<p><code>vim [文件名]</code>使用vim进入文件</p>
<p><code>vim [文件名] [文件名] ...</code>使用vim进入多个文件</p>
<p><code>:ls</code>(命令)列出当前打开的所有文件,例如<code>:ls</code></p>
<p><code>:bn</code>(命令)打开第n个文件例如:<code>:b1</code>,<code>:b2</code></p>
<p><code>vim -On [files]</code>打开多个文件并左右分屏</p>
<p><code>vim -on [flies]</code>打开多个文件并上下分屏</p>
<p><code>:sp file</code>打开一个新的文件file,并上下分割当前文件与新打开的文件</p>
<p><code>:vsp file</code>打开一个文件file并与当前文件左右分割</p>
<p><code>Ctrl +  W</code>键为组合功能键,与其他键配合使用.</p>
<ul>
<li><code>s</code>上下分割当前打开的文件</li>
<li><code>v</code>左右分割当前打开的文件</li>
<li><code>h</code>将光标定在左边屏幕</li>
<li><code>l</code>将光标定在右边屏幕</li>
<li><code>H</code>将当前分屏移动到左边</li>
<li><code>L</code>将当前分屏移动到右边</li>
<li><code>j</code>将光标移到下面分屏</li>
<li><code>k</code>将光标移到上面分屏</li>
<li><code>J</code>将当前分屏移到下面</li>
<li><code>K</code>将当前分屏移到上面</li>
<li><code>c</code>关闭当前分屏</li>
<li><code>q</code>关闭当前分屏,如果是最后一个分屏则退出vim</li>
</ul>
<p><code>:w</code>保存文件但不退出</p>
<p><code>:w!</code>强制保存但不退出</p>
<p><code>:w file</code>保存当前文件修改到file中</p>
<p><code>:q!</code>强制退出文件,但不保存</p>
<p><code>:qa!</code>强制退出所有文件,任何修改都不保存</p>
<p><code>:wq</code>退出文件,保存修改</p>
<p><code>:x</code>退出文件保存修改</p>
<p><code>:e</code>打开另一个文件</p>
<p><code>:e!</code>放弃对文件的所以修改,恢复文件到上次保存的位置</p>
<p><code>:saveas file</code>另存为file</p>
<p><code>快捷键ZZ(大写ZZ)</code>保存退出</p>
<hr>
<p><code>I</code>进入插入模式,把光标移至<strong>行首</strong></p>
<p><code>i</code>进入插入模式,在光标所在字符之前插入</p>
<p><code>a</code>在光标后插入</p>
<p><code>A</code>在行尾插入</p>
<p><code>o</code>光标下一行行首插入</p>
<p><code>O</code>光标上一行行首插入</p>
<p><code>s</code>删除光标所在处字符进行插入</p>
<p><code>S</code>删除光标所在行在行首插入</p>
<p><code>cw</code>删除光标处到单词结束的字符并进行插入</p>
<p><code>:set nu</code>显示行号</p>
<p><code>:set nonu</code>取消显示行号</p>
<p><code>:n</code>定位至第n行</p>
<hr>
<p><code>/&#123;目标字符串&#125;</code>查找目标字符串</p>
<p>查找成功后<code>n</code>寻找下一个匹配,<code>N</code>寻找下一个匹配</p>
<p><code>:set ic</code>查找时不区分大小写</p>
<p><code>:set noic</code>查找时区分大小写</p>
<p><code>:n1, n2d</code>删除n1到n2行</p>
<hr>
<p><code>:&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换标志&#125;</code>文本替换</p>
<p>例如:</p>
<ul>
<li><code>:s/test/TEST/g</code>将当前行的test换为TEST</li>
<li><code>:%s/test/TEST/g</code>换全文</li>
<li><code>:n1,n2s/test/TEST/g</code>换n1到n2行</li>
<li>选区,在可视模式下选区后输入<code>:</code>会自动添加<code>:'&lt;,'&gt;</code>,比如<code>:'&lt;,'&gt;s/test/TEST/g</code></li>
</ul>
<p><strong>替换标志</strong></p>
<p><code>g</code>替换所有出现</p>
<p><code>%s</code>替换所有行第一次出现,例如<code>%s/TEST/test</code></p>
<p><code>(空)</code>替换当前光标开始的第一次出现</p>
<p><code>i</code>大小写不敏感</p>
<p><code>I</code>大小写敏感</p>
<p><code>c</code>需要确认</p>
<p><strong>执行linux命令</strong></p>
<p><code>:![command]</code>command即为欲执行的命令,例如:</p>
<ul>
<li><code>:!date</code></li>
</ul>
<p><code>:r ![command]</code>将命令执行结果加至操作文本光标处</p>
<p><strong>定义快捷键</strong></p>
<p><code>:map [key] [value]</code></p>
<hr>
<p><strong>正常模式下</strong></p>
<ol>
<li>
<p>在当前行上移动光标</p>
<ul>
<li><code>0</code>移动至行头</li>
<li><code>^</code>移动到本行第一个不是空白字符的地方</li>
<li><code>$</code>移动至行尾</li>
<li><code>g_</code>移动到本行最后一个不是空白字符的地方</li>
<li><code>w</code>移动到下一个单词开头</li>
<li><code>e</code>移动到下一个单词结尾</li>
<li><code>f[a]</code>移动到下一个为a的字符处,例如<code>fa</code>移动到下一个a,<code>fb</code>移动到下一个b</li>
<li><code>nf[a]</code>移动到第n个字符为a的地方</li>
<li><code>F[a]与nF[a]</code>查找方向与上两个相反</li>
<li><code>t[a]</code>移动至a前一个字符</li>
<li><code>nt[a]</code>移动到第n个</li>
<li><code>;与,</code>;下一个字符,前一个字符</li>
</ul>
</li>
<li>
<p>跨行移动光标</p>
<ul>
<li><code>nG</code>到第n行行首</li>
<li><code>gg</code>到第一行行首</li>
<li><code>G</code>最后一行行首</li>
<li><code>H</code>当前屏幕第一行行首</li>
<li><code>M</code>当前屏幕中间</li>
<li><code>L</code>当前屏幕尾部</li>
<li><code>zt</code>当前屏幕最上方</li>
<li><code>zz</code>当前屏幕中间</li>
<li><code>zb</code>当前屏幕尾部</li>
<li><code>%</code>匹配括号移动</li>
<li><code>*与#</code>匹配光标当前单词,移动光标至下一个或上一个匹配的单词,<code>*</code>为下一个,<code>#</code>为上一个</li>
</ul>
</li>
<li>
<p>翻页操作</p>
<ul>
<li><code>ctrl+f</code>下一页</li>
<li><code>ctrl+b</code>上一页</li>
</ul>
</li>
</ol>
<hr>
<p><strong>复制粘贴删除</strong></p>
<p><code>d</code>删除,<code>y</code>复制,<code>p</code>粘贴</p>
<ol>
<li>
<p>关于<code>d</code>删除,它通常搭配不同字母使用</p>
<ul>
<li><code>dw</code>删除一个单词</li>
<li><code>dnw</code>删除n个单词</li>
<li><code>dfa</code>删除光标到下一个a处的字符</li>
<li><code>dnfa</code>删除光标到第n个a处的字符</li>
<li><code>dd</code>删除一整行</li>
<li><code>ndd</code>删除光标开始的n行</li>
<li><code>d$</code>删除光标至本行结尾</li>
<li><code>dH</code>删除屏幕显示第一行文本到光标所在行</li>
<li><code>dG</code>删除光标所在行到文本的结束</li>
</ul>
</li>
<li>
<p><code>y</code>复制,操作和上面<code>d</code>的基本一样</p>
</li>
<li>
<p><code>p</code>粘贴</p>
<ul>
<li><code>p</code>光标和粘贴</li>
<li><code>P</code>光标前粘贴</li>
</ul>
</li>
</ol>
<hr>
<p><code>u</code>撤销</p>
<p><code>ctrl+u</code>恢复撤销</p>
<hr>
<p><code>x</code>删除光标所在字符</p>
<p><code>r</code>替换光标所在处的字符</p>
<p><code>R</code>替换光标开始后的所有字符</p>
<hr>
<p><code>~</code>将光标处字母带小写改变</p>
<p><code>n~</code>改变n个大小写</p>
<p><code>g~~</code>改变当前行</p>
<p><code>gUU</code>当前行全改成大写</p>
<p><code>guu</code>小写</p>
<p><code>3gUU</code>光标开始三行全改为大写</p>
<p><code>gUw</code>光标处单词改为大写</p>
<p><code>guw</code>小写</p>
<p><code>n[command]</code>执行n次命令</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Mat - The Basic Image Container</title>
    <url>/2022/06/02/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2022-06-02Mat/</url>
    <content><![CDATA[<h2 id="mat">Mat</h2>
<p>使用Mat对象无需再自己手动分配和释放内存</p>
<p>Mat对象由两个数据部分组成：</p>
<ol>
<li>
<p><strong>矩阵头</strong></p>
<p>包含着一些信息，例如矩阵尺寸，用于记录矩阵存储位置的方法等等</p>
</li>
<li>
<p><strong>矩阵指针</strong></p>
<p>包含像素值(根据选择的存储方式决定维度)</p>
</li>
</ol>
<p>其中，矩阵头大小恒定，但矩阵实际尺寸视情况而定。</p>
<p>为了加快程序的运算速度，每一个Mat对象都有自己的头，而一个矩阵有可能通过共享矩阵指针的方式来被两个Mat对象使用。并且，拷贝运算符<strong>只会拷贝矩阵头与矩阵指针，而不会拷贝矩阵本身</strong>。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat A, C;                          &#x2F;&#x2F; creates just the header parts
A &#x3D; imread(argv[1], IMREAD_COLOR); &#x2F;&#x2F; here we&#39;ll know the method used (allocate matrix)
Mat B(A);                                 &#x2F;&#x2F; Use the copy constructor
C &#x3D; A;                                    &#x2F;&#x2F; Assignment operator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面例子中的<strong>所有Mat对象均指向同一矩阵，改变其中一个会影响到其他的</strong>。</p>
<p>可以创建一个只含部分数据的矩阵头，例如，要在图像中创建感兴趣区域 （<em>ROI</em>），只需创建一个具有新边界的新标头:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat D (A, Rect(10, 10, 100, 100) ); &#x2F;&#x2F; using a rectangle
Mat E &#x3D; A(Range::all(), Range(1,3)); &#x2F;&#x2F; using row and column boundaries<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Mat对象使用引用计数来负责内存的释放。</p>
<p>赋值矩阵本身时，可以使用<strong>cv::Mat::clone()<strong>或</strong>cv::Mat::copyTo()</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat F &#x3D; A.clone();
Mat G;
A.copyTo(G);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="存储方法">存储方法</h2>
<p><strong>色彩空间是</strong>指我们如何组合颜色分量以编码给定的颜色。最简单的一个是灰度，我们可以支配的颜色是黑色和白色。这些的组合使我们能够创建许多灰色阴影。</p>
<p>最受欢迎的色彩空间是<strong>RGB</strong>,因为这也是我们眼睛建立颜色感受的方式，其基色为<strong>红，绿，蓝</strong>，有时候为了对颜色透明度进行区分，会加入第四个元素<strong>alpha</strong>。</p>
<p>还有许多其他色彩空间，例如:</p>
<ul>
<li>RGB是最常见的，因为我们的眼睛使用类似的东西，但请记住，OpenCV标准显示系统使用BGR色彩空间组成颜色(而非RGB)</li>
<li>HSV和HLS将颜色分解为它们的<strong>色调</strong>，<strong>饱和度</strong>和<strong>明度/亮度</strong>分量，这是我们描述颜色的更自然的方式。例如，您可能会忽略最后一个分量，从而使算法对输入图像的光照条件不那么敏感。</li>
<li>YCrCb被流行的JPEG图像格式使用。</li>
<li>CIE L<em>a</em>b* 是一个感知上均匀的色彩空间，如果您需要测量给定颜色到另一种颜色的<em>距离</em>，它会派上用场。</li>
</ul>
<p>每个色彩空间都有自己的有效域。这将决定我们使用的数据类型。我们如何存储颜色决定了我们对其有效域的控制。可能的最小数据类型是<strong>char</strong>，这意味着 1 个字节或 8 位。这可能是无符号（因此可以存储从 0 到 255 的值）或有符号（从 -127 到 +127 的值）。尽管在三个分量（如RGB）的情况下，这种宽度已经给出了1600万种可能的颜色来表示，但我们可以通过为每个分量使用浮点数（4字节= 32位）或双精度（8字节= 64位）数据类型来获得更精细的控制。但是，请记住，增加组件的大小也会增加内存中整个画面的大小。</p>
<hr>
<h2 id="显示创建mat对象">显示创建Mat对象</h2>
<p>可以使用**&quot;&lt;&lt;&quot;**来查看矩阵具体的值，但该方式仅适用于二维矩阵。</p>
<ul>
<li>
<p><strong>使用Mat构造函数进行创建</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat m(2, 2, CV_8UC3, Scalar(0, 0, 255));
cout &lt;&lt; &quot;M &#x3D; &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl&lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于二维和多通道图像，我们首先定义它们的大小：行数和列数。</p>
<p>然后，我们需要指定用于存储元素的数据类型以及每个矩阵点的通道数。为此，我们根据以下约定构造了多个定义：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_[每个项目的位数][有符号或无符号][类型前缀]C[通道号]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>例如，<strong>CV_8UC3</strong>意味着我们使用长度为 8 位的无符号 char 类型，每个像素有三个<strong>uchar</strong>来形成三个通道。</p>
</li>
<li>
<p><strong>使用 C/C++数组并通过构造函数进行初始化</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int sz[3] &#x3D; &#123;2, 2, 2&#125;;
Mat L(3, sz, CV_8UC1, Scalar::all(0));  &#x2F;&#x2F; 三维，sz数组决定了每个维度的而大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>
<p><strong>使用cv::Mat::create函数</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat M;
M.create(4, 4, CV_8UC(2));
cout &lt;&lt; M;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>注意</strong>:这个创建方法不能为矩阵设初值，它只是在改变尺寸时重新为矩阵数据开辟内存。</p>
</li>
<li>
<p><strong>使用Matlab风格的初始化函数：cv::Mat::zeros(), cv::Mat::ones(), cv::Mat::eye()</strong></p>
<p>需要提供大小和数据类型来创建矩阵：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat E &#x3D; Mat::eye(4, 4, CV_64F);
cout &lt;&lt; &quot;E &#x3D; &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;
Mat O &#x3D; Mat::ones(2, 2, CV_32F);
cout &lt;&lt; &quot;O &#x3D; &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; O &lt;&lt; endl &lt;&lt; endl;
Mat Z &#x3D; Mat::zeros(3, 3, CV_8UC1);
cout &lt;&lt; &quot;Z &#x3D; &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>对于小型矩阵，可以使用逗号分隔的初始值项或初始值列表：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">   Mat C &#x3D; (Mat_&lt;double&gt;(3, 3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1, 0);
   cout &lt;&lt; &quot;C &#x3D; &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; C &lt;&lt; endl;
   C &#x3D; (Mat_&lt;double&gt;(&#123;0, -1, 0, -1, 5, -1, 0, -1, 0&#125;)).reshape(3);
   cout &lt;&lt; &quot;C &#x3D; &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; C &lt;&lt; endl;
&#x2F;&#x2F; reshape(cn, rows):在不改变数据的情况下，将矩阵更改为
&#x2F;&#x2F; 具有cn个通道，rows行的矩阵<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>为现有Mat对象创建新的头，并对齐使用<strong>cv::Mat::clone</strong>或<strong>cv::Mat::copyTo</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat RowClone &#x3D; C.row(1).clone();
   cout &lt;&lt; &quot;RowClone &#x3D; &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; RowClone &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>
<p><strong>注意</strong>：可以使用**cv::randu()**来随机填充一个矩阵，在使用时需要为随机值提供一个上下限</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat R &#x3D; Mat(3, 2, CV_8UC3);
randu(R, Scalar::all(0), Scalar::all(255));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<hr>
<h2 id="格式化输出">格式化输出</h2>
<p>有不同的格式，这里不再展示，可以使用的有</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; M为需要输出的矩阵
cout &lt;&lt; R;								 &#x2F;&#x2F; 默认
cout &lt;&lt; format(R, Formatter::FMT_PYTHON); 	&#x2F;&#x2F; python
cout &lt;&lt; format(R, Formatter::FMT_CSV);	    &#x2F;&#x2F; Comma separated values (CSV)
cout &lt;&lt; format(R, Formatter::FMT_NUMPY);	&#x2F;&#x2F; numpy
cout &lt;&lt; format(R, Formatter::FMT_C);        &#x2F;&#x2F; C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="其他常用输出">其他常用输出</h2>
<p>OpenCV也通过&lt;&lt;运算符支持其他常见OpenCV数据结构的输出：</p>
<ul>
<li>
<p>2D Point</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Point2f P(5, 1);
cout &lt;&lt; &quot;Point(2d) &#x3D; &quot; &lt;&lt; P &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>
<p>3D Point</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Point3f P3F(2, 6, 7);
cout &lt;&lt; &quot;Point(3d) &#x3D; &quot; &lt;&lt; P3F &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>
<p>通过cv::Mat输出std::vector</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;float&gt; v;
v.push_back((float)CV_PI);
v.push_back(2);
cout &lt;&lt; &quot;Vector of floats via Mat &#x3D; &quot; &lt;&lt; Mat(v) &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>由points组成的std::vector</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;Point2f&gt; vPoints(20);
int j &#x3D; 0;
for (auto i &#x3D; vPoints.begin(); i !&#x3D; vPoints.end(); ++i)
&#123;
    *i &#x3D; Point2f((float)(j * 5), float(j % 7));
    j++;
&#125;
cout &lt;&lt; &quot;A vector of 2D Points &#x3D; &quot; &lt;&lt; vPoints &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图像处理</tag>
        <tag>OpenCV</tag>
        <tag>Core Module</tag>
      </tags>
  </entry>
  <entry>
    <title>How to scan images, lookup tables and time measurement with OpenCV</title>
    <url>/2022/06/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2022-06-25-Scan%20Image/</url>
    <content><![CDATA[<p><strong>此为OpenCV官方教程的个人翻译</strong></p>
<h2 id="目标">目标</h2>
<p>这篇文章将为您讲解:</p>
<ul>
<li>如何遍历图像的每一个像素?</li>
<li>OpenCV中的矩阵如何存储?</li>
<li>如何衡量我们使用算法的性能?</li>
<li>什么是查找表?为什么我们要使用它?</li>
</ul>
<h2 id="测试用例">测试用例</h2>
<p>​	考虑一个简单的减色方法,使用C和C++里的<code>unsigned char</code>类型来作为矩阵的数据类型.因此该矩阵中,每一像素通道都可能含有多达256种不同的数值.对于一个三通道图像,这会造成非常非常多组合(大概1600万).直接操作这些色彩可能会对我们算法的性能造成极大影响.然而,有时可能操作更少数量的色彩,却达到相同的结果.</p>
<p>​	在这种情况下，我们通常会进行<em>色彩空间缩减</em>。这意味着我们将颜色空间当前值与新的输入值进行划分，最终得到更少的颜色。例如，介于 0 和 9 之间的每个值都采用新值 0，10 到 19 之间的每个值都取值 10，依此类推。</p>
<p>​	当您将 <em>uchar</em>（无符号 char - 即值介于 0 和 255 之间）值与 <em>int</em> 值相除时，结果也将是 <em>char</em>。这些值只能是字符值。因此，任何分数都将向下舍入。利用这一事实，<em>uchar</em>域中的上部运算可以表示为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mfrac><msub><mi>I</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mn>10</mn></mfrac><mo>∗</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">I_{new}=\frac{I_{old}}{10}*10
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></span></p>
<p>​	一个简单的色彩空间减少算法将仅传递图像矩阵的每个像素并应用此公式。值得注意的是，我们做了一个除法和乘法运算。对于系统来shu说，这些操作开销非常大。如果可能的话，值得通过使用开销更低的操作来避免它们，例如一些减法，加法在最好情况下就是简单赋值。此外，请注意，对于上述运算，我们只有有限数量的输入值。在使用<em>uchar</em>的情况下，该值为256.</p>
<p>​	因此，对于较大的图像，明智的做法是事先计算所有可能的值，并且在分配期间只需使用查找表进行分配即可。查找表是简单的数组（具有一个或多个维度），对于给定的输入值变体，它保存最终的输出值。它的优势在于我们不需要进行计算，我们只需要读取结果即可。</p>
<p>​	我们的测试用例程序（以及此处提供的示例）将执行以下操作：读取控制台行参数所提供的图像，并使用给定的控制台行参数整数值应用缩减。在OpenCV中，目前它们是逐个像素地浏览图像的三种主要方式。为了使事情变得更有趣，将使用所有这些方法扫描每个图像，并打印出花费的时间。</p>
<p>​	最后一个参数是可选的。给定图像将以灰度格式加载，否则使用BGR颜色方式。第一件事是计算查找表。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string input;
cin &gt;&gt; input;
stringstream s;
s &lt;&lt; input;
int divideWith;
s &gt;&gt; divideWith;
if (!s || !divideWith) &#123;
    cout &lt;&lt; &quot;Invalid number entered for dividing&quot; &lt;&lt; endl;
    return -1;
&#125;
uchar table[256];
for (int i &#x3D; 0; i &lt; 256; i++) &#123;
    table[i] &#x3D; (uchar)(divideWith * (i &#x2F; divideWith));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​	在这里，我们首先使用 C++ <em>stringstream</em> 类将输入字符串从文本转换为整数格式。然后，我们使用简单的外观和上面的公式来计算查找表。这里没有OpenCV特定的东西。</p>
<p>​	另一个问题是我们如何测量时间？OpenCV提供了两个简单的函数来实现这个**getTickCount（）<strong>和</strong>getTickFrequency（）**第一个返回来自特定事件（例如，自您启动系统以来）的系统 CPU tick 。第二个返回 CPU 在一秒内发出tick的次数。因此，以秒为单位测量两次操作之间经过的时间数很容易.</p>
 <pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">   double t &#x3D; (double)getTickCount();
&#x2F;&#x2F; do somthing
   t &#x3D; ((double)getTickCount() - t) &#x2F; getTickFrequency();
   cout &lt;&lt; &quot;Times passed in seconds: &quot; &lt;&lt; t &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="图像矩阵如何保存在内存中">图像矩阵如何保存在内存中?</h2>
<p>​	矩阵的大小取决于所使用的颜色系统。更准确地说，这取决于所使用的通道数量。对于灰度图像，我们有如下内容：</p>
<p><img src="https://s2.loli.net/2022/06/26/gDXkM5xtEz6q3Bb.png" alt="1.png"></p>
<p>​	对于多通道图像，列包含的子列数与通道数一样多。例如，在BGR颜色系统的情况下：</p>
<p><img src="https://s2.loli.net/2022/06/26/ZJgoKe5Q12B4tYl.png" alt="2.png"></p>
<p>​	因为在许多情况下，内存足够大，可以连续地存储行，因此行可能会一个接一个存储，从而创建一个长行。由于所有内容都是连续的，因此可以一个接一个地计算，这可能有助于加快扫描过程。我们可以使用 **isContinuous（）**函数来<em>确认</em>矩阵是否属于这种情况。</p>
<h2 id="更高效的方式">更高效的方式</h2>
<p>​	在性能方面，最快的便是经典的C样式运算符[]（指针）访问。因此，我们可以推荐的最高效的进行分配的方法是：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat&amp; ScanImageReduceC(Mat&amp; I, uchar* table) &#123;
    &#x2F;&#x2F; accept only char type matrIces
    CV_Assert(I.depth() &#x3D;&#x3D; CV_8U);

    int channels &#x3D; I.channels();

    int nRows &#x3D; I.rows;
    int nCols &#x3D; I.cols;

    if (I.isContinuous()) &#123;
        nCols &#x3D; nRows * nCols * channels;
        nRows &#x3D; 1;
    &#125;
    int i, j;
    uchar* p;
    for (i &#x3D; 0; i &lt; nRows; ++i) &#123;
        p &#x3D; I.ptr&lt;uchar&gt;(i);
        for (j &#x3D; 0; j &lt; nCols; ++j) &#123;
            p[j] &#x3D; table[p[j]];
        &#125;
    &#125;
    return I;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​	在这里，我们基本上只是获取一个指向每行开头的指针，并遍历它直到结束。在矩阵以连续方式存储的特殊情况下，我们只需要请求指针一次，然后一直走到最后。我们需要注意彩色图像：我们有三个通道，因此我们需要在每行中传递三倍以上的项。</p>
<p>​	还有另一种方式。<em>Mat</em> 对象成员变量<em>data</em>返回指向第一行（第一列）的指针。如果此指针为 null，则该对象中没有有效的输入。这是检查图像加载是否成功的最简单方法。如果存储连续，我们可以使用它来遍历整个数据指针。如果是输入灰度图像，则可以按下面的进行操作：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">uchar* p &#x3D; I.data;

for( unsigned int i &#x3D;0; i &lt; ncol*nrows; ++i)
    *p++ &#x3D; table[*p];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​	你会得到同样的结果。但是，此代码以后更难阅读。如果你有一些更先进的技术，那就更难了。此外，在实践中，这会获得相同的性能结果（因为大多数现代编译器可能会自动为您进行这个小的优化）。</p>
<h2 id="迭代器方式-安全方式">迭代器方式(安全方式)</h2>
<p>​	如果您以指针以及[]方式进行遍历,那么正确处理可能出现的内存间隙就是您的责任.迭代器方法被认为是一种更安全的方式，因为它从用户那里接管这些任务。您需要做的就是询问图像矩阵的开始和结束，然后只需增加开始迭代器，直到到达终点。要获取迭代器<em>指向</em>的值，请使用 * 运算符。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat&amp; ScanImageAndReduceIterator(Mat&amp; I, uchar* table) &#123;
    CV_Assert(I.depth() &#x3D;&#x3D; CV_8U);
    const int channels &#x3D; I.channels();
    switch (channels) &#123;
        case 1: &#123;
            MatIterator_&lt;uchar&gt; it, end;
            for (it &#x3D; I.begin&lt;uchar&gt;(), end &#x3D; I.end&lt;uchar&gt;(); it !&#x3D; end; ++it) &#123;
                *it &#x3D; table[*it];
            &#125;
            break;
        &#125;
        case 3: &#123;
            MatIterator_&lt;Vec3b&gt; it, end;
            for (it &#x3D; I.begin&lt;Vec3b&gt;(), end &#x3D; I.end&lt;Vec3b&gt;(); it !&#x3D; end; ++it) &#123;
                (*it)[0] &#x3D; table[(*it)[0]];
                (*it)[1] &#x3D; table[(*it)[1]];
                (*it)[2] &#x3D; table[(*it)[2]];
            &#125;
        &#125;
        default:
            break;
    &#125;
    return I;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​	对于彩色图像，每列有三个uchar子列。这可以被认为是uchar项目的简短向量，在OpenCV中以<em>Vec3b</em>命名。要访问第 n 个子列，我们使用简单的运算符 [] 访问。请务必记住，OpenCV 迭代器会遍历各列并自动跳到下一行。因此，对于彩色图像，如果您使用简单的<em>uchar</em>迭代器，您将只能访问蓝色通道值。</p>
<h2 id="使用引用进行动态地址计算">使用引用进行动态地址计算</h2>
<p>​	不建议使用此方法进行遍历。它是为了获取或修改图像中的随机元素而制作的。其基本用法是<strong>指定要访问的项目的行号和列号</strong>。在我们早期的遍历方法中，您已经可以通过我们查看图像的类型来观察到这一点很重要。此外,您需要手动指定在自动查找时使用的类型。对于以下源代码的灰度图像（一并演示了**at（）**函数的用法），您可以观察到这一点：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat&amp; ScanImageAndReduceRandomAccess(Mat&amp; I, uchar* table)
&#123;
    CV_Assert(I.depth() &#x3D;&#x3D; CV_8U);

    const int channels &#x3D; I.channels();
    switch (channels)
    &#123;
    case 1: &#123;
        for (int i &#x3D; 0; i &lt; I.rows; ++i)
        &#123;
            for (int j &#x3D; 0; j &lt; I.cols; j++)
            &#123;
                I.at&lt;uchar&gt;(i, j) &#x3D; table[I.at&lt;uchar&gt;(i, j)];
            &#125;
        &#125;
        break;
    &#125;
    case 3: &#123;
        Mat_&lt;Vec3b&gt; _I &#x3D; I;
        for (int i &#x3D; 0; i &lt; I.rows; i++)
        &#123;
            for (int j &#x3D; 0; j &lt; I.cols; j++) &#123;
                _I(i, j)[0] &#x3D; table[_I(i, j)[0]];
                _I(i, j)[1] &#x3D; table[_I(i, j)[1]];
                _I(i, j)[2] &#x3D; table[_I(i, j)[2]];
            &#125;
        &#125;
        I &#x3D; _I;
        break;
    &#125;
    default:
        break;
    &#125;
    return I;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​	这些函数采用您指定输入类型和坐标，并动态计算查询项的地址。然后返回对此的引用。当您<em>获取</em>值时，这可能是一个常量，当您<em>设置</em>值时，这可能是一个非常量。在debug模式下，会有以安全检查措施:将对输入坐标是否有效且存在进行检查。如果不存在或者无效，您将在标准错误输出流上收到一个很好的输出消息。与release模式下的C风格[]方式相比，使用此方法的唯一区别是，对于图像的每个元素，您将获得一个新的行指针，用于我们使用C运算符[]来获取列元素的内容。</p>
<p>​	如果需要使用此方法对图像进行多次查找，则为每个访问输入类型和 at 关键字可能会很麻烦且耗时。为了解决这个问题，OpenCV具有<strong>Mat_<strong>数据类型。它与Mat相同，在定义时，您需要通过查看数据矩阵的内容来指定数据类型，但是作为回报，您可以使用operator（）来快速访问项目。]同时，OpenCV也提供了很方便</strong>Mat</strong>与**Mat_<strong>的转化方式(如上示例)。尽管如此，重要的是要注意，相同的操作（具有相同的运行时速度）可以使用</strong>at()**函数完成。</p>
<h2 id="主要函数">主要函数</h2>
<p>​	这是在图像中实现查找表修改的额外方法。因为在图像处理中，将所有给定的图像值替换为其他值是很常见的，故OpenCV提供了一个函数，该函数无需您自己编写遍历方法便可以进行转变。我们使用核心模块的<a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#lut">LUT（）</a>功能。首先，我们构建查找表的 Mat 类型：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat lookUpTable(1, 256, CV_8U);
uchar* p &#x3D; lookUpTable.data;
for (int i &#x3D; 0; i &lt; 256; i++)
&#123;
    p[i] &#x3D; table[i];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后调用函数（I 是我们的输入图像，J 是输出图像）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">LUT(I, lookUpTable, I);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="上述方法的性能差异">上述方法的性能差异</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>迭 代</td>
<td>83.7201 毫秒</td>
</tr>
<tr>
<td>实时 RA</td>
<td>93.7878 毫秒</td>
</tr>
<tr>
<td>LUT 函数</td>
<td>32.5759 毫秒</td>
</tr>
<tr>
<td>C风格[]</td>
<td>79.4717 毫秒</td>
</tr>
</tbody>
</table>
<p>​	如果可能的话，使用OpenCV已经提供的函数（而不是重新造轮子）。最快的方法是LUT函数。这是因为 OpenCV 库是通过英特尔线程构建模块启用多线程的。但是，如果您需要编写简单的图像扫描，则首选指针方法。迭代器是一个更安全的方法，但速度相当慢。在调试模式下，使用动态引用访问方法进行全图像扫描是最慢的的。在发布模式下，它可能会快于迭代器方法，但肯定会为此牺牲迭代器的安全特性。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图像处理</tag>
        <tag>OpenCV</tag>
        <tag>Core Module</tag>
      </tags>
  </entry>
  <entry>
    <title>Mask operations on matrices</title>
    <url>/2022/06/26/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2022-06-26-Mask%20Mat/</url>
    <content><![CDATA[<p><strong>此为OpenCV官方教程的个人翻译</strong></p>
<h2 id="矩阵上的掩膜操作">矩阵上的掩膜操作</h2>
<p>​	矩阵上的掩码操作非常简单。基本做法是，我们根据掩膜矩阵（也称为内核）重新计算图像中的每个像素值。此内核包含的值将调整相邻像素（和当前像素）对新像素值的影响程度。从数学的角度来看，我们用我们指定的值进行了一个加权平均值计算。</p>
<h2 id="测试用例">测试用例</h2>
<p>​	让我们考虑一下如何增强图像对比度。基本上，我们会对图像的每个像素应用以下公式：</p>
<p><img src="https://s2.loli.net/2022/06/26/8H5k7SRCzQ1qExG.png" alt="1.png"></p>
<p>​	第一种表示法是使用公式，而第二种表示法是使用掩码的第一种表示法的压缩版本。使用掩码核时，请将掩码矩阵的中心放在要计算的像素上，并将像素值与相应位置的矩阵值相乘。在大型矩阵的情况下，后一种表示法更容易查看。</p>
<p>​	现在让我们看看如何使用基本的像素访问方法或使用<a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#filter2d">filter2D</a>函数来实现这一点。</p>
<h2 id="基本方法">基本方法</h2>
<p>​	以下函数可以执行掩膜操作:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Sharpen(const Mat&amp; myImage, Mat&amp; result) &#123;
    CV_Assert(myImage.depth() &#x3D;&#x3D; CV_8U);

    result.create(myImage.size(), myImage.type());
    const int nChannels &#x3D; myImage.channels();

    for (int j &#x3D; 1; j &lt; myImage.rows - 1; ++j) &#123;
        const uchar* previous &#x3D; myImage.ptr&lt;uchar&gt;(j - 1);
        const uchar* current &#x3D; myImage.ptr&lt;uchar&gt;(j);
        const uchar* next &#x3D; myImage.ptr&lt;uchar&gt;(j + 1);

        uchar* output &#x3D; result.ptr&lt;uchar&gt;(j);
        for (int i &#x3D; nChannels; i &lt; nChannels * (myImage.cols - 1); ++i) &#123;
            *output++ &#x3D; saturate_cast&lt;uchar&gt;(
                5 * current[i] - current[i - nChannels] -
                current[i + nChannels] - previous[i] - next[i]);
        &#125;
    &#125;

    result.row(0).setTo(Scalar(0));
    result.row(result.rows - 1).setTo(Scalar(0));
    result.col(0).setTo(Scalar(0));
    result.col(result.cols - 1).setTo(Scalar(0));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​	首先，我们确保输入图像数据采用<code>uchar</code>格式。为此，我们使用<a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#cv-assert">CV_Assert</a>函数，当其中的表达式为 false 时，该函数会引发错误。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_Assert(myImage.depth() &#x3D;&#x3D; CV_8U);  &#x2F;&#x2F; accept only uchar images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​	我们创建与输入具有相同大小和类型类型的输出图像。正如您在<a href="../how_to_scan_images/how_to_scan_images.html#how-image-stored-memory">“图像矩阵如何存储在内存中？”</a>部分中看到的那样，根据通道的数量，我们可能具有一个或多个子列。我们将通过指针循环访问它们.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Result.create(myImage.size(), myImage.type());
const int nChannels &#x3D; myImage.channels();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​	我们将使用普通的 C [] 运算符来访问像素。由于我们需要同时访问多行，因此我们将获取每个行的指针（上一行、当前行和下一行）。我们需要另一个指针，指向要保存计算结果的位置。然后，只需使用 [] 运算符访问正确的项目即可。为了将输出指针向前移动，我们只需在每次操作后增加此值（使用一个字节）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for(int j &#x3D; 1; j &lt; myImage.rows - 1; ++j)
&#123;
    const uchar* previous &#x3D; myImage.ptr&lt;uchar&gt;(j - 1);
    const uchar* current  &#x3D; myImage.ptr&lt;uchar&gt;(j    );
    const uchar* next     &#x3D; myImage.ptr&lt;uchar&gt;(j + 1);

    uchar* output &#x3D; Result.ptr&lt;uchar&gt;(j);

    for(int i &#x3D; nChannels; i &lt; nChannels * (myImage.cols - 1); ++i)
    &#123;
        *output++ &#x3D; saturate_cast&lt;uchar&gt;(5 * current[i]
                     -current[i - nChannels] - current[i + nChannels] - previous[i] - next[i]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​	在图像的边界上，上一行不存在像素。因此,在这些点上，我们的公式是未定义的。一个简单的解决方案是不在这些点上应用掩码核，例如，将边界上的像素设置为零：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Result.row(0).setTo(Scalar(0));               &#x2F;&#x2F; The top row
Result.row(Result.rows - 1).setTo(Scalar(0)); &#x2F;&#x2F; The bottom row
Result.col(0).setTo(Scalar(0));               &#x2F;&#x2F; The left column
Result.col(Result.cols - 1).setTo(Scalar(0)); &#x2F;&#x2F; The right column<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="filter2d-函数">filter2D 函数</h2>
<p>​	应用这样的滤镜在图像处理中非常普遍，因此OpenCV提供一个函数来应用掩码（在某些地方也称为内核）。为此，您首先需要定义一个保存掩码核的 <em>Mat</em> 对象：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat kern &#x3D; (Mat_&lt;char&gt;(3,3) &lt;&lt;  0, -1,  0,
                               -1,  5, -1,
                                0, -1,  0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​	然后调用 <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#filter2d">filter2D</a> 函数，指定要使用的输入、输出图像和内核：</p>
<pre class="line-numbers language-none"><code class="language-none">filter2D(I, K, I.depth(), kern);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​	该函数甚至有第五个可选参数来指定内核的中心，以及第六个用于确定在操作未定义的区域（边界）中要执行的操作的参数。使用此函数的优点是它更短，更不冗长，并且由于实现了一些优化技术，因此它通常比<em>手动编码的方法</em>更快。例如，在我的测试中，第二个只花了13毫秒，第一个花了大约31毫秒。有很大的不同。</p>
<p>​	例如：</p>
<p><img src="https://s2.loli.net/2022/06/26/U6TKPXgfdzFny9V.png" alt="2.png"></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图像处理</tag>
        <tag>OpenCV</tag>
        <tag>Core Module</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链表</title>
    <url>/2022/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-02-11-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>虽然我不知道静态链表什么时候用，但学了总有好处</p>
<h3 id="前言：">前言：</h3>
<p>1.老师仅仅布置了静态链表的初始化、插入和删除操作，因此我只做这几个。</p>
<p>2.本文使用cpp完成。</p>
<h3 id="思路：">思路：</h3>
<p>Component中有两个元素，一个是DataType,这里我使用了string,用来表示存储的元素，另一个是cursor，它的作用与链表节点中的指针一样，用来指出下一个元素的位置</p>
<p>不同的是，cursor指出的不再是地址，而是下一个元素在数组中的下标。</p>
<p>由此可以看出，<strong>静态链表本质还是链表，我们仍需用出来链表的方式处理静态链表，不能被数组所迷惑。</strong></p>
<p>下面开始实现。</p>
<h3 id="实现：">实现：</h3>
<p>静态链表，归根结底还是链表，因此首先我们要定义节点。</p>
<pre class="line-numbers language-none"><code class="language-none">#define MAXSIZE 1000     &#x2F;&#x2F;数组最大长度

struct Component
&#123;
    string data &#x3D;  &quot;&quot; ;         &#x2F;&#x2F;数据
    int cursor &#x3D; 0;            &#x2F;&#x2F;游标
&#125;;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在main函数中，我们定义静态链表</p>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    Component StaticLinkedList[MAXSIZE];      &#x2F;&#x2F;静态链表
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们需要进行初始化</p>
<pre class="line-numbers language-none"><code class="language-none">void initLinkedList(Component* list)
&#123;
    int cnt &#x3D; 1;
    for ( int i &#x3D; 0; i &lt; MAXSIZE - 1; i++)
    &#123;
        list[i].cursor &#x3D; i++;                  &#x2F;&#x2F;初始化时每个节点的cursor指出
    &#125;                                                     &#x2F;&#x2F;下一个节点的位置，而最后一个
    list[MAXSIZE - 1].cursor &#x3D; 0;            &#x2F;&#x2F;节点的cursor为0，指向头节点
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论插入还是删除，我们都需要找到元素。</p>
<pre class="line-numbers language-none"><code class="language-none">Component&amp; find(string input, Component* list)
&#123; &#x2F;&#x2F;返回component的引用，这样可以修改数组中的元素，而无需使用指针
    int curEle &#x3D; list[0].cursor;
    while (list[curEle].cursor !&#x3D; 0 &amp;&amp; list[curEle].data !&#x3D;  &quot;&quot; )　　　　 &#x2F;&#x2F;初始化时每个元素都为空，因此以此为条件
    &#123;
        if (list[curEle].data &#x3D;&#x3D; input)
        &#123;
            return list[curEle];
        &#125;
        else
        &#123;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
    return list[curEle];　　 &#x2F;&#x2F;当找不到时返回的元素
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
<p>当我们插入元素时，我们需要将最后一个非空元素后面的那一个元素使用，将数据保存在那个元素里。</p>
<p><img src="https://s2.loli.net/2022/05/25/DzMxsWebVGNQjS2.png" alt="当前长度" title="当前长度"></p>
<p>这里是将元素出入指定元素之后</p>
<pre class="line-numbers language-none"><code class="language-none">void insertAfter(string input, string query, Component* list)
&#123; &#x2F;&#x2F;与链表插入几乎一样的手法，无需多言
    currenLength++;
    Component&amp; target &#x3D; find(query, list);
    list[currenLength].data &#x3D; input;
    list[currenLength].cursor &#x3D; target.cursor;
    target.cursor &#x3D; currenLength;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>删除元素</p>
<pre class="line-numbers language-none"><code class="language-none">void deleteElement(string query, Component* list)
&#123;
    if (query &#x3D;&#x3D;  &quot;&quot; )
    &#123;
        cout &lt;&lt;  &quot;you didn&#39;t input anything.&quot; ;
        return ;
    &#125;
    Component&amp; target &#x3D; find(query, list);
    if (target.data !&#x3D; query)
    &#123;
        cout &lt;&lt;  &quot;the element you input does not exist in the list.&quot; ;
        return ;
    &#125;
    int curEle &#x3D; 0;
    int pre;
    while (1)　　 &#x2F;&#x2F;需要寻找指定元素之前的元素
    &#123;
        if (list[curEle].data &#x3D;&#x3D; query)
        &#123;
            list[pre].cursor &#x3D; list[curEle].cursor;
            list[curEle].cursor &#x3D; -1;
            list[curEle].data &#x3D;  &quot;&quot; ;
            break ;
        &#125;
        else
        &#123;
            pre &#x3D; curEle;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>完整代码：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include 
#include 
using namespace std;
#define MAXSIZE 1000
struct Component
&#123;
    string data &#x3D;  &quot;&quot; ;
    int cursor &#x3D; 0;
&#125;;

static int currenLength &#x3D; 0;

Component&amp; find(string input, Component* list)
&#123;
    int curEle &#x3D; list[0].cursor;
    while (list[curEle].cursor !&#x3D; 0 &amp;&amp; list[curEle].data !&#x3D;  &quot;&quot; )
    &#123;
        if (list[curEle].data &#x3D;&#x3D; input)
        &#123;
            return list[curEle];
        &#125;
        else
        &#123;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
    return list[curEle];
&#125;

void insertAfter(string input, string query, Component* list)
&#123;
    currenLength++;
    Component&amp; target &#x3D; find(query, list);
    list[currenLength].data &#x3D; input;
    list[currenLength].cursor &#x3D; target.cursor;
    target.cursor &#x3D; currenLength;
&#125;

void deleteElement(string query, Component* list)
&#123;
    if (query &#x3D;&#x3D;  &quot;&quot; )
    &#123;
        cout &lt;&lt;  &quot;you didn&#39;t input anything.&quot; ;
        return ;
    &#125;
    Component&amp; target &#x3D; find(query, list);
    if (target.data !&#x3D; query)
    &#123;
        cout &lt;&lt;  &quot;the element you input does not exist in the list.&quot; ;
        return ;
    &#125;
    int curEle &#x3D; 0;
    int pre;
    while (1)
    &#123;
        if (list[curEle].data &#x3D;&#x3D; query)
        &#123;
            list[pre].cursor &#x3D; list[curEle].cursor;
            list[curEle].cursor &#x3D; -1;
            list[curEle].data &#x3D;  &quot;&quot; ;
            break ;
        &#125;
        else
        &#123;
            pre &#x3D; curEle;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
&#125;

void initLinkedList(Component* list)
&#123;
    int cnt &#x3D; 1;
    for ( int i &#x3D; 0; i &lt; MAXSIZE - 1; i++)
    &#123;
        list[i].cursor &#x3D; i++;
    &#125;
    list[MAXSIZE - 1].cursor &#x3D; 0;
&#125;
int main()
&#123;
   
    Component StaticLinkedList[MAXSIZE];
    initLinkedList(StaticLinkedList);
    string input, query, deleteMent;
    while (1) &#123;
        cin &gt;&gt; input &gt;&gt; query &gt;&gt; deleteMent;
        insertAfter(input, query, StaticLinkedList);
        deleteElement(deleteMent, StaticLinkedList);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
<h3 id="结语：">结语：</h3>
<p>这就是静态链表这几个操作了，我经过VS调试后并未出现异常</p>
<p>如有看不懂，或错误的地方，欢迎讨论。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>双链表</title>
    <url>/2022/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-02-14-%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>相比单链表，双链表提供了prev指针，使得其在处理一些操作时更为简单。</p>
<h2 id="前言：">前言：</h2>
<p>1.这里的双链表使用C++实现</p>
<p>2.只完成了插入删除操作</p>
<h2 id="思路：">思路：</h2>
<p><img src="https://s2.loli.net/2022/05/25/3LFDGZJONKn98y4.png" alt=""></p>
<p>如上图所示，next指向下一个，而prev指向前一个，只要适当调整指针指向，即可完成双链表</p>
<h2 id="实现：">实现：</h2>
<p>首先，需要定义表示节点的结构体:</p>
<pre class="line-numbers language-none"><code class="language-none">struct node
&#123;
	string data;
	node* next;		&#x2F;&#x2F;指向下一个元素
	node* prev;		&#x2F;&#x2F;指向前一个元素
	node()                　&#x2F;&#x2F;构造函数，用于在创建新节点时自动初始化    
	&#123;
		data &#x3D; &quot;&quot;;
		prev &#x3D; NULL;
		next &#x3D; NULL;
	&#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我为了在字面上区分节点和链表的区别，使用了</p>
<p><img src="https://s2.loli.net/2022/05/25/5OE78YwUT1kyhrp.png" alt=""></p>
<p>接下来创建链表，实际上是创造了一个节点，将其作为头结点。</p>
<pre class="line-numbers language-none"><code class="language-none">doubleLinkedList* createList()
&#123;
	node* list &#x3D; new node();　　&#x2F;&#x2F;这种方式返回不会存在局部变量内存销毁的问题，因为它是new出来的
	return list;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>插入操作</p>
<pre class="line-numbers language-none"><code class="language-none">void insert(node* position, string input)
&#123;&#x2F;&#x2F;position是插入的位置，input是插入数据的data
	node* newNode &#x3D; new node();
	&lt;strong&gt;newNode-&gt;data &#x3D; input;				&#x2F;&#x2F;先处理新创造的节点
	newNode-&gt;next &#x3D; position-&gt;next;		　　　　 &#x2F;&#x2F;如果不对新节点优先处理，会造成找不到节点的清空，造成野指针
	newNode-&gt;prev &#x3D; position;
	if (position-&gt;next !&#x3D; NULL) &#123;　　　　　　　　　　　　&#x2F;&#x2F;如果不进行判断，可能会对NULL操作而错误
		position-&gt;next-&gt;prev &#x3D; newNode;
		position-&gt;next &#x3D; newNode;
	&#125;
	else &#123;
		position-&gt;next &#x3D; newNode;
	&#125;&lt;&#x2F;strong&gt;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
<pre class="line-numbers language-none"><code class="language-none">void deleteElement(node* ele)
&#123;
	ele-&gt;prev-&gt;next &#x3D; ele-&gt;next;
	if (ele-&gt;next !&#x3D; NULL)
	&#123;
		ele-&gt;next-&gt;prev &#x3D; ele-&gt;prev;
	&#125;
	else
	&#123;&#x2F;&#x2F;ele-&gt;next为空时不需要做什么了
	&#125;
	delete ele;　　　　&#x2F;&#x2F;必须删除，否则长时间可能造成内存泄漏
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
<p>查找操作</p>
<pre class="line-numbers language-none"><code class="language-none">node* find(string input, doubleLinkedList* list)
&#123;&#x2F;&#x2F;与单链表差不多
	doubleLinkedList* L &#x3D; list;
	while (L !&#x3D; NULL)
	&#123;
		if (L-&gt;data &#x3D;&#x3D; input)
		&#123;
			return L;
		&#125;
		else
		&#123;
			L &#x3D; L-&gt;next;
		&#125;
	&#125;
	return NULL;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>完整代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
struct node
&#123;
	string data;
	node* next;		&#x2F;&#x2F;指向下一个元素
	node* prev;		&#x2F;&#x2F;指向前一个元素
	node()
	&#123;
		data &#x3D; &quot;&quot;;
		prev &#x3D; NULL;
		next &#x3D; NULL;
	&#125;
&#125;;

using doubleLinkedList &#x3D; node;

void insert(node* position, string input)
&#123;&#x2F;&#x2F;position是插入的位置，input是插入数据的data
	node* newNode &#x3D; new node();
	newNode-&gt;data &#x3D; input;				&#x2F;&#x2F;先处理新创造的节点
	newNode-&gt;next &#x3D; position-&gt;next;		
	newNode-&gt;prev &#x3D; position;
	if (position-&gt;next !&#x3D; NULL) &#123;
		position-&gt;next-&gt;prev &#x3D; newNode;
		position-&gt;next &#x3D; newNode;
	&#125;
	else &#123;
		position-&gt;next &#x3D; newNode;
	&#125;
&#125;

void deleteElement(node* ele)
&#123;
	ele-&gt;prev-&gt;next &#x3D; ele-&gt;next;
	if (ele-&gt;next !&#x3D; NULL)
	&#123;
		ele-&gt;next-&gt;prev &#x3D; ele-&gt;prev;
	&#125;
	else
	&#123;
	&#125;
	delete ele;
&#125;

node* find(string input, doubleLinkedList* list)
&#123;
	doubleLinkedList* L &#x3D; list;
	while (L !&#x3D; NULL)
	&#123;
		if (L-&gt;data &#x3D;&#x3D; input)
		&#123;
			return L;
		&#125;
		else
		&#123;
			L &#x3D; L-&gt;next;
		&#125;
	&#125;
	return NULL;
&#125;

doubleLinkedList* createList()
&#123;
	node* list &#x3D; new node();
	return list;
&#125;

int main()
&#123;
	doubleLinkedList* list &#x3D; createList();
	while (true)
	&#123;
		int j;
		cin &gt;&gt; j;
		if (j &#x3D;&#x3D; 1)
		&#123;
			string query, input;
			cin &gt;&gt; input;
			insert(list, input);
		&#125;
		else
		&#123;
			string query;
			cin &gt;&gt; query;
			deleteElement(find(query, list));
		&#125;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此代码已经本人VS调试测试，暂时没有发现什么问题</p>
<p>如果由不懂的或错误的，欢迎评论或加QQ私聊！</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2022/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-03-10-%E6%A0%88/</url>
    <content><![CDATA[<h1 id="关于栈">关于栈</h1>
<p>栈是一种<strong>后进先出</strong>的数据结构，栈中允许进行插入、删除操作的一段位<strong>栈顶</strong>，另一端则称为<strong>栈底</strong>。栈中没有元素时为<strong>空栈</strong>。栈的插入删除操作分别称为<strong>进栈</strong>和<strong>出栈</strong>。因此每次进栈都会放在原栈顶元素之上并成为新的栈顶，而每次出栈都会拿出当前栈顶元素，并更新栈顶。</p>
<p>我认为这是一种比较重要的数据结构，因为操作系统中许多操作都是在栈中进行的。因此有必要认真看一看。</p>
<h1 id="栈的操作">栈的操作</h1>
<p>下面是栈操作的图示</p>
<p><strong>入栈：每一次入栈，栈顶指针都必须跟随变化</strong></p>
<p><img src="https://s2.loli.net/2022/06/02/gdLHtUr3yD2cJMl.png" alt="1.png"></p>
<p><img src="https://s2.loli.net/2022/06/02/9nhJwyfWdoK8Bgz.png" alt="2.png"></p>
<p>这是最主要的两个操作。其余的操作还有：</p>
<li style="list-style-type: none;">
<ul>
- initStack(S)　　   //初始化栈
- clearStack(s)　　//清空栈
- isEmpty(S)           //看是否为空站
- isFull(s)                //看栈是否已满
- getTop(S, x)         //取出顶部元素，但是不改变栈
<p>以下是栈的所有操作</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool pop(Stack* stack, int* top);
bool push(Stack* stack, int *pushElement);
void initStack(Stack*);
void clearStack(Stack* stack);
bool isEmpty(Stack* stack);
bool isFull(Stack* stack);
bool getTop(Stack* stack, int* top);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>栈的结构</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Stack
&#123;
private:
    int stack[Stack_Size];        &#x2F;&#x2F;Stack_Size为栈的大小，可根据需求修改
    int topPointer;

public:
    bool pop(int *top);
    bool push(int *pushElement);
    void initStack();
    void clearStack();
    bool isEmpty();
    bool isFull();
    bool getTop(int *top);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="栈操作的实现">栈操作的实现</h1>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;出栈
bool Stack::pop(int *top)
&#123;
    if (this-&gt;isEmpty())
    &#123;
        return false;
    &#125;
    *top &#x3D; this-&gt;stack[this-&gt;topPointer];
    this-&gt;topPointer--;
    return true;
&#125;
&#x2F;&#x2F;初始化
void Stack::initStack()
&#123;
    this-&gt;topPointer &#x3D; -1;
&#125;
&#x2F;&#x2F;清空
void Stack::clearStack()
&#123;
    this-&gt;topPointer &#x3D; -1;
&#125;
&#x2F;&#x2F;判空
bool Stack::isEmpty()
&#123;
    if (this-&gt;topPointer &lt; 0)
    &#123;
        return true;
    &#125;
    return false;
&#125;
&#x2F;&#x2F;入栈
bool Stack::push(int *top)
&#123;
    if (this-&gt;isFull())
    &#123;
        return false;
    &#125;
    this-&gt;topPointer++;
    this-&gt;stack[topPointer] &#x3D; *top;
    return true;
&#125;
&#x2F;&#x2F;判满
bool Stack::isFull()
&#123;
    if (this-&gt;topPointer &#x3D;&#x3D; Stack_Size - 1)
    &#123;
        return true;
    &#125;
    return false;
&#125;
&#x2F;&#x2F;获取栈顶元素
bool Stack::getTop(int *top)
&#123;
    if (this-&gt;isEmpty())&#123;

        return false;
    &#125;
    *top &#x3D; this-&gt;stack[this-&gt;topPointer];
    return true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就是栈的全部了</p>
<p>此外，还准备了模板栈类主要为了强化自己面向对象能力</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;string&gt;
#define Stack_Size 50 &#x2F;&#x2F;栈中个数为50
template &lt;typename T&gt;
class Stack
&#123;
private:
    T stack[Stack_Size];
    int topPointer;

public:
    bool pop(T *top);
    bool push(T *pushElement);
    void clearStack();
    bool isEmpty();
    bool isFull();
    bool getTop(T *top);

    &#x2F;&#x2F;构造函数担任初始化任务
    Stack();
    &#x2F;&#x2F;不允许赋值
    Stack(const Stack &amp;) &#x3D; delete;
    Stack operator&#x3D;(const Stack &amp;rhs) &#x3D; delete;
&#125;;
template &lt;typename T&gt;
bool Stack&lt;T&gt;::pop(T *top)
&#123;
    if (this-&gt;isEmpty())
    &#123;
        return false;
    &#125;
    *top &#x3D; this-&gt;stack[this-&gt;topPointer];
    this-&gt;topPointer--;
    return true;
&#125;

template &lt;typename T&gt;
bool Stack&lt;T&gt;::push(T *pushElement)
&#123;
    if (this-&gt;isFull())
    &#123;
        return false;
    &#125;
    this-&gt;topPointer++;
    this-&gt;stack[topPointer] &#x3D; *pushElement;
    return true;
&#125;

template &lt;typename T&gt;
void Stack&lt;T&gt;::clearStack()
&#123;
    this-&gt;topPointer &#x3D; -1;
&#125;

template &lt;typename T&gt;
bool Stack&lt;T&gt;::isEmpty()
&#123;
    if (this-&gt;topPointer &lt; 0)
    &#123;
        return true;
    &#125;
    return false;
&#125;

template &lt;typename T&gt;
bool Stack&lt;T&gt;::isFull()
&#123;
    if (this-&gt;topPointer &#x3D;&#x3D; Stack_Size - 1)
    &#123;
        return true;
    &#125;
    return false;
&#125;

template &lt;typename T&gt;
bool Stack&lt;T&gt;::getTop(T *top)
&#123;
    if (this-&gt;isEmpty())
    &#123;

        return false;
    &#125;
    *top &#x3D; this-&gt;stack[this-&gt;topPointer];
    return true;
&#125;

template &lt;typename T&gt;
Stack&lt;T&gt;::Stack() : topPointer(-1) &#123;&#125;

int main()
&#123;
    Stack&lt;std::string&gt; aStack;
    std::string  a &#x3D; &quot;this is a test&quot;;
    aStack.push(&amp;a);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>链栈</title>
    <url>/2022/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-03-11-%E9%93%BE%E6%A0%88/</url>
    <content><![CDATA[<p>链栈与栈的逻辑结构相同，只不过存储结构不同。</p>
<p>链栈的表头指针为栈顶指针。</p>
<p>链栈的优点是不用指定内存。只要操作系统没用光，就能一直push。</p>
<p>按理来说应该会有一个表示这个栈长度的私有量，但是因为我懒，所以没弄</p>
<p><strong>示意图</strong></p>
<p><img src="https://s2.loli.net/2022/06/02/j3ED7oMVkca1nBF.png" alt="1.png">**</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;

struct Node
&#123;
    int data;
    Node *next;
&#125;;

class LinkStack
&#123;
private:
    Node *head;

public:
    LinkStack()
    &#123;&#x2F;&#x2F;构造函数
        head &#x3D; new Node;
        head-&gt;next &#x3D; nullptr;
    &#125;
    bool push(int a);
    bool pop(int *a);
&#125;;
bool LinkStack::push(int a)
&#123;&#x2F;&#x2F;压栈
    Node *newNode;
    try&#x2F;&#x2F;异常处理
    &#123;
        newNode &#x3D; new Node();
    &#125;
    catch (const std::bad_alloc &amp;e)
    &#123;
        return false;
    &#125;

    newNode-&gt;data &#x3D; a;
    newNode-&gt;next &#x3D; this-&gt;head-&gt;next;
    this-&gt;head-&gt;next &#x3D; newNode;
    return true;
&#125;

bool LinkStack::pop(int *a)
&#123;&#x2F;&#x2F;出栈
    Node *node &#x3D; this-&gt;head-&gt;next;
    if (node &#x3D;&#x3D; nullptr)
    &#123;
        return false;
    &#125;
    *a &#x3D; node-&gt;data;
    this-&gt;head-&gt;next &#x3D; node-&gt;next;
    delete node;
    return true;
&#125;

int main()
&#123;
    LinkStack a;
    int b;
    a.pop(&amp;b);
    a.push(6);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>双端栈</title>
    <url>/2022/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-03-13-%E5%8F%8C%E7%AB%AF%E6%A0%88/</url>
    <content><![CDATA[<h1 id="关于双端栈">关于双端栈</h1>
<p>为了节省数组空间并增加栈的个数，可以使用双端栈。</p>
<p>双端栈的基本操作都和栈没太大区别，因此不再赘述。</p>
<p><img src="https://s2.loli.net/2022/06/02/bPtMmgiWrusSUqH.png" alt="1.png"></p>
<p><img src="https://s2.loli.net/2022/06/02/vVXl2szPheikYnw.png" alt="2.png"></p>
<h1 id="实现">实现</h1>
<p>仅实现双端栈的插入删除初始化操作。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;iostream&gt;
#define STACK_SIZE 100
template &lt;typename ElementType&gt;
struct DoubleSideStack
&#123;
    int top[2];
    ElementType Stack[STACK_SIZE];

    DoubleSideStack();  &#x2F;&#x2F;初始化（构造函数）
    bool push(ElementType x, int i);    &#x2F;&#x2F;压栈
    bool pop(ElementType *x, int i);    &#x2F;&#x2F;出栈
&#125;;

template &lt;typename ElementType&gt;
DoubleSideStack&lt;ElementType&gt;::DoubleSideStack()
&#123;&#x2F;&#x2F;初始化
    top[0] &#x3D; -1;
    top[1] &#x3D; STACK_SIZE;
&#125;

template &lt;typename ElementType&gt;
bool DoubleSideStack&lt;ElementType&gt;::push(ElementType x, int i)
&#123;&#x2F;&#x2F;压栈
    if (this-&gt;top[0] + 1 &#x3D;&#x3D; this-&gt;top[1])
    &#123; &#x2F;&#x2F;判断栈满与否
        std::cout &lt;&lt; &quot;栈满&quot;;
        return false;
    &#125;

    switch (i)
    &#123;
    case 0:
    &#123;
        this-&gt;top[0]++;
        this-&gt;Stack[this-&gt;top[0]] &#x3D; x;
        return true;
        break;
    &#125;
    case 1:
    &#123;
        this-&gt;top[1]--;
        this-&gt;Stack[this-&gt;top[1]] &#x3D; x;
        return true;
        break;
    &#125;
    default:
    &#123;
        std::cout &lt;&lt; &quot;out of range&quot; &lt;&lt; std::endl;
        return false;
        break;
    &#125;
    &#125;
&#125;

template &lt;typename ElementType&gt;
bool DoubleSideStack&lt;ElementType&gt;::pop(ElementType *x, int i)
&#123;&#x2F;&#x2F;出栈
    switch (i)
    &#123;
    case 0:
    &#123;
        if (this-&gt;top[0] &#x3D;&#x3D; -1)
        &#123;&#x2F;&#x2F;判断栈空与否
            std::cout &lt;&lt; &quot;out of range&quot; &lt;&lt; std::endl;
            return false;
        &#125;
        *x &#x3D; this-&gt;Stack[this-&gt;top[0]];
        this-&gt;top[0]--;
        return true;
        break;
    &#125;
    case 1:
    &#123;
        if (this-&gt;top[1] &#x3D;&#x3D; STACK_SIZE)
        &#123;&#x2F;&#x2F;判断栈空与否
            std::cout &lt;&lt; &quot;out of range&quot; &lt;&lt; std::endl;
            return false;
        &#125;
        *x &#x3D; this-&gt;Stack[this-&gt;top[1]];
        this-&gt;top[1]++;
        return true;
        break;
    &#125;
    default:
    &#123;
        return false;
        break;
    &#125;
    &#125;
&#125;

int main()
&#123;
    DoubleSideStack&lt;std::string&gt; testStack;
    testStack.push(&quot;this is a test&quot;, 0);
    testStack.push(&quot;this is a end test&quot;, 1);
    std::string newString;
    testStack.pop(&amp;newString, 1);
    testStack.pop(&amp;newString, 1);
    std::cout &lt;&lt; newString;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>链队列</title>
    <url>/2022/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-03-14-%E9%93%BE%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="关于此数据结构-题外话">关于此数据结构&amp;题外话</h1>
<p>链队列是队列的一种，队列（Queue）是一种先入先出的数据结构。增加元素叫入队，删除元素叫出队。</p>
<p>我最近发现了拿类组织数据结构真的是一件很方便的事，因此这一期用的事模板+类，有关C++的代码我都会在旁标出C语言等价解释。</p>
<h1 id="链队列的示意">链队列的示意</h1>
<p><img src="https://s2.loli.net/2022/06/05/h6voFArmXDcEOiR.png" alt="1.png"></p>
<p>一种特殊情况是，在队列里只有一个元素时，将该元素出队。**此时就需要移动rear， 使rear = front，**否则之后在判空时会出错。如图所示</p>
<p><img src="https://s2.loli.net/2022/06/05/X8mWQnsbYG15cJk.png" alt="2.png"></p>
<p>链队列应实现的功能如下</p>
<pre class="line-numbers language-none"><code class="language-none">template &lt;typename ElementType&gt;
class LinkQueue
&#123;
private:
    Node&lt;ElementType&gt; *front; &#x2F;&#x2F;相当于Node的数据域类型为ElementType
    Node&lt;ElementType&gt; *rear;

public:
    bool initQueue();                 &#x2F;&#x2F;初始化队列
    bool isEmpty();                   &#x2F;&#x2F;队列判空
    bool enterQueue(ElementType x);   &#x2F;&#x2F;入队
    bool deleteQueue(ElementType *x); &#x2F;&#x2F;出队
    bool getHead(ElementType *x);     &#x2F;&#x2F;得到元素，但不出队
    void clearQueue();                &#x2F;&#x2F;清空队列
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="链队列的实现"><strong>链队列的实现</strong></h1>
<p><strong>注释都在代码里，不懂请发私信或直接联系我QQ也行。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;

template &lt;typename ElementType&gt; &#x2F;&#x2F;相当于#define ElementType 元素类型
struct Node
&#123;
    ElementType data; &#x2F;&#x2F;数据域
    Node *next;       &#x2F;&#x2F;指针域
&#125;;

template &lt;typename ElementType&gt;
class LinkQueue
&#123;
private:
    Node&lt;ElementType&gt; *front; &#x2F;&#x2F;相当于Node的数据域类型为ElementType
    Node&lt;ElementType&gt; *rear;

public:
    bool initQueue();                 &#x2F;&#x2F;初始化队列
    bool isEmpty();                   &#x2F;&#x2F;队列判空
    bool enterQueue(ElementType x);   &#x2F;&#x2F;入队
    bool deleteQueue(ElementType *x); &#x2F;&#x2F;出队
    bool getHead(ElementType *x);     &#x2F;&#x2F;得到元素，但不出队
    void clearQueue();                &#x2F;&#x2F;清空队列
&#125;;

template &lt;typename ElementType&gt;
bool LinkQueue&lt;ElementType&gt;::initQueue()
&#123;
    try &#x2F;&#x2F;相当于front &#x3D; (Node*)malloc(sizeof(Node))
    &#123;
        front &#x3D; new Node&lt;ElementType&gt;;
    &#125;
    catch (const std::exception &amp;e)
    &#123; &#x2F;&#x2F;相当于if(front &#x3D;&#x3D; NULL)
        std::cerr &lt;&lt; e.what() &lt;&lt; &#39;\n&#39;;
    &#125;
    rear &#x3D; front;
    front-&gt;next &#x3D; nullptr;
    return true;
&#125;

template &lt;typename ElementType&gt;
bool LinkQueue&lt;ElementType&gt;::isEmpty()
&#123;
    if (front &#x3D;&#x3D; rear)
    &#123;
        return true;
    &#125;
    return false;
&#125;

template &lt;typename ElementType&gt;
bool LinkQueue&lt;ElementType&gt;::enterQueue(ElementType x)
&#123;
    Node&lt;ElementType&gt; *newNode;
    try
    &#123;
        newNode &#x3D; new Node&lt;ElementType&gt;;
    &#125;
    catch (const std::exception &amp;e)
    &#123;
        std::cerr &lt;&lt; e.what() &lt;&lt; &#39;\n&#39;;
    &#125;
    newNode-&gt;data &#x3D; x;
    newNode-&gt;next &#x3D; nullptr;
    rear-&gt;next &#x3D; newNode;
    rear &#x3D; newNode;
    return true;
&#125;

template &lt;typename ElementType&gt;
bool LinkQueue&lt;ElementType&gt;::deleteQueue(ElementType *x)
&#123;
    Node&lt;ElementType&gt; *p;
    if (this-&gt;isEmpty()) &#x2F;&#x2F;队空
    &#123;
        return false;
    &#125;
    p &#x3D; front-&gt;next;
    *x &#x3D; p-&gt;data;
    front-&gt;next &#x3D; p-&gt;next;
    if (rear &#x3D;&#x3D; p) &#x2F;&#x2F;如果队中只有一个元素p,则p出队后成为空队
    &#123;
        rear &#x3D; front;
    &#125;
    delete p;
    return true;
&#125;

template &lt;typename ElementType&gt;
bool LinkQueue&lt;ElementType&gt;::getHead(ElementType *x)
&#123;
    if (this-&gt;isEmpty())
    &#123;
        return false;
    &#125;
    *x &#x3D; front-&gt;next-&gt;data;
    return true;
&#125;

template &lt;typename ElementType&gt;
void LinkQueue&lt;ElementType&gt;::clearQueue()
&#123;
    if (this-&gt;isEmpty())
    &#123;
        return;
    &#125;
    while (front !&#x3D; rear)
    &#123;
        Node&lt;ElementType&gt; *p &#x3D; front;
        front &#x3D; front-&gt;next;
        delete p;
    &#125;
&#125;

int main()
&#123; &#x2F;&#x2F;测试代码
    LinkQueue&lt;int&gt; test;
    test.initQueue();
    int testInt;
    test.enterQueue(1);
    test.enterQueue(2);
    test.enterQueue(3);
    test.getHead(&amp;testInt);
    std::cout &lt;&lt; testInt &lt;&lt; std::endl;
    test.deleteQueue(&amp;testInt);
    std::cout &lt;&lt; testInt &lt;&lt; std::endl;
    test.deleteQueue(&amp;testInt);
    std::cout &lt;&lt; testInt &lt;&lt; std::endl;
    test.clearQueue();
    test.deleteQueue(&amp;testInt);
    std::cout &lt;&lt; testInt &lt;&lt; std::endl;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>循环队列</title>
    <url>/2022/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-03-16-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>循环队列是队列的一种顺序表示与实现方法。</p>
<p><img src="https://s2.loli.net/2022/06/05/LGIqkwfXtjp4RCM.png" alt="1.png"></p>
<p><strong>入队</strong></p>
<p><img src="https://s2.loli.net/2022/06/05/ECNe4YOfhZ2KI7G.png" alt="2.png"></p>
<p><strong>出队</strong></p>
<p><img src="https://s2.loli.net/2022/06/05/IB2YiTwLC38s5eQ.png" alt="3.png"></p>
<p>我们可以看到<strong>rear指针总指向队里最后一个的下一个位置</strong></p>
<p>此时当rear == front时，如果之前有元素出队，那么就会造成队满的假象。</p>
<p>此时使用取模运算可以解决这个问题。</p>
<p>因此队尾指针变化为</p>
<pre class="line-numbers language-none"><code class="language-none">rear &#x3D; (rear + 1) % MAXSIZE;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>队首指针变化为</p>
<pre class="line-numbers language-none"><code class="language-none">front &#x3D; (front + 1) % MAXSIZE;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是如果仅使用rear == front来判断队满还是队空，会发生歧义</p>
<p>**队空 **</p>
<p><img src="https://s2.loli.net/2022/06/05/4ia16PrTBEIf98u.png" alt="4.png"></p>
<p><strong>队满</strong></p>
<p><img src="https://s2.loli.net/2022/06/05/ndYtLgHcF4x2e9f.png" alt="5.png"></p>
<p>解决方案是牺牲一个元素的空间，当队尾指针的下一个元素为队首元素时，则队满，停止入队</p>
<p><strong>队满</strong></p>
<pre class="line-numbers language-none"><code class="language-none">rear &#x3D;&#x3D; front;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>判满条件为</p>
<pre class="line-numbers language-none"><code class="language-none">(rear + 1) % MAXSIZE &#x3D;&#x3D; front;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="实现">实现</h1>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#define ElementType int
#define MAXSIZE 50
class CircularQueue
&#123;
    ElementType element[MAXSIZE];
    int rear;
    int front;
    public:
    void init();
    bool enterQueue(ElementType x);
    bool deleteQueue(ElementType* x);
&#125;;
void CircularQueue::init()
&#123;
    this-&gt;front &#x3D; this-&gt;rear &#x3D; 0;
&#125;

bool CircularQueue::enterQueue(ElementType x)
&#123;
    if ((this-&gt;rear + 1) % MAXSIZE &#x3D;&#x3D; this-&gt;front)
    &#123;&#x2F;&#x2F;栈满
        return false;
    &#125;
    this-&gt;element[this-&gt;rear] &#x3D; x;
    this-&gt;rear &#x3D; (this-&gt;rear + 1) % MAXSIZE;
    return true;
&#125;

bool CircularQueue::deleteQueue(ElementType* x)
&#123;
    if (this-&gt;front &#x3D;&#x3D; this-&gt;rear)
    &#123;&#x2F;&#x2F;空队
        return false;
    &#125;
    *x &#x3D; this-&gt;element[this-&gt;front];
    this-&gt;front &#x3D; (this-&gt;front + 1) % MAXSIZE;
    return true;
&#125;


int main()&#123;
    CircularQueue Queue;
    Queue.init();
    int x;
    Queue.deleteQueue(&amp;x);
    Queue.enterQueue(1);
    Queue.enterQueue(2);
    Queue.enterQueue(3);
    Queue.enterQueue(4);
    Queue.enterQueue(5);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】深度优先搜索（DFS）</title>
    <url>/2022/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-03-19-%E7%AE%97%E6%B3%95%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言-吐槽">前言&amp;吐槽</h1>
<p>我看网上都说深度优先搜索是一种遍历树和图的算法，但是我还没学数和图啊！老师就讲了。</p>
<p>不过这种算法也确实挺好用的，下面我们就来介绍一下。</p>
<h1 id="介绍">介绍</h1>
<p>DFS形象点来说就是不撞南墙不回头，必须要一条路走到黑，之后再考虑其他路。</p>
<p>因此DFS最重要的部分就是回溯了。</p>
<p>而关于此算法的步骤，网上总结得已经很好了</p>
<center>递归下去</center>
<center>回溯上来</center>
<p>下面我们画图来更好得理解一下这种算法。</p>
<h1 id="图示">图示</h1>
<p>首先，假设我们现在的任务是从A走向B</p>
<p><img src="https://s2.loli.net/2022/06/07/7HAUDIqnyGcjCQ4.png" alt="1.png"></p>
<p><img src="https://s2.loli.net/2022/06/07/NOmKXRYxhztcopB.png" alt="2.png"></p>
<p><img src="https://s2.loli.net/2022/06/07/sUK5pcdlVWemt1O.png" alt="3.png"></p>
<p><img src="https://s2.loli.net/2022/06/07/DjH4gUK7onscOV9.png" alt="4.png"></p>
<h1 id="实战">实战</h1>
<p><a href="https://www.cnblogs.com/RickSchanze/articles/16026411.html">跳马问题</a></p>
<p><a href="https://www.cnblogs.com/RickSchanze/articles/16026578.html">奇怪的电梯</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】Prim算法</title>
    <url>/2022/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-05-29-Prim%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>最近数据结构已经结课了，但是我差的太多啦！！！这篇文章就来补最小生成树的Prim算法。</p>
<h2 id="简介">简介</h2>
<p>Prim是一种生成最小生成树的算法。<s>雀氏简啊</s></p>
<h2 id="算法步骤描述">算法步骤描述</h2>
<p>假设$$ N=(V, {E}) $$ 是一连通图, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">TE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>为最小生成树种边的集合。</p>
<ol>
<li>初始时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><msub><mi>u</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>u</mi><mn>0</mn></msub><mo>∈</mo><mi>V</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>T</mi><mi>E</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">U={u_0}(u_0\in V), TE=\empty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span> 。</li>
<li>在所有的$u\in U,v\in V-U <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>的边中，选一条代价最小的边</mtext></mrow><annotation encoding="application/x-tex">的边中，选一条代价最小的边</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">选</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">价</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">边</span></span></span></span>(u,v)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>并入集合</mtext></mrow><annotation encoding="application/x-tex">并入集合</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span></span></span></span>TE<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo separator="true">,</mo><mtext>同时</mtext></mrow><annotation encoding="application/x-tex">,同时</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">时</span></span></span></span>v<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>并入</mtext></mrow><annotation encoding="application/x-tex">并入</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">入</span></span></span></span>U$.</li>
<li>重复第二个步骤，直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U=V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>为止。</li>
</ol>
<p>此时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">TE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>种必含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>条边，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mrow><mi>T</mi><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=(V,{TE})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span><span class="mclose">)</span></span></span></span>为N的最小生成树。</p>
<h2 id="算法图解">算法图解</h2>
<p><img src="https://s2.loli.net/2022/05/30/KTOcxhZpN2qWdgj.jpg" alt="1.jpg"></p>
<center>此图来源于课本</center>
<h2 id="算法实现">算法实现</h2>
<p>为了记录已在生成树的顶点集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>，我们使用一个结构来记录，如下</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct Assist
&#123;
    int tail;			&#x2F;&#x2F; 表示从结点tail引出
    int lowcost;		&#x2F;&#x2F; 表示到当前结点的最短距离
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在进行操作时，我们(closedge为Assist数组)</p>
<ol>
<li>将初始顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>加入到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>中，对其余每一顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">closedge[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>均初始化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>的边信息。</li>
<li>循环<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次，进行如下操作：
<ul>
<li>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">closedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span></span></span></span>中选出最小边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext>这里</mtext><mi>v</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">closedge[v],这里v \in V-U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>。</li>
<li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>加入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span></li>
<li>更新剩余每组的最小边信息<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>i</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">closedge[i](i \in V-U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> 。</li>
</ul>
</li>
</ol>
<p>关键部分如下:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * @description: Prim算法
 * @param begin 最小生成树的开始结点
 * @return void
 *&#x2F;
void Graph::prim(int begin)
&#123;
    &#x2F;*用于求最小生成树的辅助结构*&#x2F;
    Assist closedge[20];
    auto start &#x3D; begin - 1;
    closedge[start].lowcost &#x3D; 0; &#x2F;&#x2F; 初始化, U &#x3D; &#123;u&#125;
    for (int i &#x3D; 0; i &lt; vexnum; i++)
    &#123;
        if (i !&#x3D; start)			&#x2F;&#x2F; 初始化closedge[i]
        &#123;
            closedge[i].tail &#x3D; start;
            auto weig &#x3D; findArc(start, i + 1);
            if (!weig)
            &#123;
                closedge[i].lowcost &#x3D; 10000;
            &#125;
            else
            &#123;
                closedge[i].lowcost &#x3D; weig-&gt;weight;
            &#125;
        &#125;
    &#125;
    for (int i &#x3D; 0; i &lt; vexnum - 1; i++)		&#x2F;&#x2F; 循环n-1次
    &#123;
        auto minNode &#x3D; minimum(closedge);		&#x2F;&#x2F; 找出最小边
        start &#x3D; closedge[minNode].tail;
        &#x2F;*输出最小生成树信息*&#x2F;
        std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; start + 1 &lt;&lt; &quot;,&quot; &lt;&lt; minNode + 1 &lt;&lt; &quot;&gt;&quot; &lt;&lt; std::endl;
        closedge[minNode].lowcost &#x3D; 0;			&#x2F;&#x2F; 将minNode并入U中
        &#x2F;*更新closedge信息*&#x2F;
        for (int j &#x3D; 0; j &lt; vexnum; j++)
        &#123;
            auto now &#x3D; findArc(minNode, j + 1);
            if (!now)
            &#123;
                continue;
            &#125;
            if (now-&gt;weight &lt; closedge[j].lowcost)
            &#123;
                closedge[j].lowcost &#x3D; now-&gt;weight;
                closedge[j].tail &#x3D; minNode;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="完整代码实现">完整代码实现</h2>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;*
 * @Author: zh(RickSchanze)(帝皇の惊)
 * @Description: 最小生成树的Prim算法
 * @Date: 2022-05-29 22:48:52
 * @LastEditTime: 2022-05-31 21:34:56
 *&#x2F;
#include &lt;iostream&gt;

struct ArcNode
&#123;
    int arc;
    int weight;
    ArcNode *next;

    ArcNode(int arc, int weight) : arc(arc), weight(weight), next(nullptr) &#123;&#125;
&#125;;

struct VexNode
&#123;
    int vex;
    ArcNode *first;

    VexNode(int vex) : vex(vex), first(nullptr) &#123;&#125;
    VexNode() : vex(-1), first(nullptr) &#123;&#125;
&#125;;

struct Assist
&#123;
    int tail;
    int lowcost;
&#125;;

struct Graph
&#123;
    VexNode vexMat[20];
    int arcnum;
    int vexnum;

    &#x2F;&#x2F; void createDirectedGraph();  有向图暂时先不写了
    void createGraph();
    void prim(int begin);
    ArcNode *findArc(int begin, int end) const;
    int minimum(Assist *) const;
&#125;;

int Graph::minimum(Assist dist[]) const
&#123;
    int min &#x3D; 10000, rtn &#x3D; 10000;
    for (int i &#x3D; 0; i &lt; vexnum; i++)
    &#123;
        if (dist[i].lowcost &#x3D;&#x3D; 0)
        &#123;
            continue;
        &#125;
        if (dist[i].lowcost &lt; min)
        &#123;
            min &#x3D; dist[i].lowcost;
            rtn &#x3D; i;
        &#125;
    &#125;
    return rtn;
&#125;

ArcNode *Graph::findArc(int begin, int end) const
&#123;
    auto beginPtr &#x3D; vexMat[begin].first;
    if (beginPtr)
    &#123;
        while (beginPtr !&#x3D; nullptr)
        &#123;
            if (beginPtr-&gt;arc &#x3D;&#x3D; end)
            &#123;
                return beginPtr;
            &#125;
            beginPtr &#x3D; beginPtr-&gt;next;
        &#125;
    &#125;
    return beginPtr;
&#125;

void Graph::createGraph()
&#123;
    std::cout &lt;&lt; &quot;请输入顶点个数:&quot;;
    std::cin &gt;&gt; vexnum;
    &#x2F;&#x2F; vexMat &#x3D; new VexNode[vexnum];
    for (size_t i &#x3D; 0; i &lt; vexnum; i++)
    &#123;
        std::cin &gt;&gt; vexMat[i].vex;
    &#125;
    std::cout &lt;&lt; &quot;请输入边个数:&quot;;
    std::cin &gt;&gt; arcnum;
    for (size_t i &#x3D; 0; i &lt; arcnum; i++)
    &#123;
        int begin, end, weight;
        std::cout &lt;&lt; &quot;输入弧尾弧头权重:&quot;;
        std::cin &gt;&gt; begin &gt;&gt; end &gt;&gt; weight;
        auto first &#x3D; vexMat[begin - 1].first;
        for (; first !&#x3D; nullptr &amp;&amp; first-&gt;next !&#x3D; nullptr; first &#x3D; first-&gt;next)
            ;
        if (first &#x3D;&#x3D; nullptr)
        &#123;
            vexMat[begin - 1].first &#x3D; new ArcNode(end, weight);
        &#125;
        else
        &#123;
            first-&gt;next &#x3D; new ArcNode(end, weight);
        &#125;
    &#125;
&#125;

&#x2F;**
 * @description: Prim算法
 * @param begin 最小生成树的开始结点
 * @return void
 *&#x2F;
void Graph::prim(int begin)
&#123;
    &#x2F;*用于求最小生成树的辅助结构*&#x2F;
    Assist closedge[20];
    auto start &#x3D; begin - 1;
    closedge[start].lowcost &#x3D; 0; &#x2F;&#x2F; 初始化, U &#x3D; &#123;u&#125;
    for (int i &#x3D; 0; i &lt; vexnum; i++)
    &#123;
        if (i !&#x3D; start)
        &#123;
            closedge[i].tail &#x3D; start;
            auto weig &#x3D; findArc(start, i + 1);
            if (!weig)
            &#123;
                closedge[i].lowcost &#x3D; 10000;
            &#125;
            else
            &#123;
                closedge[i].lowcost &#x3D; weig-&gt;weight;
            &#125;
        &#125;
    &#125;
    for (int i &#x3D; 0; i &lt; vexnum - 1; i++)
    &#123;
        auto minNode &#x3D; minimum(closedge);
        start &#x3D; closedge[minNode].tail;
        std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; start + 1 &lt;&lt; &quot;,&quot; &lt;&lt; minNode + 1 &lt;&lt; &quot;&gt;&quot; &lt;&lt; std::endl;
        closedge[minNode].lowcost &#x3D; 0;
        for (int j &#x3D; 0; j &lt; vexnum; j++)
        &#123;
            auto now &#x3D; findArc(minNode, j + 1);
            if (!now)
            &#123;
                continue;
            &#125;
            if (now-&gt;weight &lt; closedge[j].lowcost)
            &#123;
                closedge[j].lowcost &#x3D; now-&gt;weight;
                closedge[j].tail &#x3D; minNode;
            &#125;
        &#125;
    &#125;
&#125;

int main()
&#123;
    Graph *graph &#x3D; new Graph();
    graph-&gt;createGraph();
    graph-&gt;prim(2);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注：这里的图用邻接表存储</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】Kruskal算法</title>
    <url>/2022/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-06-01-Kruskal%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>​		这篇博客来记录Kruskal算法，我比较奇怪的是课本居然没给实现，那我就按自己的理解实现一遍好了。</p>
<h2 id="简介">简介</h2>
<p>​		Kruskal是一种求最小生成树的算法，相比Prim算法的加点策略，Kruskal算法采用加边策略.。</p>
<h2 id="算法步骤描述">算法步骤描述</h2>
<p>假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N=(V,{E})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span><span class="mclose">)</span></span></span></span>为一连通图，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>中的边按从小到大顺序排列</p>
<ol>
<li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个顶点看作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个集合</li>
<li>按权值由小到大选择边，所选边应满足两个顶点不在同一顶点集合内，将该边放到生成树边的集合中，同时将该边两个顶点所在顶点集合合并</li>
<li>重复2直至所有顶点均在同一顶点集合内。</li>
</ol>
<h2 id="算法流程图示">算法流程图示</h2>
<p><img src="https://s2.loli.net/2022/06/01/CBybo1wWz4cqpMr.png" alt="1.png"></p>
<center>基本与课本一致<del>比课本丑</del></center>
<h2 id="算法实现">算法实现</h2>
<p>为了实现判断不同顶点是否在同一集合内，我们使用<strong>并查集</strong>作为辅助数据结构来使用，定义如下:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct VertexSet
&#123;
    int vertex;							&#x2F;&#x2F; 表示当前结点
    VertexSet *parent &#x3D; nullptr;

    VertexSet() &#x3D; default;
    VertexSet(int i) : vertex(i) &#123;&#125;		&#x2F;&#x2F; 构造函数
    void changeGroup(VertexSet *set)
    &#123;									&#x2F;&#x2F; 将this结点加入到集合set里
        if (this-&gt;parent &#x3D;&#x3D; nullptr)
        &#123;
            this-&gt;parent &#x3D; set;				&#x2F;&#x2F; this无父节点则直接将this接入set
        &#125;
        else
        &#123;
            auto temp &#x3D; this;				&#x2F;&#x2F; 有父节点则寻找顶层父节点，将该父节点并入set
            while (temp-&gt;parent !&#x3D; nullptr)
            &#123;
                temp &#x3D; temp-&gt;parent;
            &#125;
            temp-&gt;parent &#x3D; set;
        &#125;
    &#125;
    bool inGroup(VertexSet *set)
    &#123;								&#x2F;&#x2F; 看结点this与set是否在同一集合
        VertexSet *temp &#x3D; this;
        &#x2F;&#x2F; 寻找顶层父节点
        while (temp !&#x3D; nullptr &amp;&amp; temp-&gt;parent !&#x3D; nullptr)
        &#123;
            temp &#x3D; temp-&gt;parent;
        &#125;
        VertexSet *tempSet &#x3D; set;
        while (tempSet !&#x3D; nullptr &amp;&amp; tempSet-&gt;parent !&#x3D; nullptr)
        &#123;
            tempSet &#x3D; tempSet-&gt;parent;
        &#125;
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; 比较
        if (temp &#x3D;&#x3D; tempSet)
        &#123;
            return true;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而Kruskal算法主体实现如下</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Tree::kruskal()
&#123;
    std::sort(arcs.begin(), arcs.end(), [](Arc A, Arc B)
              &#123; return A.weight &lt; B.weight; &#125;);				&#x2F;&#x2F; 使用std::sort为边集合排序
    VertexSet vertexSet[vexnum + 1];					   &#x2F;&#x2F;  创建适当大小的并查集 
    for (size_t i &#x3D; 1; i &lt;&#x3D; vexnum; i++)
    &#123;
        vertexSet[i] &#x3D; VertexSet(i);						&#x2F;&#x2F; 初始化并查集
    &#125;
    int now &#x3D; 0, size &#x3D; vexnum;								&#x2F;&#x2F; size用于记录停止条件
    while (size !&#x3D; 1)
    &#123;
        int begin &#x3D; arcs[now].tail;
        int end &#x3D; arcs[now].head;
        if (vertexSet[begin].inGroup(&amp;vertexSet[end]))
        &#123;
            now++;
            continue;
        &#125;
        std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; begin &lt;&lt; &quot;,&quot; &lt;&lt; end &lt;&lt; &quot;&gt;&quot; &lt;&lt; std::endl;
        now++;
        vertexSet[begin].changeGroup(&amp;vertexSet[end]);
        size--;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用了std::sort来进行快速排序，可以说是偷了点懒吧┑(￣Д ￣)┍</p>
<h2 id="完整代码">完整代码</h2>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct Arc
&#123;
    int tail;
    int head;
    int weight;
    Arc(int t, int h, int w) : tail(t), head(h), weight(w) &#123;&#125;
    Arc() &#x3D; default;
&#125;;

struct Tree
&#123;
    std::vector&lt;Arc&gt; arcs;
    int vexnum;
    int arcnum;

    void init();
    void kruskal();
&#125;;

struct VertexSet
&#123;
    int vertex;
    VertexSet *parent &#x3D; nullptr;

    VertexSet() &#x3D; default;
    VertexSet(int i) : vertex(i) &#123;&#125;
    void changeGroup(VertexSet *set)
    &#123;
        if (this-&gt;parent &#x3D;&#x3D; nullptr)
        &#123;
            this-&gt;parent &#x3D; set;
        &#125;
        else
        &#123;
            auto temp &#x3D; this;
            while (temp-&gt;parent !&#x3D; nullptr)
            &#123;
                temp &#x3D; temp-&gt;parent;
            &#125;
            temp-&gt;parent &#x3D; set;
        &#125;
    &#125;
    bool inGroup(VertexSet *set)
    &#123;
        VertexSet *temp &#x3D; this;
        while (temp !&#x3D; nullptr &amp;&amp; temp-&gt;parent !&#x3D; nullptr)
        &#123;
            temp &#x3D; temp-&gt;parent;
        &#125;
        VertexSet *tempSet &#x3D; set;
        while (tempSet !&#x3D; nullptr &amp;&amp; tempSet-&gt;parent !&#x3D; nullptr)
        &#123;
            tempSet &#x3D; tempSet-&gt;parent;
        &#125;
        if (temp &#x3D;&#x3D; tempSet)
        &#123;
            return true;
        &#125;
        return false;
    &#125;
&#125;;

void Tree::init()
&#123;
    std::cout &lt;&lt; &quot;请输入顶点个数与边个数:&quot;;
    std::cin &gt;&gt; vexnum &gt;&gt; arcnum;
    for (size_t i &#x3D; 1; i &lt;&#x3D; arcnum; i++)
    &#123;
        int begin, end, weight;
        std::cout &lt;&lt; &quot;请输入弧尾弧头与两点间距离:&quot;;
        std::cin &gt;&gt; begin &gt;&gt; end &gt;&gt; weight;
        arcs.emplace_back(std::move(Arc(begin, end, weight)));
    &#125;
&#125;

void Tree::kruskal()
&#123;
    std::sort(arcs.begin(), arcs.end(), [](Arc A, Arc B)
              &#123; return A.weight &lt; B.weight; &#125;);
    VertexSet vertexSet[vexnum + 1];
    for (size_t i &#x3D; 1; i &lt;&#x3D; vexnum; i++)
    &#123;
        vertexSet[i] &#x3D; VertexSet(i);
    &#125;
    int now &#x3D; 0, size &#x3D; vexnum;
    while (size !&#x3D; 1)
    &#123;
        int begin &#x3D; arcs[now].tail;
        int end &#x3D; arcs[now].head;
        int weight &#x3D; arcs[now].weight;
        if (vertexSet[begin].inGroup(&amp;vertexSet[end]))
        &#123;
            now++;
            continue;
        &#125;
        std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; begin &lt;&lt; &quot;,&quot; &lt;&lt; end &lt;&lt; &quot;&gt;&quot; &lt;&lt; std::endl;
        now++;
        vertexSet[begin].changeGroup(&amp;vertexSet[end]);
        size--;
    &#125;
&#125;

int main()
&#123;
    Tree aTree;
    aTree.init();
    aTree.kruskal();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>图使用邻接矩阵存储。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】插入类排序</title>
    <url>/2022/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2022-06-04-%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p>插入类排序的基本思想是<strong>在一个已排好序的记录子集基础上，每一步将下一个待排序的几步有序插入已排好的记录子集，直到将所有待排记录全部插入为止</strong>。</p>
<h2 id="1：直接插入排序">1：直接插入排序</h2>
<h3 id="例子">例子</h3>
<p>对于序列<code>&#123;14, 62, 35, 77, 55, 14, 35, 95&#125;</code>而言，其顺序如下</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;48&#125; 62 35 77 55 14 *35* 98
&#123;48 62&#125; 35 77 55 14 *35* 98
&#123;35 48 62&#125; 77 55 14 *35* 98
&#123;35 48 62 77&#125; 55 14 *35* 98
&#123;35 48 55 62 77&#125; 14 *35* 98
&#123;14 35 48 55 62 77&#125; *35* 98
&#123;14 35 *35* 48 55 62 77&#125; 98
&#123;14 35 *35* 48 55 62 77 98&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了提高效率，附设一个监视哨<em>data[0]</em>,使得*data[0]*始终存放待插入得记录。</p>
<p>该监视哨作用有二：</p>
<ol>
<li>
<p>备份待插入记录，以便前面关键字较大得记录后移</p>
</li>
<li>
<p>防止越界</p>
</li>
</ol>
<h3 id="算法实现">算法实现</h3>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void InsertSortion::directInsertionSort(TargetType *data, int length)
&#123;
    int j;
    for (size_t i &#x3D; 2; i &lt;&#x3D; length; i++)
    &#123;
        data[0] &#x3D; data[i]; &#x2F;&#x2F; 将待插入数据记录到监视哨data[0]
        j &#x3D; i - 1;
        while (data[0] &lt; data[j]) &#x2F;&#x2F; 寻找插入位置,同时移动元素位置
        &#123;
            data[j + 1] &#x3D; data[j];
            j--;
        &#125;
        data[j + 1] &#x3D; data[0]; &#x2F;&#x2F; 将待插入数据插入已排序的序列
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在插入排序中：</p>
<ul>
<li>
<p>最坏情况为逆序，每一趟比较移动次数均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，此时总比较次数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{(n+2)(n-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></msubsup><mi>i</mi></mrow><annotation encoding="application/x-tex">\sum_{i=2}^{n}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span></span></span></span>,记录次数也达到最大，为</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{(n+4)(n-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=2}^{n}(i+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p>
</li>
<li>
<p>最好情况为顺序，此时需比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次，记录移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>次。</p>
</li>
</ul>
<p>由于排序记录大概率随机，出现各种排列概率相同，故取平均值。时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<h2 id="2：折半插入排序">2：折半插入排序</h2>
<p>折半插入排序主要是将查找过程利用二分查找进行优化，使其查找复杂度达到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mclose">)</span></span></span></span>,但由于其移动元素的时间消耗不变，时间复杂度仍然是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<h3 id="算法实现">算法实现</h3>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void InsertSortion::halfInsertionSort(TargetType *data, int length)
&#123;
    int temp, low, high, mid;
    for (size_t i &#x3D; 2; i &lt;&#x3D; length; i++)
    &#123;
        temp &#x3D; data[i];
        low &#x3D; 1;
        high &#x3D; i - 1;
        while (low &lt;&#x3D; high) &#x2F;&#x2F; 确定插入位置
        &#123;
            mid &#x3D; (low + high) &#x2F; 2;
            if (temp &lt; mid)
            &#123;
                high &#x3D; mid - 1;
            &#125;
            else
            &#123;
                low &#x3D; mid + 1;
            &#125;
        &#125;
        for (size_t j &#x3D; i - 1; j &gt;&#x3D; low; j++)   &#x2F;&#x2F; 开始移动
        &#123;
            data[j + 1] &#x3D; data[j];
        &#125;
        data[low] &#x3D; temp;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3：希尔排序">3：希尔排序</h2>
<p>希尔排序又称缩小增量排序，是一张基于插入思想的排序方法。</p>
<h3 id="算法思想">算法思想</h3>
<p>先将待排序记录序列分割为若干个较稀疏的子序列，分别进行插入排序。经过上述粗略调整后，再对全部记录进行一次直接插入排序。</p>
<ol>
<li>选定记录间的距离<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_i(i=1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，在整个待排序记录序列中，将所有间隔为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的记录分为一组，进行组内直接插入排序</li>
<li>取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，记录间的距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>d</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>d</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_i(d_i&lt;d_{i-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，在整个待排序记录序列中，将所有间隔为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的记录分为一组，进行组内直接插入排序。</li>
</ol>
<p>重复步骤2多次，直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">d_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，此时只有一个子序列，对该序列进行直接插入排序即可。</p>
<h3 id="例子">例子</h3>
<p>初始关键字序列：<code>&#123;46, 55, 13, 42, 94, 17, 05, 70&#125;</code></p>
<p>取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">d_i=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，则分为4个间隔为4的子序列：</p>
<center>{ <font color=red>46</font>  <font color=yellow>55</font>  <font color=blue>13</font>  <font color=green>42</font>  <font color=red>94</font>  <font color=yellow>17</font>  <font color=blue>05</font>     <font color=green>70</font> }</center>
<p>对其每一个子序列进行插入排序，得:</p>
<center>{ <font color=red>46</font>  <font color=yellow>17</font>  <font color=blue>05</font>  <font color=green>42</font>  <font color=red>94</font>  <font color=yellow>55</font>  <font color=blue>13</font>     <font color=green>70</font> }</center>
<p>再取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">d_i=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，分为两个间隔为2的子序列:</p>
<center>{ <font color=red>46</font> <font color=blue>17</font> <font color=red>05</font>  <font color=blue>42</font> <font color=red>94</font>  <font color=blue>55</font> <font color=red>13</font> <font color=blue>70</font>}</center>
<p>对其两个子序列进行插入排序:</p>
<center>{ <font color=red>05</font> <font color=blue>17</font> <font color=red>13</font>  <font color=blue>42</font> <font color=red>46</font>  <font color=blue>55</font> <font color=red>94</font> <font color=blue>70</font>}</center>
<p>取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">d_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，对整体进行插入排序，得到结果:</p>
<center>{ 05 13 17 42 46 55 70 94 }</center>
<h3 id="算法实现">算法实现</h3>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void InsertSortion::shellInsert(TargetType *data, int length, int delta)
&#123;
    &#x2F;* 对记录数字data做一趟希尔排序*&#x2F;
    for (int i &#x3D; 1 + delta; i &lt;&#x3D; length; i++)
    &#123;
        if (data[i] &lt; data[i - delta])
        &#123;
            data[0] &#x3D; data[i]; &#x2F;&#x2F; 备份data[i],不做监视哨
            int j &#x3D; i - delta;
            for (j &#x3D; i - delta; (j &gt; 0) &amp;&amp; (data[0] &lt; data[j]); j -&#x3D; delta)
            &#123;
                data[j + delta] &#x3D; data[j];
            &#125;
            data[j + delta] &#x3D; data[0];
        &#125;
    &#125;
&#125;
&#x2F;**
 * @description: 希尔排序
 * @param &#123;TargetType*&#125; 待记录数组
 * @param &#123;int&#125; n  数组长度
 * @param &#123;int&#125; *dalta   增量数组
 * @param &#123;int&#125; m  增量数组长度
 * @return &#123;*&#125;
 *&#x2F;
void InsertSortion::shellSort(TargetType *data, int n, int *dalta, int m)
&#123;
    for (int i &#x3D; 0; i &lt; m - 1; i++)
    &#123;
        shellInsert(data, n, dalta[i]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一般认为希尔排序的复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。且希尔排序不是稳定的排序算法。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类里静态成员链接错误</title>
    <url>/2022/03/03/%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/2022-03-03-C++%E7%B1%BB%E9%87%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>我现声明一个类内静态变量:</p>
<pre class="line-numbers language-none"><code class="language-none">class test&#123;
public:
    static int a;
    int get();
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在test.cpp中对a进行使用</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;test.h&gt;
int test::get()
&#123;
    return a;                    
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>会产生链接错误</p>
<p><img src="https://s2.loli.net/2022/05/29/MPGYQKLqogBn7uE.png" alt="1.png"><br>
　　解决方案：</p>
<p><strong>①在头文件中定义函数</strong></p>
<p>**　　　　**</p>
<pre class="line-numbers language-none"><code class="language-none">#pragma once
class test
&#123;
public:
	static int a;
	int get()
	&#123;
		return a;
	&#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>②在源文件加上静态变量的声明</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;test.h&quot;

int test::a;

int test::get()
&#123;
	return a;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
]]></content>
      <categories>
        <category>细节问题</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>细节问题</tag>
      </tags>
  </entry>
  <entry>
    <title>关于函数体内指针指向问题</title>
    <url>/2022/02/16/%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/2022-02-16-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在做一道题的时候，发现了一个问题，那就是函数的执行会不会改变指针指向的问题。</p>
<p>下面来诠释此问题。</p>
<p></p>
<p>首先，我们用一段代码创建了一个具有10个节点的链表（不算头结点）：</p>
<pre class="line-numbers language-none"><code class="language-none">struct test &#123;
	int data;
	test* next &#x3D; NULL;
&#125;;

test* createList()
&#123;
	test* list &#x3D; new test;
	test* ret &#x3D; list;
	for (int i &#x3D; 0; i &lt; 10; i++)
	&#123;
		test* newNode &#x3D; new test;
		newNode-&gt;data &#x3D; i;
		list-&gt;next &#x3D; newNode;
		list &#x3D; list-&gt;next;
	&#125;
	return ret;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们有一个测试函数来改变指针：</p>
<pre class="line-numbers language-none"><code class="language-none">void changePoint(test* list)
&#123;
	list &#x3D; list-&gt;next;
&#125;

int main()
&#123;
	test* testlist &#x3D; createList();
	changePoint(testlist);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面开始调试，将断点设置在函数changePoint中，得到如下结果：</p>
<p><img src="https://s2.loli.net/2022/05/26/YQ4jAtaXq9swDVN.png" alt="1.png"></p>
<p><img src="https://s2.loli.net/2022/05/26/xCjGmJqbHD4QSVA.png" alt="2.png"></p>
<p>可见在函数体内部，指针是被改变了的。</p>
<p>但在函数执行完毕后，指针又变成了原来未被改变的：</p>
<p><img src="https://s2.loli.net/2022/05/26/PvFCebwK7R2ziWI.png" alt="3.png"></p>
<p>如果想要同时更改函数体内和函数体外的指针的值，可以使用<strong>指针的引用.</strong></p>
<pre class="line-numbers language-none"><code class="language-none">void changePoint(test* &amp;list)
&#123;
	list &#x3D; list-&gt;next;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现，指针被顺利改写。</p>
<p><strong><img src="https://s2.loli.net/2022/05/26/YsUfb5eViRh8P3u.png" alt="4.png"></strong></p>
<p><img src="https://s2.loli.net/2022/05/26/irTmSIPNge8VUM6.png" alt="5.png"></p>
<p></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>细节问题</tag>
      </tags>
  </entry>
  <entry>
    <title>双链表求500位Π</title>
    <url>/2022/03/09/%E9%A2%98%E8%A7%A3/2022-03-09-%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%B1%82500%E4%BD%8D%CE%A0/</url>
    <content><![CDATA[<h1 id="题目描述：">题目描述：</h1>
<p><img src="https://s2.loli.net/2022/06/01/CU4ZYomSAbjeTRQ.png" alt="1.png"></p>
<h1 id="思路分析：">思路分析：</h1>
<p>根据上面给出的公式，我们可以知道每一项都是前一项乘</p>
<img src="https://latex.codecogs.com/gif.latex?%5Cfrac%7B%282n-1%29%5E%7B2%7D%7D%7B2n%5Ccdot%20%282n1%29%29%7D%5Ccdot%20%5Cfrac%7B1%7D%7B4%7D" id="equationview" title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program." name="equationview" />
<p>但是考虑到会出现的大数，不能直接用long long来进行存储，绝对会溢出。又题目限定了使用双链表，因此我们使用双链表。</p>
<p>最主要需要解决的问题是大数的加法、乘法除法。解决方案见下。</p>
<p>另外，可以给第一项直接乘6，这样之后每一项都是原来的6倍，得出来的结果直接位，不必再继续乘。</p>
<p>并且我们数字低位在前，高位在后。</p>
<h1 id="解题过程：">解题过程：</h1>
<p>①完成一个双链表，题目中要求前500位，那么我们定义一个有600个节点的双链表，并将其初始化。</p>
<pre class="line-numbers language-none"><code class="language-none">struct Node
&#123;
    int data &#x3D; 0;
    Node* next &#x3D; nullptr;
    Node* prev &#x3D; nullptr;
&#125;;
void insertNode(Node* head)
&#123;
    Node* newNode &#x3D; new Node;       &#x2F;&#x2F;直接插入一个元素，这样就不用多次判断head-&gt;next是否为NULL了
    newNode-&gt;next &#x3D; head-&gt;next;
    newNode-&gt;prev &#x3D; head;
    head-&gt;next &#x3D; newNode;
    for (int i &#x3D; 1; i &lt; 600; i++)
    &#123;
        Node* newNode &#x3D; new Node;
        newNode-&gt;next &#x3D; head-&gt;next;
        newNode-&gt;prev &#x3D; head;
        head-&gt;next-&gt;prev &#x3D; newNode;
        head-&gt;next &#x3D; newNode;
    &#125;
&#125;
Node* createAList()
&#123;
    return new Node;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>②大数乘法</p>
<p>​		让程序模仿我们手算的过程即可。</p>
<pre class="line-numbers language-none"><code class="language-none">void multiple(Node* source, Node* target, int n)
&#123;&#x2F;&#x2F;source指乘数，而结果将存在source中
    int temp &#x3D; 0, ret &#x3D; 0, left &#x3D; 0;    &#x2F;&#x2F;temp指产生的临时变量，ret指进位，left指留下来的数
    while (source)
    &#123;
        temp &#x3D; source-&gt;data * n + ret;
        left &#x3D; temp % 10;
        ret &#x3D; temp &#x2F; 10;
        target-&gt;data &#x3D; left;
        source &#x3D; source-&gt;next;
        target &#x3D; target-&gt;next;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>③大数加法</strong></p>
<p>​		主要用来求这次结果与上次的和，模拟手算。</p>
<pre class="line-numbers language-none"><code class="language-none">void add(Node* sum, Node* num)
&#123;
    &#x2F;&#x2F;num为这次计算结果，相加的和存于sum中，依然需要传刚开始的节点
    int temp &#x3D; 0, ret &#x3D; 0;
    while (sum &amp;&amp; num)
    &#123;
        temp &#x3D; sum-&gt;data + num-&gt;data + ret;
        sum-&gt;data &#x3D; temp % 10;
        ret &#x3D; temp &#x2F; 10;
        sum &#x3D; sum-&gt;next;
        num &#x3D; num-&gt;next;
    &#125; 
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>④大数除法</strong></p>
<p>​		仍然是模拟手算。</p>
<pre class="line-numbers language-none"><code class="language-none">void divison(Node *source, int n)
&#123;
    &#x2F;&#x2F;值得注意的是，此次传入的应是尾节点
    int temp &#x3D; 0, ret &#x3D; 0;
    while (source)
    &#123;
        int dividend &#x3D; temp + source-&gt;data; &#x2F;&#x2F;计算过程中的被除数
        int now &#x3D; dividend &#x2F; n;             &#x2F;&#x2F;这里应该是列式计算时，计算符号上面的数
        if (!now)
        &#123;
            temp &#x3D; dividend * 10;
        &#125;
        else
        &#123;
            temp &#x3D; (dividend % n) * 10;
        &#125;
        source-&gt;data &#x3D; now;
        source &#x3D; source-&gt;prev;
    &#125;
&#125;　<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>⑤开始计算</strong></p>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    &#x2F;&#x2F;必要初始化
    Node *sum &#x3D; createAList();
    Node *num &#x3D; createAList();
    insertNode(num);
    insertNode(sum);
    &#x2F;&#x2F;获得尾结点
    Node *sumTail &#x3D; sum, *numTail &#x3D; num;
    while (sumTail-&gt;next !&#x3D; nullptr)
    &#123;
        sumTail &#x3D; sumTail-&gt;next;
    &#125;
    while (numTail-&gt;next !&#x3D; nullptr)
    &#123;
        numTail &#x3D; numTail-&gt;next;
    &#125;
    &#x2F;&#x2F;从3开始，简化运算
    numTail-&gt;data &#x3D; 3;
    sumTail-&gt;data &#x3D; 3;
    for (int i &#x3D; 1; i &lt; 1000; i++)
    &#123;
        int dividend &#x3D; (2 * i) * (2 * i + 1) * 4;
        int mult &#x3D; (2 * i - 1) * (2 * i - 1);
        &#x2F;&#x2F;先做除法，否则会溢出
        divison(numTail, dividend);
        &#x2F;&#x2F;再做乘法，注意从头结点开始
        multiple(num, mult);
        &#x2F;&#x2F;相加
        add(sum, num);
    &#125;
    &#x2F;&#x2F;指定输出位数输出
    int n;
    std::cin &gt;&gt; n;
    std::cout &lt;&lt; sumTail-&gt;data;
    sumTail &#x3D; sumTail-&gt;prev;
    std::cout &lt;&lt; &quot;.&quot;;
    for (int i &#x3D; 0; i &lt; n - 1; i++)
    &#123;
        std::cout &lt;&lt; sumTail-&gt;data;
        sumTail &#x3D; sumTail-&gt;prev;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="输出结果：">输出结果：</h1>
<p><img src="https://s2.loli.net/2022/06/01/AqelHXj8KhuGC34.png" alt="2.png"></p>
<h1 id="成功">成功！</h1>
<h1 id="完整代码：">完整代码：</h1>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;

struct Node
&#123;
    int data &#x3D; 0;
    Node *next &#x3D; nullptr;
    Node *prev &#x3D; nullptr;
&#125;;
void insertNode(Node *head)
&#123;
    Node *newNode &#x3D; new Node; &#x2F;&#x2F;直接插入一个元素，这样就不用多次判断head-&gt;next是否为NULL了
    newNode-&gt;next &#x3D; head-&gt;next;
    newNode-&gt;prev &#x3D; head;
    head-&gt;next &#x3D; newNode;
    for (int i &#x3D; 1; i &lt; 600; i++)
    &#123;
        Node *newNode &#x3D; new Node;
        newNode-&gt;next &#x3D; head-&gt;next;
        newNode-&gt;prev &#x3D; head;
        head-&gt;next-&gt;prev &#x3D; newNode;
        head-&gt;next &#x3D; newNode;
    &#125;
&#125;
Node *createAList()
&#123;
    return new Node;
&#125;

void multiple(Node *source, int n)
&#123;
    int temp &#x3D; 0, ret &#x3D; 0; &#x2F;&#x2F; temp指产生的临时变量，ret指进位，left指留下来的数
    while (source)
    &#123;
        temp &#x3D; source-&gt;data * n + ret;
        ret &#x3D; temp &#x2F; 10;
        source-&gt;data &#x3D; temp % 10;
        source &#x3D; source-&gt;next;
    &#125;
&#125;

void add(Node *sum, Node *num)
&#123;
    &#x2F;&#x2F; num为这次计算结果，相加的和存于sum中，依然需要传刚开始的节点
    int temp &#x3D; 0, ret &#x3D; 0;
    while (sum &amp;&amp; num)
    &#123;
        temp &#x3D; sum-&gt;data + num-&gt;data + ret;
        sum-&gt;data &#x3D; temp % 10;
        ret &#x3D; temp &#x2F; 10;
        sum &#x3D; sum-&gt;next;
        num &#x3D; num-&gt;next;
    &#125;
&#125;

void divison(Node *source, int n)
&#123;
    &#x2F;&#x2F;值得注意的是，此次传入的应都是尾节点
    int temp &#x3D; 0, ret &#x3D; 0;
    while (source)
    &#123;
        int dividend &#x3D; temp + source-&gt;data; &#x2F;&#x2F;计算过程中的被除数
        int now &#x3D; dividend &#x2F; n;             &#x2F;&#x2F;这里应该是列式计算时，计算符号上面的数
        if (!now)
        &#123;
            temp &#x3D; dividend * 10;
        &#125;
        else
        &#123;
            temp &#x3D; (dividend % n) * 10;
        &#125;
        source-&gt;data &#x3D; now;
        source &#x3D; source-&gt;prev;
    &#125;
&#125;

int main()
&#123;
    &#x2F;&#x2F;必要初始化
    Node *sum &#x3D; createAList();
    Node *num &#x3D; createAList();
    insertNode(num);
    insertNode(sum);
    &#x2F;&#x2F;获得尾结点
    Node *sumTail &#x3D; sum, *numTail &#x3D; num;
    while (sumTail-&gt;next !&#x3D; nullptr)
    &#123;
        sumTail &#x3D; sumTail-&gt;next;
    &#125;
    while (numTail-&gt;next !&#x3D; nullptr)
    &#123;
        numTail &#x3D; numTail-&gt;next;
    &#125;
    &#x2F;&#x2F;从3开始，简化运算
    numTail-&gt;data &#x3D; 3;
    sumTail-&gt;data &#x3D; 3;
    for (int i &#x3D; 1; i &lt; 1000; i++)
    &#123;
        int dividend &#x3D; (2 * i) * (2 * i + 1) * 4;
        int mult &#x3D; (2 * i - 1) * (2 * i - 1);
        &#x2F;&#x2F;先做除法，否则会溢出
        divison(numTail, dividend);
        &#x2F;&#x2F;再做乘法，注意从头结点开始
        multiple(num, mult);
        &#x2F;&#x2F;相加
        add(sum, num);
    &#125;
    &#x2F;&#x2F;指定输出位数输出
    int n;
    std::cin &gt;&gt; n;
    std::cout &lt;&lt; sumTail-&gt;data;
    sumTail &#x3D; sumTail-&gt;prev;
    std::cout &lt;&lt; &quot;.&quot;;
    for (int i &#x3D; 0; i &lt; n - 1; i++)
    &#123;
        std::cout &lt;&lt; sumTail-&gt;data;
        sumTail &#x3D; sumTail-&gt;prev;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你一点没变地复制粘贴上去，肯定会WA，因为我输出的<strong>不是小数点后几位</strong></p>
<p><strong>如果你输入了n输出的是3.1415，所以你只要把倒数第六行n-1改成n就行了。</strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
        <tag>NOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>LOCATE操作（NOJ第6题）</title>
    <url>/2022/03/15/%E9%A2%98%E8%A7%A3/2022-03-15-LOCATE%E6%93%8D%E4%BD%9C%EF%BC%88NOJ%E7%AC%AC6%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目描述">题目描述</h1>
<p><img src="https://s2.loli.net/2022/06/05/4KIBtRjxk3C7wTP.png" alt="1.png"></p>
<h1 id="思路-前言">思路&amp;前言</h1>
<p>这道题的思路很直观。创建循环双链表、填充数据、根据被访问节点增加访问数、根据访问量进行排序、输出即可。</p>
<p>我写的用到的函数如下</p>
<pre class="line-numbers language-none"><code class="language-none">Node *insert(Node *, char x);　　　　　　　　　　　　　　　　&#x2F;&#x2F;插入数据
void init(Node *head, int n);　　　　　　　　　　　　　　　　&#x2F;&#x2F;初始化,n代表该链表节点数
void sort(Node *head, int n);　　　　　　　　　　　　　　　　&#x2F;&#x2F;根据freq排序
void print(Node *head);　　　　　　　　　　　　　　　　　　　 &#x2F;&#x2F;打印结果
void visitChar(Node *head, char *charArray, int n);　　 &#x2F;&#x2F;根据charArray里的数据来增加链表里相应的freq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而我写这个题的题解是为了向您推荐STL。</p>
<p><strong>STL</strong>指的是标准模板库，是C++里的内容。<strong>但是！！！对于这些编程题而言，STL意味着你不用写那些数据结构了！</strong></p>
<p>​		例如： 队列对应queue, 线性表与栈对应vector, 串对应string,等等</p>
<p><strong>同时，它还内置了查找算法，排序算法，去重算法，相信我，对于现阶段的您来说，这些算法比您自己写得快得多！</strong></p>
<p>​	   <strong>但是！！！如果您要入坑C++，请慎重慎重再慎重！！！</strong></p>
<p>​       <strong>大部分你只要把C++当成C with STL就行了</strong></p>
<p>下面开始解题</p>
<h1 id="实现">实现</h1>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Node
&#123;
    char data;
    int freq;
    struct Node *next;
    struct Node *prev;
&#125; Node;

Node *insert(Node *, char x);
void init(Node *head, int n);
void sort(Node *head, int n);
void print(Node *head);
void visitChar(Node *head, char *charArray, int n);

void init(Node *head, int n)
&#123;
    head-&gt;next &#x3D; head;
    head-&gt;prev &#x3D; head;
    head-&gt;freq &#x3D; 0;
    head-&gt;data &#x3D; 0;
    Node *aHead &#x3D; head;
    int i &#x3D; 0;
    while (1)
    &#123;
        if (i &#x3D;&#x3D; n)
        &#123;
            break;
        &#125;
        char c;
        scanf(&quot;%c&quot;, &amp;c);
        if (c !&#x3D; &#39; &#39; &amp;&amp; c !&#x3D; &#39;\n&#39;)
        &#123;
            aHead &#x3D; insert(aHead, c);
            i++;
        &#125;
    &#125;
&#125;

void visitChar(Node *head, char *charArray, int n)
&#123;
    Node *aHead &#x3D; head;
    for (int i &#x3D; 0; i &lt; n; i++)
    &#123;&#x2F;&#x2F;找到链表内对应元素，让它的freq++
        aHead &#x3D; aHead-&gt;next;
        while (aHead-&gt;data !&#x3D; 0)
        &#123;
            if (aHead-&gt;data &#x3D;&#x3D; charArray[i])
            &#123;
                aHead-&gt;freq++;
            &#125;
            aHead &#x3D; aHead-&gt;next;
        &#125;
    &#125;
&#125;

void sort(Node *head, int n)
&#123;&#x2F;&#x2F;根据freq进行排序
    head &#x3D; head-&gt;next;
    while (head-&gt;data !&#x3D; 0)
    &#123;&#x2F;&#x2F;此排序与选择排序类似，相信您能在课本上找到范例
        Node *max &#x3D; head;
        Node *sortNext &#x3D; head-&gt;next;
        while (sortNext-&gt;data !&#x3D; 0)
        &#123;
            if (sortNext-&gt;freq &gt; max-&gt;freq)
            &#123;
                max &#x3D; sortNext;
            &#125;
            sortNext &#x3D; sortNext-&gt;next;
        &#125;
        if (max !&#x3D; head)
        &#123;&#x2F;&#x2F;这里如果不判断会造成死循环
            &#x2F;&#x2F;这里是在移动元素，在纸上画画吧，很好懂的
            max-&gt;next-&gt;prev &#x3D; max-&gt;prev;
            max-&gt;prev-&gt;next &#x3D; max-&gt;next;
            max-&gt;next &#x3D; head;
            max-&gt;prev &#x3D; head-&gt;prev;
            head-&gt;prev-&gt;next &#x3D; max;
            head-&gt;prev &#x3D; max;
        &#125;
        head &#x3D; head-&gt;next;
    &#125;
&#125;

Node *insert(Node *node, char x)
&#123;
    Node *newNode &#x3D; (Node *)malloc(sizeof(Node));
    newNode-&gt;data &#x3D; x;
    newNode-&gt;freq &#x3D; 0;
    &#x2F;&#x2F;下面这一堆是为了插入node元素之后
    newNode-&gt;next &#x3D; node-&gt;next;
    newNode-&gt;prev &#x3D; node;
    node-&gt;next-&gt;prev &#x3D; newNode;
    node-&gt;next &#x3D; newNode;
    &#x2F;&#x2F;为什么要返回这个newNode?为了不让它每次插入都找一次链表尾
    return newNode;
&#125;

void print(Node *head)
&#123;&#x2F;&#x2F;打印输出，没啥可说得
    head &#x3D; head-&gt;next;
    while (head-&gt;data !&#x3D; 0)
    &#123;
        printf(&quot;%c &quot;, head-&gt;data);
        head &#x3D; head-&gt;next;
    &#125;
&#125;

int main()
&#123;
    Node *head &#x3D; (Node *)malloc(sizeof(Node));
    int n, m;
    char visit[1000] &#x3D; &#123;0&#125;;
    scanf(&quot;%d&quot;, &amp;n);
    scanf(&quot;%d&quot;, &amp;m);
    init(head, n);
    int i &#x3D; 0;
    while (1)
    &#123;
        if (i &#x3D;&#x3D; m)
        &#123;
            break;
        &#125;
        char c;
        scanf(&quot;%c&quot;, &amp;c);
        if (c !&#x3D; &#39; &#39; &amp;&amp; c !&#x3D; &#39;\n&#39;)
        &#123;
            visit[i] &#x3D; c;
            i++;
        &#125;
    &#125;
    visitChar(head, visit, m);
    sort(head, n);
    print(head);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注释在上面很清晰地标注出来了。共138行。下来请看STL版本的</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

struct Node
&#123;
    char data;
    int frec;
&#125;;

int main()
&#123;
    vector&lt;Node&gt; list;
    vector&lt;char&gt; willVisit;
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (size_t i &#x3D; 0; i &lt; n; i++)
    &#123;&#x2F;&#x2F;输入数据
        Node m;
        cin &gt;&gt; m.data;
        list.push_back(m);
    &#125;
    for (size_t i &#x3D; 0; i &lt; m; i++)
    &#123;&#x2F;&#x2F;输入数据
        char k;
        cin &gt;&gt; k;
        willVisit.push_back(k);
    &#125;
    for (auto i &#x3D; willVisit.begin(); i &lt; willVisit.end(); i++)
    &#123;&#x2F;&#x2F;根据willVisit递增链表中相应元素
        (find_if(list.begin(), list.end(), [&amp;i](Node &amp;m)
                 &#123; return m.data &#x3D;&#x3D; *i; &#125;))
            -&gt;frec++;
    &#125;
    &#x2F;&#x2F;排序
    sort(list.begin(), list.end(), [](Node &amp;a, Node &amp;b)
         &#123; return a.frec &gt; b.frec; &#125;);
    for (size_t i &#x3D; 0; i &lt; list.size(); i++)
    &#123;&#x2F;&#x2F;输出
        cout &lt;&lt; list[i].data &lt;&lt; &quot; &quot;;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>43行，很简洁吧！</p>
<p>总之，这道题不怎么难，但是如果因为这道题能让您了解到STL，那也算值了！！！</p>
<p>不过，<strong>如果您正在学习数据结构，那么不建议您过度依赖STL，以防止期末上机考试时STL被禁</strong>，但如果您在学习算法，那么STL将成为您的助力！！！</p>
<p>**　　**</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
        <tag>NOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰式（NOJ第8题）</title>
    <url>/2022/03/17/%E9%A2%98%E8%A7%A3/2022-03-17-%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F%EF%BC%88NOJ%E7%AC%AC8%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>对于NOJ，其实我最想吐槽的就是没有测试点输入输出的数据，这样我们只能拿前辈的代码来进行测试。</p>
<p>就像这道题，我一开始全用的栈（因为课本上那道表达式的题用的就是栈），结果搁那耗了将近三个小时才想到合适的数据结构。</p>
<p>而且我在解题的过程中，发现编程题好像就是在让我们钻研数学的本质。让我们在种种限制下起舞。</p>
<p>还是太菜了啊。</p>
<p><img src="https://s2.loli.net/2022/06/07/4dszr2I89GQwxcM.png" alt="1.png"></p>
<h1 id="题目描述">题目描述</h1>
<p><img src="https://s2.loli.net/2022/06/07/rOnCdzmWXJIVgZt.png" alt="2.png"></p>
<p>我们先来看逆波兰式的例子吧</p>
<p><strong>(a+b)(c+d)    ⟶    ab+cd+</strong></p>
<p><strong>(a+(b+c))    ⟶    abc++</strong></p>
<p><strong>(1+2)3/4(7+8)    ⟶    12+34/78+</strong></p>
<p>基本就是以上的形式，愿君看清再做题。</p>
<h1 id="算法设计">算法设计</h1>
<p>在这道题中，我们会遇到六个符号</p>
<center>( ) + - * /</center>
<p>为了保证数字能按照顺序输出，我们使用队列来存储输入数据和其中的运算数</p>
<p>为了能让操作符正确的输出（按照（）、【*、/】、【+、-】）来输出，我们使用栈来保存操作符</p>
<p>而我们又考察到无论什么运算符，左边的都可以优先计算，所以我们从左边开始。</p>
<ol>
<li>
<p>循环地从输入队列（SQ）中取出单个字符</p>
</li>
<li>
<p>①如果是操作数，则入操作数队列（NQ）</p>
</li>
</ol>
<p>②如果是操作符，则：</p>
<p>（1）如果是’(’，则入操作符栈（OS)</p>
<p>（2）如果是’)’,  则：</p>
<p>Ⅰ.让NQ中所有数依次出队并输出</p>
<p>Ⅱ.让OS中所有除’('外地操作符出栈并输出</p>
<p>（3）如果是’*‘或’/’，则：**</p>
<p>Ⅰ.如果下一操作符是’(’,则直接让下一操作符入栈</p>
<p>​								 Ⅱ.如果不是，则先SQ出队并输出，然后OS出栈并输出</p>
<p>(4)  如果是’+‘或’-’，则入OS栈</p>
<p>（5）如果是操作数，则如NQ队列</p>
<p>上述操作完成后，可以保证所有工作地正确地做完。</p>
<h1 id="实现">实现</h1>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;逆波兰式
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

struct Queue
&#123;
    char queue[100];
    int rear &#x3D; 0;
    int front &#x3D; 0;
    char pop()
    &#123;
        char rtn &#x3D; queue[front];
        front++;
        return rtn;
    &#125;
    char getTop()
    &#123;
        return queue[front];
    &#125;
    void push(char x)
    &#123;
        queue[rear] &#x3D; x;
        rear++;
    &#125;
    bool isEmpty()
    &#123;
        return front &gt;&#x3D; rear;
    &#125;
&#125;;

struct Stack
&#123;
    char stack[100];
    int top &#x3D; -1;
    char pop()
    &#123;
        char rtn &#x3D; stack[top];
        top--;
        return rtn;
    &#125;
    char getTop()
    &#123;
        return stack[top];
    &#125;
    void push(char x)
    &#123;
        top++;
        stack[top] &#x3D; x;
    &#125;
    bool isEmpty()
    &#123;
        return top &#x3D;&#x3D; -1;
    &#125;
&#125;;

bool isNormalOperator(char x)
&#123;
    if (x &#x3D;&#x3D; &#39;+&#39; || x &#x3D;&#x3D; &#39;-&#39;)
    &#123;
        return true;
    &#125;
    return false;
&#125;

bool isGreaterOperator(char x)
&#123;
    if (x &#x3D;&#x3D; &#39;*&#39; || x &#x3D;&#x3D; &#39;&#x2F;&#39;)
    &#123;
        return true;
    &#125;
    return false;
&#125;

bool isLeftBracket(char x)
&#123;
    if (x &#x3D;&#x3D; &#39;(&#39;)
    &#123;
        return true;
    &#125;
    return false;
&#125;

bool isRightBracket(char x)
&#123;
    if (x &#x3D;&#x3D; &#39;)&#39;)
    &#123;
        return true;
    &#125;
    return false;
&#125;

int main()
&#123;
    Queue SQ;
    std::cin &gt;&gt; SQ.queue;
    SQ.rear &#x3D; strlen(SQ.queue);
    Stack OS;
    Queue NQ;
    while (!SQ.isEmpty())
    &#123;
        if (isLeftBracket(SQ.getTop()))
        &#123;
            OS.push(SQ.pop());
        &#125;
        else if (isRightBracket(SQ.getTop()))
        &#123;
            char x &#x3D; SQ.pop();
            while (!NQ.isEmpty())
            &#123;
                std::cout &lt;&lt; NQ.pop();
            &#125;
            while (!OS.isEmpty())
            &#123;
                if (isLeftBracket(OS.getTop()) || isRightBracket(OS.getTop()))
                &#123;
                    OS.pop();
                &#125;
                else
                &#123;
                    std::cout &lt;&lt; OS.pop();
                &#125;
            &#125;
        &#125;
        else if (isGreaterOperator(SQ.getTop()))
        &#123;
            OS.push(SQ.pop());
            char x &#x3D; SQ.getTop();
            if (!isLeftBracket(x))
            &#123;
                std::cout &lt;&lt; SQ.pop();
                std::cout &lt;&lt; OS.pop();
            &#125;
            else
            &#123;
                OS.push(SQ.pop());
            &#125;
        &#125;
        else if (isNormalOperator(SQ.getTop()))
        &#123;
            OS.push(SQ.pop());
        &#125;
        else
        &#123;
            NQ.push(SQ.pop());
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最前面的就是对栈和队列的实现，使用C函数可以很容易地实现那些类函数。</p>
<p>我已经把完整的伪代码写在上面了，相信不用再写注释了。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
        <tag>NOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>奇怪的电梯（洛谷P1135）</title>
    <url>/2022/03/19/%E9%A2%98%E8%A7%A3/2022-03-19-%E5%A5%87%E6%80%AA%E7%9A%84%E7%94%B5%E6%A2%AF%EF%BC%88%E6%B4%9B%E8%B0%B7P1135%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言-吐槽">前言&amp;吐槽</h1>
<p>同样可以拿dfs，这道题怎么就难那么多呢？</p>
<h1 id="题目描述">题目描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1135">奇怪的电梯</a></p>
<p><img src="https://s2.loli.net/2022/06/07/Alx2YXHSUzEJ53o.png" alt="1.png"></p>
<h1 id="算法设计">算法设计</h1>
<p>dfs的基本框架就是遍历一个结点的每一条路，所以我们的算法大概可以设计成这样</p>
<pre class="line-numbers language-none"><code class="language-none">void dfsInEveryFloor()
&#123;
    if (当前楼层 &#x3D;&#x3D; 目标楼层)
    &#123;
        做一些操作...
        retrun;
    &#125;
    
    if (满足电梯向上走的条件)
    &#123;
        dfsInEveryFloor();
    &#125;
    if (满足电梯向下走的条件)
    &#123;
        dfsInEveryFloor();
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们假设step是所求的最小次数，sum为某一条路需要的次数，那么可以知道：</p>
<ul>
<li>在一个结点处，无论向上还是向下，sum都应该加1，但是sum本身不应该改变，因为那样sum得出来就不是一条路的次数了，而是多条路的总次数</li>
<li>如果达到了目标，就可以置step了</li>
<li>如果sum已经大于step，那么这个路就已经不是最小的了，直接return结束递归</li>
</ul>
<p>根据上述发现，我们将代码完善一下：</p>
<pre class="line-numbers language-none"><code class="language-none">void dfsInEveryFloor(int now, int sum)
&#123;
    if (now &#x3D;&#x3D; targetFloor)
    &#123;
        step &#x3D; min(step, sum);  &#x2F;&#x2F;sum与step的最小值
        return;
    &#125;
    
    if (sum &gt; step)
    &#123;
        return;
    &#125;
    
    if (now + floor[now] &lt;&#x3D; N)
    &#123;
        dfsInEveryFloor(now + floor[now], sum + 1); &#x2F;&#x2F;如果这里使用sum++，求的是两条路加起来的次数
    &#125;
    if (now - floor[now] &gt; 0)
    &#123;
        dfsInEveryFloor(now - floor[now], sum + 1);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是这并不能解这道题，因为如果楼层的按钮为0的话，会造成无限递归</p>
<p>解决方案是，看看这条路的此结点有没有经过。</p>
<p>我们使用</p>
<pre class="line-numbers language-none"><code class="language-none">bool floorState[205];    &#x2F;&#x2F;因为楼层最多200
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>来保存状态</p>
<p>那么代码可以更改为</p>
<pre class="line-numbers language-none"><code class="language-none">void dfsInEveryFloor(int now, int sum)
&#123;
    if (now &#x3D;&#x3D; targetFloor)
    &#123;
        step &#x3D; min(step, sum); &#x2F;&#x2F; sum与step的最小值
        return;
    &#125;

    if (sum &gt; step)
    &#123;
        return;
    &#125;
    floorState[now] &#x3D; 1;                                        &#x2F;&#x2F;已经过
    if (now + floor[now] &lt;&#x3D; N &amp;&amp; !floorState[now + floor[now]]) &#x2F;&#x2F;下一个结点没经过
    &#123;
        dfsInEveryFloor(now + floor[now], sum + 1); &#x2F;&#x2F;如果这里使用sum++，求的是两条路加起来的次数
    &#125;
    if (now - floor[now] &gt; 0 &amp;&amp; !floorState[now - floor[now]])
    &#123;
        dfsInEveryFloor(now - floor[now], sum + 1);
    &#125;

    floorState[now] &#x3D; 0; &#x2F;&#x2F;接下来要回溯到上一个结点走另一条路，此时已经是不同的路了，因此需要重置状态
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到此为止，算法已经设计完了。接下来就进行实现吧</p>
<h1 id="代码实现">代码实现</h1>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
bool floorState[205] &#x3D; &#123;0&#125;;   &#x2F;&#x2F;记录楼层状态（这条有没有被搜索）
int floorStep[205] &#x3D; &#123;0&#125;;
int N, A, B;
int step &#x3D; 0x7fffff;

void dfs(int now, int sum)
&#123;
    if (now &#x3D;&#x3D; B)
    &#123;
        step &#x3D; min(step, sum);
    &#125;
    &#x2F;&#x2F;因为寻找的是最短路径
    if (sum &gt; step)
    &#123;
        return;
    &#125;
    
    floorState[now] &#x3D; 1;    &#x2F;&#x2F;该层被搜索
    if (now + floorStep[now] &lt;&#x3D; N &amp;&amp; !floorState[now + floorStep[now]])
    &#123;
        dfs(now + floorStep[now], sum + 1);
    &#125;
    if (now - floorStep[now] &gt; 0 &amp;&amp; !floorState[now-floorStep[now]])
    &#123;
        dfs(now - floorStep[now], sum + 1);
    &#125;
    &#x2F;&#x2F;实际上上面那两个已经把当前楼层的情况搜完了
    &#x2F;&#x2F;因此下面需要回溯到新的路径时，需要重置状态
    floorState[now] &#x3D; 0;
&#125;

int main()
&#123;
    cin &gt;&gt; N &gt;&gt; A &gt;&gt; B;
    for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
    &#123;
        cin &gt;&gt; floorStep[i];
    &#125;
    dfs(A, 0);
    if (step !&#x3D; 0x7fffff)
    &#123;
        cout &lt;&lt; step;
    &#125;
    else&#123;
        cout &lt;&lt; -1;
    &#125;
    
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我也是才刚刚学DFS，若有不准确还请指出</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>跳马问题（洛谷P1644）</title>
    <url>/2022/03/19/%E9%A2%98%E8%A7%A3/2022-03-19-%E8%B7%B3%E9%A9%AC%E9%97%AE%E9%A2%98%EF%BC%88%E6%B4%9B%E8%B0%B7P1644%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言-吐槽">前言&amp;吐槽</h1>
<p>这道题用DFS很好做，唯一需要注意的是你正在下<strong>中国象棋</strong>，所以马是不能够向上向下走的，只能斜着走。</p>
<h1 id="题目描述">题目描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1644">跳马问题</a></p>
<p><img src="https://s2.loli.net/2022/06/07/4JWeUQ5oAXZVFdI.png" alt="1.png"></p>
<h1 id="算法设计">算法设计</h1>
<p>使用DFS搜下去就行了</p>
<pre class="line-numbers language-none"><code class="language-none">void DFS()&#123;
    if(满足条件):
        ...
        return;
    if(选择一种分支):
       DFS()
    if(另一种):
       DFS()  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="代码实现">代码实现</h1>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
int sum &#x3D; 0, n, m;

void dfs(int row, int column)
&#123;&#x2F;&#x2F;棋盘上的马已经限定了向右行走，所以只有四种情况
    if (row &#x3D;&#x3D; m &amp;&amp; column &#x3D;&#x3D;n)
    &#123;
        sum++;
    &#125;
    if (row + 1 &lt;&#x3D; m &amp;&amp; column + 2 &lt;&#x3D; n)
    &#123;
        dfs(row + 1, column + 2);
    &#125;
    if (row + 1 &lt;&#x3D; m &amp;&amp; column - 2 &gt;&#x3D; 0)
    &#123;
        dfs(row + 1, column - 2);
    &#125;
    if (row + 2 &lt;&#x3D; m &amp;&amp; column + 1 &lt;&#x3D; n)
    &#123;
        dfs(row + 2, column + 1);
    &#125;
    if (row + 2 &lt;&#x3D; m &amp;&amp; column - 1 &gt;&#x3D; 0)
    &#123;
        dfs(row + 2, column - 1);
    &#125;
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    dfs(0, 0);
    cout &lt;&lt; sum;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>K阶斐波那契数列（NOJ理论第10题）（非精解）</title>
    <url>/2022/03/20/%E9%A2%98%E8%A7%A3/2022-03-20-K%E9%98%B6%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%88NOJ%E7%90%86%E8%AE%BA%E7%AC%AC10%E9%A2%98%EF%BC%89%EF%BC%88%E9%9D%9E%E7%B2%BE%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>这篇文章主要是为了诠释什么叫<strong>k阶斐波那契数列</strong>，以免各位做的时候意味题错了，同时还能水一篇文章。</p>
<p>k阶斐波那契数列<strong>一开始前k-1项都是0，第k项为1，后面生成的每一项都是前数列之前k项的和</strong>。</p>
<h1 id="答案">答案</h1>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;

static int MAXSIZE;

typedef struct CircularQueue
&#123;
    int series[500];
    int rear;
    int front;
&#125; CircularQueue;

void init(CircularQueue *aQueue)
&#123;
    aQueue-&gt;rear &#x3D; aQueue-&gt;front &#x3D; 0;
    
&#125;

int isEmpty(CircularQueue *aQueue)
&#123;
    return aQueue-&gt;front &#x3D;&#x3D; aQueue-&gt;rear;
&#125;

int isFull(CircularQueue *aQueue)
&#123;
    return (aQueue-&gt;rear + 1) % MAXSIZE &#x3D;&#x3D; aQueue-&gt;front;
&#125;

int pop(CircularQueue *aQueue)
&#123;
    int rtn &#x3D; aQueue-&gt;series[aQueue-&gt;front];
    aQueue-&gt;front &#x3D; (aQueue-&gt;front + 1) % MAXSIZE;
    return rtn;
&#125;

void push(CircularQueue *aQueue, int element)
&#123;
    if (!isFull(aQueue))
    &#123;
        aQueue-&gt;series[aQueue-&gt;rear] &#x3D; element;
        aQueue-&gt;rear &#x3D; (aQueue-&gt;rear + 1) % MAXSIZE;
    &#125;
    else
    &#123;
        pop(aQueue);
        aQueue-&gt;series[aQueue-&gt;rear] &#x3D; element;
        aQueue-&gt;rear &#x3D; (aQueue-&gt;rear + 1) % MAXSIZE;
    &#125;
&#125;

void initF(int *F, int k)
&#123;
    for (int i &#x3D; 0; i &lt; k - 1; i++)
    &#123;
        F[i] &#x3D; 0;
    &#125;
    F[k - 1] &#x3D; 1;
&#125;

void pushF(CircularQueue* aQueue, int* F, int k)
&#123;
    for (int i &#x3D; 0; i &lt; k; i++)
    &#123;
        push(aQueue, F[i]);
    &#125;
&#125;

void caculate(int* F, int k)
&#123;
    int newData &#x3D; 0;
    for (int i &#x3D; 0; i &lt; k; i++)
    &#123;
        newData +&#x3D; F[i];
    &#125;
    for (int i &#x3D; 0; i &lt; k - 1; i++)
    &#123;
        F[i] &#x3D; F[i + 1];
    &#125;
    F[k - 1] &#x3D; newData;
&#125;

int main()
&#123;
    int k, max;
    scanf(&quot;%d%d&quot;, &amp;max, &amp;k);
    MAXSIZE &#x3D; k + 1;
    CircularQueue *aQueue &#x3D; (CircularQueue *)malloc(sizeof(CircularQueue));
    init(aQueue);
    int Fibonacci[k];
    initF(Fibonacci, k);
    pushF(aQueue, Fibonacci, k);
    while (1)
    &#123;
        caculate(Fibonacci, k);
        if (Fibonacci[k - 1] &lt;&#x3D; max)
        &#123;
            push(aQueue, Fibonacci[k-1]);
        &#125;
        else
        &#123;
            break;
        &#125;
    &#125;
    
    if (k !&#x3D; 1)
    &#123;
        while (!isEmpty(aQueue))
        &#123;
            printf(&quot;%d &quot;, pop(aQueue));
        &#125;
    &#125;
    else&#123;
        printf(&quot;1&quot;);
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（还就那个淼）</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
        <tag>NOJ</tag>
      </tags>
  </entry>
</search>
