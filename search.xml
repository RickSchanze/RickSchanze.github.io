<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>静态链表</title>
    <url>/2022/02/11/2022-02-11-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>　　虽然我不知道静态链表什么时候用，但学了总有好处</p>
<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>　　1.老师仅仅布置了静态链表的初始化、插入和删除操作，因此我只做这几个。</p>
<p>　　2.本文使用cpp完成。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>　　Component中有两个元素，一个是DataType,这里我使用了string,用来表示存储的元素，另一个是cursor，它的作用与链表节点中的指针一样，用来指出下一个元素的位置</p>
<p>　　不同的是，cursor指出的不再是地址，而是下一个元素在数组中的下标。</p>
<p>　　由此可以看出，<strong>静态链表本质还是链表，我们仍需用出来链表的方式处理静态链表，不能被数组所迷惑。</strong></p>
<p>   下面开始实现。</p>
<h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>　　静态链表，归根结底还是链表，因此首先我们要定义节点。</p>
<pre class="line-numbers language-none"><code class="language-none">#define MAXSIZE 1000     &#x2F;&#x2F;数组最大长度

struct Component
&#123;
    string data &#x3D;  &quot;&quot; ;         &#x2F;&#x2F;数据
    int cursor &#x3D; 0;            &#x2F;&#x2F;游标
&#125;;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　在main函数中，我们定义静态链表</p>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    Component StaticLinkedList[MAXSIZE];      &#x2F;&#x2F;静态链表
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　接下来，我们需要进行初始化</p>
<pre class="line-numbers language-none"><code class="language-none">void initLinkedList(Component* list)
&#123;
    int cnt &#x3D; 1;
    for ( int i &#x3D; 0; i &lt; MAXSIZE - 1; i++)
    &#123;
        list[i].cursor &#x3D; i++;                  &#x2F;&#x2F;初始化时每个节点的cursor指出
    &#125;                                                     &#x2F;&#x2F;下一个节点的位置，而最后一个
    list[MAXSIZE - 1].cursor &#x3D; 0;            &#x2F;&#x2F;节点的cursor为0，指向头节点
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　无论插入还是删除，我们都需要找到元素。</p>
<pre class="line-numbers language-none"><code class="language-none">Component&amp; find(string input, Component* list)
&#123; &#x2F;&#x2F;返回component的引用，这样可以修改数组中的元素，而无需使用指针
    int curEle &#x3D; list[0].cursor;
    while (list[curEle].cursor !&#x3D; 0 &amp;&amp; list[curEle].data !&#x3D;  &quot;&quot; )　　　　 &#x2F;&#x2F;初始化时每个元素都为空，因此以此为条件
    &#123;
        if (list[curEle].data &#x3D;&#x3D; input)
        &#123;
            return list[curEle];
        &#125;
        else
        &#123;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
    return list[curEle];　　 &#x2F;&#x2F;当找不到时返回的元素
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　</p>
<p>　　当我们插入元素时，我们需要将最后一个非空元素后面的那一个元素使用，将数据保存在那个元素里。</p>
<p><img src="https://s2.loli.net/2022/05/25/DzMxsWebVGNQjS2.png" alt="当前长度" title="当前长度"></p>
<p>　　这里是将元素出入指定元素之后</p>
<pre class="line-numbers language-none"><code class="language-none">void insertAfter(string input, string query, Component* list)
&#123; &#x2F;&#x2F;与链表插入几乎一样的手法，无需多言
    currenLength++;
    Component&amp; target &#x3D; find(query, list);
    list[currenLength].data &#x3D; input;
    list[currenLength].cursor &#x3D; target.cursor;
    target.cursor &#x3D; currenLength;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　删除元素</p>
<pre class="line-numbers language-none"><code class="language-none">void deleteElement(string query, Component* list)
&#123;
    if (query &#x3D;&#x3D;  &quot;&quot; )
    &#123;
        cout &lt;&lt;  &quot;you didn&#39;t input anything.&quot; ;
        return ;
    &#125;
    Component&amp; target &#x3D; find(query, list);
    if (target.data !&#x3D; query)
    &#123;
        cout &lt;&lt;  &quot;the element you input does not exist in the list.&quot; ;
        return ;
    &#125;
    int curEle &#x3D; 0;
    int pre;
    while (1)　　 &#x2F;&#x2F;需要寻找指定元素之前的元素
    &#123;
        if (list[curEle].data &#x3D;&#x3D; query)
        &#123;
            list[pre].cursor &#x3D; list[curEle].cursor;
            list[curEle].cursor &#x3D; -1;
            list[curEle].data &#x3D;  &quot;&quot; ;
            break ;
        &#125;
        else
        &#123;
            pre &#x3D; curEle;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　<strong>完整代码：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include 
#include 
using namespace std;
#define MAXSIZE 1000
struct Component
&#123;
    string data &#x3D;  &quot;&quot; ;
    int cursor &#x3D; 0;
&#125;;

static int currenLength &#x3D; 0;

Component&amp; find(string input, Component* list)
&#123;
    int curEle &#x3D; list[0].cursor;
    while (list[curEle].cursor !&#x3D; 0 &amp;&amp; list[curEle].data !&#x3D;  &quot;&quot; )
    &#123;
        if (list[curEle].data &#x3D;&#x3D; input)
        &#123;
            return list[curEle];
        &#125;
        else
        &#123;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
    return list[curEle];
&#125;

void insertAfter(string input, string query, Component* list)
&#123;
    currenLength++;
    Component&amp; target &#x3D; find(query, list);
    list[currenLength].data &#x3D; input;
    list[currenLength].cursor &#x3D; target.cursor;
    target.cursor &#x3D; currenLength;
&#125;

void deleteElement(string query, Component* list)
&#123;
    if (query &#x3D;&#x3D;  &quot;&quot; )
    &#123;
        cout &lt;&lt;  &quot;you didn&#39;t input anything.&quot; ;
        return ;
    &#125;
    Component&amp; target &#x3D; find(query, list);
    if (target.data !&#x3D; query)
    &#123;
        cout &lt;&lt;  &quot;the element you input does not exist in the list.&quot; ;
        return ;
    &#125;
    int curEle &#x3D; 0;
    int pre;
    while (1)
    &#123;
        if (list[curEle].data &#x3D;&#x3D; query)
        &#123;
            list[pre].cursor &#x3D; list[curEle].cursor;
            list[curEle].cursor &#x3D; -1;
            list[curEle].data &#x3D;  &quot;&quot; ;
            break ;
        &#125;
        else
        &#123;
            pre &#x3D; curEle;
            curEle &#x3D; list[curEle].cursor;
        &#125;
    &#125;
&#125;

void initLinkedList(Component* list)
&#123;
    int cnt &#x3D; 1;
    for ( int i &#x3D; 0; i &lt; MAXSIZE - 1; i++)
    &#123;
        list[i].cursor &#x3D; i++;
    &#125;
    list[MAXSIZE - 1].cursor &#x3D; 0;
&#125;
int main()
&#123;
   
    Component StaticLinkedList[MAXSIZE];
    initLinkedList(StaticLinkedList);
    string input, query, deleteMent;
    while (1) &#123;
        cin &gt;&gt; input &gt;&gt; query &gt;&gt; deleteMent;
        insertAfter(input, query, StaticLinkedList);
        deleteElement(deleteMent, StaticLinkedList);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　</p>
<h3 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h3><p>　　这就是静态链表这几个操作了，我经过VS调试后并未出现异常</p>
<p>　　如有看不懂，或错误的地方，欢迎讨论。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>双链表</title>
    <url>/2022/02/14/2022-02-14-%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>　　相比单链表，双链表提供了prev指针，使得其在处理一些操作时更为简单。</p>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>　　1.这里的双链表使用C++实现</p>
<p>　　2.只完成了插入删除操作</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　<img src="https://s2.loli.net/2022/05/25/3LFDGZJONKn98y4.png"></p>
<p>　　如上图所示，next指向下一个，而prev指向前一个，只要适当调整指针指向，即可完成双链表</p>
<h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>　　首先，需要定义表示节点的结构体:</p>
<pre class="line-numbers language-none"><code class="language-none">struct node
&#123;
	string data;
	node* next;		&#x2F;&#x2F;指向下一个元素
	node* prev;		&#x2F;&#x2F;指向前一个元素
	node()                　&#x2F;&#x2F;构造函数，用于在创建新节点时自动初始化    
	&#123;
		data &#x3D; &quot;&quot;;
		prev &#x3D; NULL;
		next &#x3D; NULL;
	&#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　这里我为了在字面上区分节点和链表的区别，使用了</p>
<p><img src="https://s2.loli.net/2022/05/25/5OE78YwUT1kyhrp.png"></p>
<p>　　接下来创建链表，实际上是创造了一个节点，将其作为头结点。</p>
<pre class="line-numbers language-none"><code class="language-none">doubleLinkedList* createList()
&#123;
	node* list &#x3D; new node();　　&#x2F;&#x2F;这种方式返回不会存在局部变量内存销毁的问题，因为它是new出来的
	return list;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　插入操作</p>
<pre class="line-numbers language-none"><code class="language-none">void insert(node* position, string input)
&#123;&#x2F;&#x2F;position是插入的位置，input是插入数据的data
	node* newNode &#x3D; new node();
	&lt;strong&gt;newNode-&gt;data &#x3D; input;				&#x2F;&#x2F;先处理新创造的节点
	newNode-&gt;next &#x3D; position-&gt;next;		　　　　 &#x2F;&#x2F;如果不对新节点优先处理，会造成找不到节点的清空，造成野指针
	newNode-&gt;prev &#x3D; position;
	if (position-&gt;next !&#x3D; NULL) &#123;　　　　　　　　　　　　&#x2F;&#x2F;如果不进行判断，可能会对NULL操作而错误
		position-&gt;next-&gt;prev &#x3D; newNode;
		position-&gt;next &#x3D; newNode;
	&#125;
	else &#123;
		position-&gt;next &#x3D; newNode;
	&#125;&lt;&#x2F;strong&gt;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　</p>
<pre class="line-numbers language-none"><code class="language-none">void deleteElement(node* ele)
&#123;
	ele-&gt;prev-&gt;next &#x3D; ele-&gt;next;
	if (ele-&gt;next !&#x3D; NULL)
	&#123;
		ele-&gt;next-&gt;prev &#x3D; ele-&gt;prev;
	&#125;
	else
	&#123;&#x2F;&#x2F;ele-&gt;next为空时不需要做什么了
	&#125;
	delete ele;　　　　&#x2F;&#x2F;必须删除，否则长时间可能造成内存泄漏
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　</p>
<p>　　查找操作</p>
<pre class="line-numbers language-none"><code class="language-none">node* find(string input, doubleLinkedList* list)
&#123;&#x2F;&#x2F;与单链表差不多
	doubleLinkedList* L &#x3D; list;
	while (L !&#x3D; NULL)
	&#123;
		if (L-&gt;data &#x3D;&#x3D; input)
		&#123;
			return L;
		&#125;
		else
		&#123;
			L &#x3D; L-&gt;next;
		&#125;
	&#125;
	return NULL;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　<strong>完整代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
struct node
&#123;
	string data;
	node* next;		&#x2F;&#x2F;指向下一个元素
	node* prev;		&#x2F;&#x2F;指向前一个元素
	node()
	&#123;
		data &#x3D; &quot;&quot;;
		prev &#x3D; NULL;
		next &#x3D; NULL;
	&#125;
&#125;;

using doubleLinkedList &#x3D; node;

void insert(node* position, string input)
&#123;&#x2F;&#x2F;position是插入的位置，input是插入数据的data
	node* newNode &#x3D; new node();
	newNode-&gt;data &#x3D; input;				&#x2F;&#x2F;先处理新创造的节点
	newNode-&gt;next &#x3D; position-&gt;next;		
	newNode-&gt;prev &#x3D; position;
	if (position-&gt;next !&#x3D; NULL) &#123;
		position-&gt;next-&gt;prev &#x3D; newNode;
		position-&gt;next &#x3D; newNode;
	&#125;
	else &#123;
		position-&gt;next &#x3D; newNode;
	&#125;
&#125;

void deleteElement(node* ele)
&#123;
	ele-&gt;prev-&gt;next &#x3D; ele-&gt;next;
	if (ele-&gt;next !&#x3D; NULL)
	&#123;
		ele-&gt;next-&gt;prev &#x3D; ele-&gt;prev;
	&#125;
	else
	&#123;
	&#125;
	delete ele;
&#125;

node* find(string input, doubleLinkedList* list)
&#123;
	doubleLinkedList* L &#x3D; list;
	while (L !&#x3D; NULL)
	&#123;
		if (L-&gt;data &#x3D;&#x3D; input)
		&#123;
			return L;
		&#125;
		else
		&#123;
			L &#x3D; L-&gt;next;
		&#125;
	&#125;
	return NULL;
&#125;

doubleLinkedList* createList()
&#123;
	node* list &#x3D; new node();
	return list;
&#125;

int main()
&#123;
	doubleLinkedList* list &#x3D; createList();
	while (true)
	&#123;
		int j;
		cin &gt;&gt; j;
		if (j &#x3D;&#x3D; 1)
		&#123;
			string query, input;
			cin &gt;&gt; input;
			insert(list, input);
		&#125;
		else
		&#123;
			string query;
			cin &gt;&gt; query;
			deleteElement(find(query, list));
		&#125;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　此代码已经本人VS调试测试，暂时没有发现什么问题</p>
<p>　　如果由不懂的或错误的，欢迎评论或加QQ私聊！</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QGuiApplication</title>
    <url>/2022/03/01/2022-03-01-QGuiApplication/</url>
    <content><![CDATA[<h1 id="primaryScreen"><a href="#primaryScreen" class="headerlink" title="primaryScreen()"></a>primaryScreen()</h1><p>获取应用主屏幕</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>关于函数体内指针指向问题</title>
    <url>/2022/02/16/2022-02-16-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>　　今天在做一道题的时候，发现了一个问题，那就是函数的执行会不会改变指针指向的问题。</p>
<p>　　下面来诠释此问题。</p>
<p>　　</p>
<p>　　首先，我们用一段代码创建了一个具有10个节点的链表（不算头结点）：</p>
<pre class="line-numbers language-none"><code class="language-none">struct test &#123;
	int data;
	test* next &#x3D; NULL;
&#125;;

test* createList()
&#123;
	test* list &#x3D; new test;
	test* ret &#x3D; list;
	for (int i &#x3D; 0; i &lt; 10; i++)
	&#123;
		test* newNode &#x3D; new test;
		newNode-&gt;data &#x3D; i;
		list-&gt;next &#x3D; newNode;
		list &#x3D; list-&gt;next;
	&#125;
	return ret;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　我们有一个测试函数来改变指针：</p>
<pre class="line-numbers language-none"><code class="language-none">void changePoint(test* list)
&#123;
	list &#x3D; list-&gt;next;
&#125;

int main()
&#123;
	test* testlist &#x3D; createList();
	changePoint(testlist);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　下面开始调试，将断点设置在函数changePoint中，得到如下结果：</p>
<p><img src="https://s2.loli.net/2022/05/26/YQ4jAtaXq9swDVN.png" alt="1.png"></p>
<p><img src="https://s2.loli.net/2022/05/26/xCjGmJqbHD4QSVA.png" alt="2.png"></p>
<p>　　可见在函数体内部，指针是被改变了的。</p>
<p>　　但在函数执行完毕后，指针又变成了原来未被改变的：</p>
<p><img src="https://s2.loli.net/2022/05/26/PvFCebwK7R2ziWI.png" alt="3.png"></p>
<p>　　如果想要同时更改函数体内和函数体外的指针的值，可以使用<strong>指针的引用.</strong></p>
<pre class="line-numbers language-none"><code class="language-none">void changePoint(test* &amp;list)
&#123;
	list &#x3D; list-&gt;next;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>　　可以发现，指针被顺利改写。</p>
<p><strong><img src="https://s2.loli.net/2022/05/26/YsUfb5eViRh8P3u.png" alt="4.png"></strong></p>
<p><img src="https://s2.loli.net/2022/05/26/irTmSIPNge8VUM6.png" alt="5.png"></p>
<p>　</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>细节问题</tag>
      </tags>
  </entry>
  <entry>
    <title>QScreen</title>
    <url>/2022/03/01/2022-03-01-QScreen/</url>
    <content><![CDATA[<h1 id="availableGeometry"><a href="#availableGeometry" class="headerlink" title="availableGeometry()"></a>availableGeometry()</h1><p>获取应用程序可用区域</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>QSystemTrayIcon</title>
    <url>/2022/03/01/2022-03-01-QSystemTrayIcon/</url>
    <content><![CDATA[<p>此类用于在系统托盘中添加应用图标</p>
<h1 id="toolTip"><a href="#toolTip" class="headerlink" title="toolTip"></a>toolTip</h1><p>托盘工具提示，你把鼠标放在图标上时出现的文字</p>
<p>使用setTooTip()设置</p>
<h1 id="show"><a href="#show" class="headerlink" title="show()"></a>show()</h1><p>在托盘显示你对象拥有的图标</p>
<h1 id="setContextMenu-Qmenu"><a href="#setContextMenu-Qmenu" class="headerlink" title="setContextMenu(Qmenu*)"></a>setContextMenu(Qmenu*)</h1><p>设置用户通过鼠标事件来弹出的菜单（比如右键弹出菜单）</p>
]]></content>
      <categories>
        <category>Qt API</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>QWebEngineView</title>
    <url>/2022/03/01/2022-03-01-QWebEngineView/</url>
    <content><![CDATA[<h1 id="page"><a href="#page" class="headerlink" title="page()"></a>page()</h1><p>返回一个指向页面的指针，为QWebEnginePage*</p>
<h1 id="load"><a href="#load" class="headerlink" title="load()"></a>load()</h1><p>加载特定URL并展示它，不过视图保持不变，直到到达足够的数据以显示新 URL</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>QWidget</title>
    <url>/2022/03/01/2022-03-01-QWidget/</url>
    <content><![CDATA[<p><strong>Qt::WA_TranslucentBackground</strong></p>
<p>为你的控件设置透明背景，因为这个标志会使你的控件拥有一个阿尔法通道。这个属性一旦被设置，<strong>WA_NoSystemBackground</strong>则也被设置。在Windows上你的控件也需要设置窗口标志<strong>Qt::FramelessWindowHint</strong></p>
<p><strong>Qt::WA_NoSystemBackground</strong></p>
<p>这个标志被设置意味着你的控件没有背景，即当控件接受绘画事件时，背景不会被自动重绘。</p>
<p>注意：不像<strong>WA_OpaquePaintEvent</strong>, 新曝光区域的背景永远不会被填充</p>
<p><strong>Qt::WA_OpaquePaintEvent</strong></p>
<p>收到绘制事件时，绘制控件拥有的所有像素。但是不会重绘之前绘制的东西</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>QPainter</title>
    <url>/2022/03/02/2022-03-02-QPainter/</url>
    <content><![CDATA[<h2 id="void-translate-const-QPointF-amp-offset"><a href="#void-translate-const-QPointF-amp-offset" class="headerlink" title="void translate(const QPointF &amp;offset)"></a><strong><strong>void translate(const QPointF &amp;offset)</strong></strong></h2><p>按照给定偏移量平移坐标系(重设坐标原点)</p>
<h2 id="void-scale-qreal-sx-qreal-sy"><a href="#void-scale-qreal-sx-qreal-sy" class="headerlink" title="void scale(qreal sx, qreal sy)"></a><strong><strong>void scale(qreal sx, qreal sy)</strong></strong></h2><p>按 （sx， sy） 缩放坐标系。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="void-QPainter-rotate-qreal-angle"><a href="#void-QPainter-rotate-qreal-angle" class="headerlink" title="void QPainter::rotate(qreal angle)"></a><strong>void QPainter::rotate(qreal angle)</strong></h2><p>顺时针旋转坐标系。给定的角度参数以度为单位。</p>
<h2 id="void-QPainter-drawPixmap-const-QRectF-amp-target-const-QPixmap-amp-pixmap-const-QRectF-amp-source"><a href="#void-QPainter-drawPixmap-const-QRectF-amp-target-const-QPixmap-amp-pixmap-const-QRectF-amp-source" class="headerlink" title="void QPainter::drawPixmap(const QRectF &amp;target, const QPixmap &amp;pixmap, const QRectF &amp;source)"></a><strong>void QPainter::drawPixmap(const QRectF &amp;target, const QPixmap &amp;pixmap, const QRectF &amp;source)</strong></h2><p>将给定位图的矩形部分源绘制到绘制设备中的给定目标中</p>
<p>此函数有重载，详请查看帮助文档</p>
<p>此函数主要用于绘制图片</p>
<h2 id="void-QPainter-drawPolygon-const-QPointF-points-int-pointCount-Qt-FillRule-fillRule-x3D-Qt-OddEvenFill"><a href="#void-QPainter-drawPolygon-const-QPointF-points-int-pointCount-Qt-FillRule-fillRule-x3D-Qt-OddEvenFill" class="headerlink" title="*void QPainter::drawPolygon(const QPointF points, int pointCount, Qt::FillRule fillRule &#x3D; Qt::OddEvenFill)"></a>*<em>void QPainter::drawPolygon(const QPointF <em>points, int pointCount, Qt::FillRule fillRule &#x3D; Qt::OddEvenFill)</em></em></h2><p>使用points里的前pointCount个点进行多边形绘图</p>
<p>第一个点隐式连接到最后一个点，并且多边形用当前画笔填充。<strong>Qt::FillRule</strong><br>|Qt::OddEvenFill|0|指定该区域使用奇偶填充规则填充。有了这条规则，我们可以用下面的方法来确定一个点是否在形状内部。从这一点画一条水平线到形状外面的一个位置，并计算交点的数量。如果交点个数是奇数，则该点在形状内。此模式为默认模式。<br>|Qt::WindingFill|1|Specifies that the region is filled using the non zero winding rule. With this rule, we determine whether a point is inside the shape by using the following method. Draw a horizontal line from the point to a location outside the shape. Determine whether the direction of the line at each intersection point is up or down. The winding number is determined by summing the direction of each intersection. If the number is non zero, the point is inside the shape. This fill mode can also in most cases be considered as the intersection of closed shapes.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="bool-QPainter-begin-QPaintDevice-device"><a href="#bool-QPainter-begin-QPaintDevice-device" class="headerlink" title="*bool QPainter::begin(QPaintDevice device)"></a>*<em>bool QPainter::begin(QPaintDevice <em>device)</em></em></h2><p>开始在绘图设备上绘图，如果成功返回true;否则返回false。</p>
<p>请注意，当调用begin()时，所有的painter的设置(setPen()， setBrush()等)都被重置为默认值。</p>
<p>请注意，大多数情况下，您可以使用其中一个构造函数来代替begin()，end()函数会在painter销毁时自动进行</p>
<p><strong>警告:一个绘画装置一次只能由一个画家进行绘画。</strong></p>
<p><strong>警告:不支持在QImage::Format_Indexed8格式的QImage上绘画。</strong></p>
<h2 id="bool-QPainter-end"><a href="#bool-QPainter-end" class="headerlink" title="bool QPainter::end()"></a><strong><strong>bool QPainter::end()</strong></strong></h2><p>绘制结束。绘制时使用的任何资源将被释放。通常不需要调用它，因为它是由析构函数调用的。</p>
<p>如果绘制器不再活动，则返回true;否则返回false。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
